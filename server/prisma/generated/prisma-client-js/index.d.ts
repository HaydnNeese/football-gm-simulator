
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model PlayerContract
 * 
 */
export type PlayerContract = $Result.DefaultSelection<Prisma.$PlayerContractPayload>
/**
 * Model ContractBonus
 * 
 */
export type ContractBonus = $Result.DefaultSelection<Prisma.$ContractBonusPayload>
/**
 * Model SalaryByYear
 * 
 */
export type SalaryByYear = $Result.DefaultSelection<Prisma.$SalaryByYearPayload>
/**
 * Model CapHitByYear
 * 
 */
export type CapHitByYear = $Result.DefaultSelection<Prisma.$CapHitByYearPayload>
/**
 * Model DeadCapByYear
 * 
 */
export type DeadCapByYear = $Result.DefaultSelection<Prisma.$DeadCapByYearPayload>
/**
 * Model OptOutYear
 * 
 */
export type OptOutYear = $Result.DefaultSelection<Prisma.$OptOutYearPayload>
/**
 * Model RestructureEvent
 * 
 */
export type RestructureEvent = $Result.DefaultSelection<Prisma.$RestructureEventPayload>
/**
 * Model ContractClause
 * 
 */
export type ContractClause = $Result.DefaultSelection<Prisma.$ContractClausePayload>
/**
 * Model PerformanceBonus
 * 
 */
export type PerformanceBonus = $Result.DefaultSelection<Prisma.$PerformanceBonusPayload>
/**
 * Model StatMilestone
 * 
 */
export type StatMilestone = $Result.DefaultSelection<Prisma.$StatMilestonePayload>
/**
 * Model RosterBonus
 * 
 */
export type RosterBonus = $Result.DefaultSelection<Prisma.$RosterBonusPayload>
/**
 * Model WorkoutBonus
 * 
 */
export type WorkoutBonus = $Result.DefaultSelection<Prisma.$WorkoutBonusPayload>
/**
 * Model OptionBonus
 * 
 */
export type OptionBonus = $Result.DefaultSelection<Prisma.$OptionBonusPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Stat
 * 
 */
export type Stat = $Result.DefaultSelection<Prisma.$StatPayload>
/**
 * Model ContractDesires
 * 
 */
export type ContractDesires = $Result.DefaultSelection<Prisma.$ContractDesiresPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlayerRoleEnum: {
  STARTER: 'STARTER',
  ROLE_PLAYER: 'ROLE_PLAYER',
  BACKUP: 'BACKUP',
  SPECIAL_TEAMS: 'SPECIAL_TEAMS',
  MENTOR: 'MENTOR'
};

export type PlayerRoleEnum = (typeof PlayerRoleEnum)[keyof typeof PlayerRoleEnum]


export const FootballRecordEnum: {
  CareerPassingYards: 'CareerPassingYards',
  CareerPassingTouchdowns: 'CareerPassingTouchdowns',
  SingleSeasonPassingYards: 'SingleSeasonPassingYards',
  SingleSeasonPassingTouchdowns: 'SingleSeasonPassingTouchdowns',
  SingleGamePassingYards: 'SingleGamePassingYards',
  SingleGamePassingTouchdowns: 'SingleGamePassingTouchdowns',
  CareerRushingYards: 'CareerRushingYards',
  CareerRushingTouchdowns: 'CareerRushingTouchdowns',
  SingleSeasonRushingYards: 'SingleSeasonRushingYards',
  SingleSeasonRushingTouchdowns: 'SingleSeasonRushingTouchdowns',
  SingleGameRushingYards: 'SingleGameRushingYards',
  SingleGameRushingTouchdowns: 'SingleGameRushingTouchdowns',
  CareerReceivingYards: 'CareerReceivingYards',
  CareerReceivingTouchdowns: 'CareerReceivingTouchdowns',
  SingleSeasonReceivingYards: 'SingleSeasonReceivingYards',
  SingleSeasonReceivingTouchdowns: 'SingleSeasonReceivingTouchdowns',
  SingleGameReceivingYards: 'SingleGameReceivingYards',
  SingleGameReceivingTouchdowns: 'SingleGameReceivingTouchdowns',
  CareerSacks: 'CareerSacks',
  CareerInterceptions: 'CareerInterceptions',
  SingleSeasonSacks: 'SingleSeasonSacks',
  SingleSeasonInterceptions: 'SingleSeasonInterceptions',
  SingleGameSacks: 'SingleGameSacks',
  SingleGameInterceptions: 'SingleGameInterceptions',
  LongestFieldGoal: 'LongestFieldGoal',
  MostFieldGoalsSingleGame: 'MostFieldGoalsSingleGame',
  MostFieldGoalsSeason: 'MostFieldGoalsSeason',
  CareerFieldGoalsMade: 'CareerFieldGoalsMade',
  LongestKickReturn: 'LongestKickReturn',
  LongestPuntReturn: 'LongestPuntReturn',
  MostKickReturnTouchdowns: 'MostKickReturnTouchdowns',
  MostPuntReturnTouchdowns: 'MostPuntReturnTouchdowns',
  LongestWinStreak: 'LongestWinStreak',
  MostWinsSeason: 'MostWinsSeason',
  MostPointsScoredSeason: 'MostPointsScoredSeason',
  MostPointsScoredGame: 'MostPointsScoredGame',
  MostGamesPlayed: 'MostGamesPlayed',
  MostProBowls: 'MostProBowls',
  MostMVPs: 'MostMVPs',
  MostChampionships: 'MostChampionships'
};

export type FootballRecordEnum = (typeof FootballRecordEnum)[keyof typeof FootballRecordEnum]


export const InjuryTypeEnum: {
  Concussion: 'Concussion',
  NeckStrain: 'NeckStrain',
  Stinger: 'Stinger',
  ShoulderDislocation: 'ShoulderDislocation',
  RotatorCuffTear: 'RotatorCuffTear',
  BrokenCollarbone: 'BrokenCollarbone',
  ACJointSprain: 'ACJointSprain',
  ElbowSprain: 'ElbowSprain',
  BrokenArm: 'BrokenArm',
  WristFracture: 'WristFracture',
  DislocatedFinger: 'DislocatedFinger',
  BrokenFinger: 'BrokenFinger',
  ThumbSprain: 'ThumbSprain',
  RibFracture: 'RibFracture',
  AbdominalStrain: 'AbdominalStrain',
  Hernia: 'Hernia',
  LowerBackStrain: 'LowerBackStrain',
  HipPointer: 'HipPointer',
  GroinStrain: 'GroinStrain',
  HamstringStrain: 'HamstringStrain',
  QuadStrain: 'QuadStrain',
  KneeSprain: 'KneeSprain',
  ACLTear: 'ACLTear',
  MCLTear: 'MCLTear',
  LCLTear: 'LCLTear',
  PCLTear: 'PCLTear',
  MeniscusTear: 'MeniscusTear',
  PatellarTendinitis: 'PatellarTendinitis',
  AnkleSprain: 'AnkleSprain',
  HighAnkleSprain: 'HighAnkleSprain',
  AchillesTear: 'AchillesTear',
  TurfToe: 'TurfToe',
  BrokenFoot: 'BrokenFoot',
  ToeFracture: 'ToeFracture',
  Contusion: 'Contusion',
  Cramping: 'Cramping',
  Fatigue: 'Fatigue',
  Dehydration: 'Dehydration'
};

export type InjuryTypeEnum = (typeof InjuryTypeEnum)[keyof typeof InjuryTypeEnum]


export const OffFieldConcernTypeEnum: {
  LegalTrouble: 'LegalTrouble',
  BehavioralIssues: 'BehavioralIssues',
  CommitmentConcerns: 'CommitmentConcerns',
  MediaDistractions: 'MediaDistractions',
  LockerRoomTension: 'LockerRoomTension',
  CoachingConflict: 'CoachingConflict',
  SubstanceIssues: 'SubstanceIssues',
  MotivationConcerns: 'MotivationConcerns',
  ConditioningIssues: 'ConditioningIssues',
  ReputationRisk: 'ReputationRisk',
  ContractDispute: 'ContractDispute',
  AgentConflict: 'AgentConflict',
  MaturityQuestions: 'MaturityQuestions',
  FocusConcerns: 'FocusConcerns'
};

export type OffFieldConcernTypeEnum = (typeof OffFieldConcernTypeEnum)[keyof typeof OffFieldConcernTypeEnum]


export const PlayerPersonalityTraitEnum: {
  Leader: 'Leader',
  HardWorker: 'HardWorker',
  Lazy: 'Lazy',
  Coachable: 'Coachable',
  Uncoachable: 'Uncoachable',
  Perfectionist: 'Perfectionist',
  Slacker: 'Slacker',
  Mentor: 'Mentor',
  Respected: 'Respected',
  Delegator: 'Delegator',
  Micromanager: 'Micromanager',
  Punctual: 'Punctual',
  ChronicallyLate: 'ChronicallyLate',
  Humble: 'Humble',
  Arrogant: 'Arrogant',
  Diva: 'Diva',
  TeamPlayer: 'TeamPlayer',
  Selfish: 'Selfish',
  FameDriven: 'FameDriven',
  MoneyDriven: 'MoneyDriven',
  GloryHunter: 'GloryHunter',
  Loyal: 'Loyal',
  Disloyal: 'Disloyal',
  Entitled: 'Entitled',
  SelfMotivated: 'SelfMotivated',
  NeedsValidation: 'NeedsValidation',
  PeoplePleaser: 'PeoplePleaser',
  ClutchPerformer: 'ClutchPerformer',
  Choker: 'Choker',
  Inconsistent: 'Inconsistent',
  GameChanger: 'GameChanger',
  Dependable: 'Dependable',
  MomentumPlayer: 'MomentumPlayer',
  ConfidenceDriven: 'ConfidenceDriven',
  PressureResistant: 'PressureResistant',
  Overthinks: 'Overthinks',
  GameManager: 'GameManager',
  Disruptive: 'Disruptive',
  LockerRoomCancer: 'LockerRoomCancer',
  Mediator: 'Mediator',
  Comedian: 'Comedian',
  SilentProfessional: 'SilentProfessional',
  DramaSeeker: 'DramaSeeker',
  TeamDad: 'TeamDad',
  Bully: 'Bully',
  Instigator: 'Instigator',
  Unifier: 'Unifier',
  PartyAnimal: 'PartyAnimal',
  CleanLiving: 'CleanLiving',
  RuleFollower: 'RuleFollower',
  RuleBreaker: 'RuleBreaker',
  Focused: 'Focused',
  Distracted: 'Distracted',
  OffFieldIssues: 'OffFieldIssues',
  MediaTrained: 'MediaTrained',
  Reckless: 'Reckless',
  StraightEdge: 'StraightEdge',
  WorkLifeBalanced: 'WorkLifeBalanced',
  Overworked: 'Overworked',
  NightOwl: 'NightOwl',
  EarlyRiser: 'EarlyRiser',
  HighFootballIQ: 'HighFootballIQ',
  LowFootballIQ: 'LowFootballIQ',
  FilmJunkie: 'FilmJunkie',
  Unprepared: 'Unprepared',
  Studious: 'Studious',
  Forgetful: 'Forgetful',
  SystemThinker: 'SystemThinker',
  Instinctive: 'Instinctive',
  VisualLearner: 'VisualLearner',
  NeedsRepetition: 'NeedsRepetition',
  InjuryProne: 'InjuryProne',
  Durable: 'Durable',
  SlowStarter: 'SlowStarter',
  HotStarter: 'HotStarter',
  AlwaysWarmedUp: 'AlwaysWarmedUp',
  StrugglesWithConditioning: 'StrugglesWithConditioning',
  BodyLanguageProblem: 'BodyLanguageProblem',
  VocalMotivator: 'VocalMotivator',
  FanFavorite: 'FanFavorite',
  MediaDarling: 'MediaDarling',
  MediaNightmare: 'MediaNightmare',
  Marketable: 'Marketable',
  Forgettable: 'Forgettable',
  SocialMediaSavvy: 'SocialMediaSavvy',
  BrandBuilder: 'BrandBuilder',
  AntiMedia: 'AntiMedia',
  ReluctantStar: 'ReluctantStar',
  Flashy: 'Flashy',
  WantsChampionships: 'WantsChampionships',
  WantsStats: 'WantsStats',
  WantsLegacy: 'WantsLegacy',
  RingChaser: 'RingChaser',
  CareerFocused: 'CareerFocused',
  FamilyFocused: 'FamilyFocused',
  PassionForGame: 'PassionForGame',
  WantsToCoach: 'WantsToCoach',
  WantsOut: 'WantsOut',
  LookingForNextContract: 'LookingForNextContract',
  Resilient: 'Resilient',
  Moody: 'Moody',
  Calm: 'Calm',
  ShortTempered: 'ShortTempered',
  Anxious: 'Anxious',
  Optimist: 'Optimist',
  Pessimist: 'Pessimist',
  Adaptable: 'Adaptable',
  SystemDependent: 'SystemDependent',
  ThrivesInChaos: 'ThrivesInChaos',
  NeedsStructure: 'NeedsStructure'
};

export type PlayerPersonalityTraitEnum = (typeof PlayerPersonalityTraitEnum)[keyof typeof PlayerPersonalityTraitEnum]


export const PlayerEventEnum: {
  BirthOfChild: 'BirthOfChild',
  Married: 'Married',
  CharityRecognition: 'CharityRecognition',
  PersonalMilestone: 'PersonalMilestone',
  MediaPraise: 'MediaPraise',
  InjuryRecovery: 'InjuryRecovery',
  MediaDaySuccess: 'MediaDaySuccess',
  RevengeGameSuccess: 'RevengeGameSuccess',
  NewAgent: 'NewAgent',
  RoleChange: 'RoleChange',
  LegalTrouble: 'LegalTrouble',
  FamilyIllness: 'FamilyIllness',
  PersonalLoss: 'PersonalLoss',
  MediaScandal: 'MediaScandal',
  MediaCriticism: 'MediaCriticism',
  Suspension: 'Suspension',
  ContractHoldout: 'ContractHoldout',
  TradeRequest: 'TradeRequest',
  OffFieldIncident: 'OffFieldIncident',
  DraftedHigh: 'DraftedHigh',
  BreakoutSeason: 'BreakoutSeason',
  WonAward: 'WonAward',
  AllProSelection: 'AllProSelection',
  MVP: 'MVP',
  ProBowl: 'ProBowl',
  SuperBowlWin: 'SuperBowlWin',
  RecordBroken: 'RecordBroken',
  ContractExtension: 'ContractExtension',
  BigContractSigning: 'BigContractSigning',
  PlayerOfTheWeek: 'PlayerOfTheWeek',
  PlayerOfTheMonth: 'PlayerOfTheMonth',
  BigGamePerformance: 'BigGamePerformance',
  NewCareerHigh: 'NewCareerHigh',
  NewTeamConnection: 'NewTeamConnection',
  ContractYear: 'ContractYear',
  ApproachingFreeAgency: 'ApproachingFreeAgency',
  ApproachingRetirement: 'ApproachingRetirement',
  Traded: 'Traded',
  Benched: 'Benched',
  Injured: 'Injured',
  MajorInjury: 'MajorInjury',
  MinorInjury: 'MinorInjury',
  Released: 'Released',
  CutFromTeam: 'CutFromTeam',
  LostStartingJob: 'LostStartingJob',
  ContractDispute: 'ContractDispute',
  DroppedInDraft: 'DroppedInDraft',
  TeamChampionship: 'TeamChampionship',
  CoachPraise: 'CoachPraise',
  NewQBConnection: 'NewQBConnection',
  TeamChemistry: 'TeamChemistry',
  TrainingCampSuccess: 'TrainingCampSuccess',
  NewTeamAcquisition: 'NewTeamAcquisition',
  TeamPlayoffRun: 'TeamPlayoffRun',
  TrainingCampBuzz: 'TrainingCampBuzz',
  TrainingCampBattle: 'TrainingCampBattle',
  StadiumRenovation: 'StadiumRenovation',
  NewTeamFacilities: 'NewTeamFacilities',
  TrainingCampStart: 'TrainingCampStart',
  TeamCollapse: 'TeamCollapse',
  CoachFired: 'CoachFired',
  CoachingChange: 'CoachingChange',
  LockerRoomDrama: 'LockerRoomDrama',
  MissedPlayoffs: 'MissedPlayoffs',
  TeammateDeparture: 'TeammateDeparture',
  TradeRumors: 'TradeRumors',
  LostPlayoffGame: 'LostPlayoffGame',
  LostSuperBowl: 'LostSuperBowl',
  TeamRebuilding: 'TeamRebuilding',
  TeamRelocation: 'TeamRelocation',
  TeamStruggles: 'TeamStruggles'
};

export type PlayerEventEnum = (typeof PlayerEventEnum)[keyof typeof PlayerEventEnum]


export const DivisionEnum: {
  AFC_EAST: 'AFC_EAST',
  AFC_NORTH: 'AFC_NORTH',
  AFC_SOUTH: 'AFC_SOUTH',
  AFC_WEST: 'AFC_WEST',
  NFC_EAST: 'NFC_EAST',
  NFC_NORTH: 'NFC_NORTH',
  NFC_SOUTH: 'NFC_SOUTH',
  NFC_WEST: 'NFC_WEST'
};

export type DivisionEnum = (typeof DivisionEnum)[keyof typeof DivisionEnum]


export const ConferenceEnum: {
  AFC: 'AFC',
  NFC: 'NFC'
};

export type ConferenceEnum = (typeof ConferenceEnum)[keyof typeof ConferenceEnum]


export const OffensiveSchemeEnum: {
  WEST_COAST: 'WEST_COAST',
  AIR_RAID: 'AIR_RAID',
  PRO_STYLE: 'PRO_STYLE',
  WILDCAT: 'WILDCAT',
  SPREAD: 'SPREAD',
  POWER_RUN: 'POWER_RUN',
  ZONE_RUN: 'ZONE_RUN',
  BALANCED: 'BALANCED',
  PISTOL: 'PISTOL',
  RUN_AND_SHOOT: 'RUN_AND_SHOOT'
};

export type OffensiveSchemeEnum = (typeof OffensiveSchemeEnum)[keyof typeof OffensiveSchemeEnum]


export const DefensiveSchemeEnum: {
  FOUR_THREE: 'FOUR_THREE',
  THREE_FOUR: 'THREE_FOUR',
  HYBRID: 'HYBRID',
  NICKEL_BASED: 'NICKEL_BASED',
  COVER_2: 'COVER_2',
  COVER_3: 'COVER_3',
  MULTIPLE: 'MULTIPLE',
  MAN_BLITZ_HEAVY: 'MAN_BLITZ_HEAVY',
  ZONE_HEAVY: 'ZONE_HEAVY'
};

export type DefensiveSchemeEnum = (typeof DefensiveSchemeEnum)[keyof typeof DefensiveSchemeEnum]


export const PlayerPositionEnum: {
  QB: 'QB',
  RB: 'RB',
  FB: 'FB',
  WR: 'WR',
  TE: 'TE',
  LT: 'LT',
  LG: 'LG',
  C: 'C',
  RG: 'RG',
  RT: 'RT',
  DE: 'DE',
  DT: 'DT',
  NT: 'NT',
  EDGE: 'EDGE',
  LB: 'LB',
  MLB: 'MLB',
  OLB: 'OLB',
  ILB: 'ILB',
  CB: 'CB',
  FS: 'FS',
  SS: 'SS',
  K: 'K',
  P: 'P',
  LS: 'LS',
  KR: 'KR',
  PR: 'PR'
};

export type PlayerPositionEnum = (typeof PlayerPositionEnum)[keyof typeof PlayerPositionEnum]


export const FinancialHealthEnum: {
  EXCELLENT: 'EXCELLENT',
  GOOD: 'GOOD',
  MODERATE: 'MODERATE',
  POOR: 'POOR'
};

export type FinancialHealthEnum = (typeof FinancialHealthEnum)[keyof typeof FinancialHealthEnum]


export const ContractNegotiationStatusEnum: {
  NotStarted: 'NotStarted',
  InProgress: 'InProgress',
  OfferMade: 'OfferMade',
  OfferRejected: 'OfferRejected',
  OfferAccepted: 'OfferAccepted',
  CounterOffer: 'CounterOffer',
  Completed: 'Completed',
  Withdrawn: 'Withdrawn',
  Expired: 'Expired',
  Stalled: 'Stalled',
  Failed: 'Failed'
};

export type ContractNegotiationStatusEnum = (typeof ContractNegotiationStatusEnum)[keyof typeof ContractNegotiationStatusEnum]


export const OptionType: {
  TEAM: 'TEAM',
  PLAYER: 'PLAYER'
};

export type OptionType = (typeof OptionType)[keyof typeof OptionType]

}

export type PlayerRoleEnum = $Enums.PlayerRoleEnum

export const PlayerRoleEnum: typeof $Enums.PlayerRoleEnum

export type FootballRecordEnum = $Enums.FootballRecordEnum

export const FootballRecordEnum: typeof $Enums.FootballRecordEnum

export type InjuryTypeEnum = $Enums.InjuryTypeEnum

export const InjuryTypeEnum: typeof $Enums.InjuryTypeEnum

export type OffFieldConcernTypeEnum = $Enums.OffFieldConcernTypeEnum

export const OffFieldConcernTypeEnum: typeof $Enums.OffFieldConcernTypeEnum

export type PlayerPersonalityTraitEnum = $Enums.PlayerPersonalityTraitEnum

export const PlayerPersonalityTraitEnum: typeof $Enums.PlayerPersonalityTraitEnum

export type PlayerEventEnum = $Enums.PlayerEventEnum

export const PlayerEventEnum: typeof $Enums.PlayerEventEnum

export type DivisionEnum = $Enums.DivisionEnum

export const DivisionEnum: typeof $Enums.DivisionEnum

export type ConferenceEnum = $Enums.ConferenceEnum

export const ConferenceEnum: typeof $Enums.ConferenceEnum

export type OffensiveSchemeEnum = $Enums.OffensiveSchemeEnum

export const OffensiveSchemeEnum: typeof $Enums.OffensiveSchemeEnum

export type DefensiveSchemeEnum = $Enums.DefensiveSchemeEnum

export const DefensiveSchemeEnum: typeof $Enums.DefensiveSchemeEnum

export type PlayerPositionEnum = $Enums.PlayerPositionEnum

export const PlayerPositionEnum: typeof $Enums.PlayerPositionEnum

export type FinancialHealthEnum = $Enums.FinancialHealthEnum

export const FinancialHealthEnum: typeof $Enums.FinancialHealthEnum

export type ContractNegotiationStatusEnum = $Enums.ContractNegotiationStatusEnum

export const ContractNegotiationStatusEnum: typeof $Enums.ContractNegotiationStatusEnum

export type OptionType = $Enums.OptionType

export const OptionType: typeof $Enums.OptionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Players
 * const players = await prisma.player.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Players
   * const players = await prisma.player.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerContract`: Exposes CRUD operations for the **PlayerContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerContracts
    * const playerContracts = await prisma.playerContract.findMany()
    * ```
    */
  get playerContract(): Prisma.PlayerContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractBonus`: Exposes CRUD operations for the **ContractBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractBonuses
    * const contractBonuses = await prisma.contractBonus.findMany()
    * ```
    */
  get contractBonus(): Prisma.ContractBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryByYear`: Exposes CRUD operations for the **SalaryByYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryByYears
    * const salaryByYears = await prisma.salaryByYear.findMany()
    * ```
    */
  get salaryByYear(): Prisma.SalaryByYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capHitByYear`: Exposes CRUD operations for the **CapHitByYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapHitByYears
    * const capHitByYears = await prisma.capHitByYear.findMany()
    * ```
    */
  get capHitByYear(): Prisma.CapHitByYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deadCapByYear`: Exposes CRUD operations for the **DeadCapByYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeadCapByYears
    * const deadCapByYears = await prisma.deadCapByYear.findMany()
    * ```
    */
  get deadCapByYear(): Prisma.DeadCapByYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.optOutYear`: Exposes CRUD operations for the **OptOutYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptOutYears
    * const optOutYears = await prisma.optOutYear.findMany()
    * ```
    */
  get optOutYear(): Prisma.OptOutYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restructureEvent`: Exposes CRUD operations for the **RestructureEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestructureEvents
    * const restructureEvents = await prisma.restructureEvent.findMany()
    * ```
    */
  get restructureEvent(): Prisma.RestructureEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractClause`: Exposes CRUD operations for the **ContractClause** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractClauses
    * const contractClauses = await prisma.contractClause.findMany()
    * ```
    */
  get contractClause(): Prisma.ContractClauseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceBonus`: Exposes CRUD operations for the **PerformanceBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceBonuses
    * const performanceBonuses = await prisma.performanceBonus.findMany()
    * ```
    */
  get performanceBonus(): Prisma.PerformanceBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statMilestone`: Exposes CRUD operations for the **StatMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatMilestones
    * const statMilestones = await prisma.statMilestone.findMany()
    * ```
    */
  get statMilestone(): Prisma.StatMilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rosterBonus`: Exposes CRUD operations for the **RosterBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RosterBonuses
    * const rosterBonuses = await prisma.rosterBonus.findMany()
    * ```
    */
  get rosterBonus(): Prisma.RosterBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutBonus`: Exposes CRUD operations for the **WorkoutBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutBonuses
    * const workoutBonuses = await prisma.workoutBonus.findMany()
    * ```
    */
  get workoutBonus(): Prisma.WorkoutBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.optionBonus`: Exposes CRUD operations for the **OptionBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptionBonuses
    * const optionBonuses = await prisma.optionBonus.findMany()
    * ```
    */
  get optionBonus(): Prisma.OptionBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stat`: Exposes CRUD operations for the **Stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stats
    * const stats = await prisma.stat.findMany()
    * ```
    */
  get stat(): Prisma.StatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractDesires`: Exposes CRUD operations for the **ContractDesires** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractDesires
    * const contractDesires = await prisma.contractDesires.findMany()
    * ```
    */
  get contractDesires(): Prisma.ContractDesiresDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Player: 'Player',
    Team: 'Team',
    PlayerContract: 'PlayerContract',
    ContractBonus: 'ContractBonus',
    SalaryByYear: 'SalaryByYear',
    CapHitByYear: 'CapHitByYear',
    DeadCapByYear: 'DeadCapByYear',
    OptOutYear: 'OptOutYear',
    RestructureEvent: 'RestructureEvent',
    ContractClause: 'ContractClause',
    PerformanceBonus: 'PerformanceBonus',
    StatMilestone: 'StatMilestone',
    RosterBonus: 'RosterBonus',
    WorkoutBonus: 'WorkoutBonus',
    OptionBonus: 'OptionBonus',
    Agent: 'Agent',
    Rating: 'Rating',
    Stat: 'Stat',
    ContractDesires: 'ContractDesires'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "player" | "team" | "playerContract" | "contractBonus" | "salaryByYear" | "capHitByYear" | "deadCapByYear" | "optOutYear" | "restructureEvent" | "contractClause" | "performanceBonus" | "statMilestone" | "rosterBonus" | "workoutBonus" | "optionBonus" | "agent" | "rating" | "stat" | "contractDesires"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      PlayerContract: {
        payload: Prisma.$PlayerContractPayload<ExtArgs>
        fields: Prisma.PlayerContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>
          }
          findFirst: {
            args: Prisma.PlayerContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>
          }
          findMany: {
            args: Prisma.PlayerContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>[]
          }
          create: {
            args: Prisma.PlayerContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>
          }
          createMany: {
            args: Prisma.PlayerContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>[]
          }
          delete: {
            args: Prisma.PlayerContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>
          }
          update: {
            args: Prisma.PlayerContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>
          }
          deleteMany: {
            args: Prisma.PlayerContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>[]
          }
          upsert: {
            args: Prisma.PlayerContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerContractPayload>
          }
          aggregate: {
            args: Prisma.PlayerContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerContract>
          }
          groupBy: {
            args: Prisma.PlayerContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerContractCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerContractCountAggregateOutputType> | number
          }
        }
      }
      ContractBonus: {
        payload: Prisma.$ContractBonusPayload<ExtArgs>
        fields: Prisma.ContractBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>
          }
          findFirst: {
            args: Prisma.ContractBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>
          }
          findMany: {
            args: Prisma.ContractBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>[]
          }
          create: {
            args: Prisma.ContractBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>
          }
          createMany: {
            args: Prisma.ContractBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>[]
          }
          delete: {
            args: Prisma.ContractBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>
          }
          update: {
            args: Prisma.ContractBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>
          }
          deleteMany: {
            args: Prisma.ContractBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>[]
          }
          upsert: {
            args: Prisma.ContractBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractBonusPayload>
          }
          aggregate: {
            args: Prisma.ContractBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractBonus>
          }
          groupBy: {
            args: Prisma.ContractBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractBonusCountArgs<ExtArgs>
            result: $Utils.Optional<ContractBonusCountAggregateOutputType> | number
          }
        }
      }
      SalaryByYear: {
        payload: Prisma.$SalaryByYearPayload<ExtArgs>
        fields: Prisma.SalaryByYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryByYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryByYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>
          }
          findFirst: {
            args: Prisma.SalaryByYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryByYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>
          }
          findMany: {
            args: Prisma.SalaryByYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>[]
          }
          create: {
            args: Prisma.SalaryByYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>
          }
          createMany: {
            args: Prisma.SalaryByYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryByYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>[]
          }
          delete: {
            args: Prisma.SalaryByYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>
          }
          update: {
            args: Prisma.SalaryByYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>
          }
          deleteMany: {
            args: Prisma.SalaryByYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryByYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryByYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>[]
          }
          upsert: {
            args: Prisma.SalaryByYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryByYearPayload>
          }
          aggregate: {
            args: Prisma.SalaryByYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryByYear>
          }
          groupBy: {
            args: Prisma.SalaryByYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryByYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryByYearCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryByYearCountAggregateOutputType> | number
          }
        }
      }
      CapHitByYear: {
        payload: Prisma.$CapHitByYearPayload<ExtArgs>
        fields: Prisma.CapHitByYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapHitByYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapHitByYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>
          }
          findFirst: {
            args: Prisma.CapHitByYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapHitByYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>
          }
          findMany: {
            args: Prisma.CapHitByYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>[]
          }
          create: {
            args: Prisma.CapHitByYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>
          }
          createMany: {
            args: Prisma.CapHitByYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapHitByYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>[]
          }
          delete: {
            args: Prisma.CapHitByYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>
          }
          update: {
            args: Prisma.CapHitByYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>
          }
          deleteMany: {
            args: Prisma.CapHitByYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapHitByYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CapHitByYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>[]
          }
          upsert: {
            args: Prisma.CapHitByYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapHitByYearPayload>
          }
          aggregate: {
            args: Prisma.CapHitByYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapHitByYear>
          }
          groupBy: {
            args: Prisma.CapHitByYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapHitByYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapHitByYearCountArgs<ExtArgs>
            result: $Utils.Optional<CapHitByYearCountAggregateOutputType> | number
          }
        }
      }
      DeadCapByYear: {
        payload: Prisma.$DeadCapByYearPayload<ExtArgs>
        fields: Prisma.DeadCapByYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeadCapByYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeadCapByYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>
          }
          findFirst: {
            args: Prisma.DeadCapByYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeadCapByYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>
          }
          findMany: {
            args: Prisma.DeadCapByYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>[]
          }
          create: {
            args: Prisma.DeadCapByYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>
          }
          createMany: {
            args: Prisma.DeadCapByYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeadCapByYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>[]
          }
          delete: {
            args: Prisma.DeadCapByYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>
          }
          update: {
            args: Prisma.DeadCapByYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>
          }
          deleteMany: {
            args: Prisma.DeadCapByYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeadCapByYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeadCapByYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>[]
          }
          upsert: {
            args: Prisma.DeadCapByYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeadCapByYearPayload>
          }
          aggregate: {
            args: Prisma.DeadCapByYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeadCapByYear>
          }
          groupBy: {
            args: Prisma.DeadCapByYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeadCapByYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeadCapByYearCountArgs<ExtArgs>
            result: $Utils.Optional<DeadCapByYearCountAggregateOutputType> | number
          }
        }
      }
      OptOutYear: {
        payload: Prisma.$OptOutYearPayload<ExtArgs>
        fields: Prisma.OptOutYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptOutYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptOutYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>
          }
          findFirst: {
            args: Prisma.OptOutYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptOutYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>
          }
          findMany: {
            args: Prisma.OptOutYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>[]
          }
          create: {
            args: Prisma.OptOutYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>
          }
          createMany: {
            args: Prisma.OptOutYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptOutYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>[]
          }
          delete: {
            args: Prisma.OptOutYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>
          }
          update: {
            args: Prisma.OptOutYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>
          }
          deleteMany: {
            args: Prisma.OptOutYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptOutYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptOutYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>[]
          }
          upsert: {
            args: Prisma.OptOutYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptOutYearPayload>
          }
          aggregate: {
            args: Prisma.OptOutYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptOutYear>
          }
          groupBy: {
            args: Prisma.OptOutYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptOutYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptOutYearCountArgs<ExtArgs>
            result: $Utils.Optional<OptOutYearCountAggregateOutputType> | number
          }
        }
      }
      RestructureEvent: {
        payload: Prisma.$RestructureEventPayload<ExtArgs>
        fields: Prisma.RestructureEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestructureEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestructureEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>
          }
          findFirst: {
            args: Prisma.RestructureEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestructureEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>
          }
          findMany: {
            args: Prisma.RestructureEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>[]
          }
          create: {
            args: Prisma.RestructureEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>
          }
          createMany: {
            args: Prisma.RestructureEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestructureEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>[]
          }
          delete: {
            args: Prisma.RestructureEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>
          }
          update: {
            args: Prisma.RestructureEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>
          }
          deleteMany: {
            args: Prisma.RestructureEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestructureEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestructureEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>[]
          }
          upsert: {
            args: Prisma.RestructureEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestructureEventPayload>
          }
          aggregate: {
            args: Prisma.RestructureEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestructureEvent>
          }
          groupBy: {
            args: Prisma.RestructureEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestructureEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestructureEventCountArgs<ExtArgs>
            result: $Utils.Optional<RestructureEventCountAggregateOutputType> | number
          }
        }
      }
      ContractClause: {
        payload: Prisma.$ContractClausePayload<ExtArgs>
        fields: Prisma.ContractClauseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractClauseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractClauseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>
          }
          findFirst: {
            args: Prisma.ContractClauseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractClauseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>
          }
          findMany: {
            args: Prisma.ContractClauseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>[]
          }
          create: {
            args: Prisma.ContractClauseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>
          }
          createMany: {
            args: Prisma.ContractClauseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractClauseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>[]
          }
          delete: {
            args: Prisma.ContractClauseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>
          }
          update: {
            args: Prisma.ContractClauseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>
          }
          deleteMany: {
            args: Prisma.ContractClauseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractClauseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractClauseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>[]
          }
          upsert: {
            args: Prisma.ContractClauseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractClausePayload>
          }
          aggregate: {
            args: Prisma.ContractClauseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractClause>
          }
          groupBy: {
            args: Prisma.ContractClauseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractClauseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractClauseCountArgs<ExtArgs>
            result: $Utils.Optional<ContractClauseCountAggregateOutputType> | number
          }
        }
      }
      PerformanceBonus: {
        payload: Prisma.$PerformanceBonusPayload<ExtArgs>
        fields: Prisma.PerformanceBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>
          }
          findFirst: {
            args: Prisma.PerformanceBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>
          }
          findMany: {
            args: Prisma.PerformanceBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>[]
          }
          create: {
            args: Prisma.PerformanceBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>
          }
          createMany: {
            args: Prisma.PerformanceBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>[]
          }
          delete: {
            args: Prisma.PerformanceBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>
          }
          update: {
            args: Prisma.PerformanceBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceBonusPayload>
          }
          aggregate: {
            args: Prisma.PerformanceBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceBonus>
          }
          groupBy: {
            args: Prisma.PerformanceBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceBonusCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceBonusCountAggregateOutputType> | number
          }
        }
      }
      StatMilestone: {
        payload: Prisma.$StatMilestonePayload<ExtArgs>
        fields: Prisma.StatMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>
          }
          findFirst: {
            args: Prisma.StatMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>
          }
          findMany: {
            args: Prisma.StatMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>[]
          }
          create: {
            args: Prisma.StatMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>
          }
          createMany: {
            args: Prisma.StatMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatMilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>[]
          }
          delete: {
            args: Prisma.StatMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>
          }
          update: {
            args: Prisma.StatMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>
          }
          deleteMany: {
            args: Prisma.StatMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatMilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>[]
          }
          upsert: {
            args: Prisma.StatMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatMilestonePayload>
          }
          aggregate: {
            args: Prisma.StatMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatMilestone>
          }
          groupBy: {
            args: Prisma.StatMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatMilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<StatMilestoneCountAggregateOutputType> | number
          }
        }
      }
      RosterBonus: {
        payload: Prisma.$RosterBonusPayload<ExtArgs>
        fields: Prisma.RosterBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RosterBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RosterBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>
          }
          findFirst: {
            args: Prisma.RosterBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RosterBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>
          }
          findMany: {
            args: Prisma.RosterBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>[]
          }
          create: {
            args: Prisma.RosterBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>
          }
          createMany: {
            args: Prisma.RosterBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RosterBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>[]
          }
          delete: {
            args: Prisma.RosterBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>
          }
          update: {
            args: Prisma.RosterBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>
          }
          deleteMany: {
            args: Prisma.RosterBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RosterBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RosterBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>[]
          }
          upsert: {
            args: Prisma.RosterBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterBonusPayload>
          }
          aggregate: {
            args: Prisma.RosterBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRosterBonus>
          }
          groupBy: {
            args: Prisma.RosterBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<RosterBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.RosterBonusCountArgs<ExtArgs>
            result: $Utils.Optional<RosterBonusCountAggregateOutputType> | number
          }
        }
      }
      WorkoutBonus: {
        payload: Prisma.$WorkoutBonusPayload<ExtArgs>
        fields: Prisma.WorkoutBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>
          }
          findFirst: {
            args: Prisma.WorkoutBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>
          }
          findMany: {
            args: Prisma.WorkoutBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>[]
          }
          create: {
            args: Prisma.WorkoutBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>
          }
          createMany: {
            args: Prisma.WorkoutBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>[]
          }
          delete: {
            args: Prisma.WorkoutBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>
          }
          update: {
            args: Prisma.WorkoutBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutBonusPayload>
          }
          aggregate: {
            args: Prisma.WorkoutBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutBonus>
          }
          groupBy: {
            args: Prisma.WorkoutBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutBonusCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutBonusCountAggregateOutputType> | number
          }
        }
      }
      OptionBonus: {
        payload: Prisma.$OptionBonusPayload<ExtArgs>
        fields: Prisma.OptionBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>
          }
          findFirst: {
            args: Prisma.OptionBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>
          }
          findMany: {
            args: Prisma.OptionBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>[]
          }
          create: {
            args: Prisma.OptionBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>
          }
          createMany: {
            args: Prisma.OptionBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptionBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>[]
          }
          delete: {
            args: Prisma.OptionBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>
          }
          update: {
            args: Prisma.OptionBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>
          }
          deleteMany: {
            args: Prisma.OptionBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptionBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>[]
          }
          upsert: {
            args: Prisma.OptionBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionBonusPayload>
          }
          aggregate: {
            args: Prisma.OptionBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptionBonus>
          }
          groupBy: {
            args: Prisma.OptionBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionBonusCountArgs<ExtArgs>
            result: $Utils.Optional<OptionBonusCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Stat: {
        payload: Prisma.$StatPayload<ExtArgs>
        fields: Prisma.StatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          findFirst: {
            args: Prisma.StatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          findMany: {
            args: Prisma.StatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          create: {
            args: Prisma.StatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          createMany: {
            args: Prisma.StatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          delete: {
            args: Prisma.StatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          update: {
            args: Prisma.StatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          deleteMany: {
            args: Prisma.StatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          upsert: {
            args: Prisma.StatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          aggregate: {
            args: Prisma.StatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStat>
          }
          groupBy: {
            args: Prisma.StatGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatCountArgs<ExtArgs>
            result: $Utils.Optional<StatCountAggregateOutputType> | number
          }
        }
      }
      ContractDesires: {
        payload: Prisma.$ContractDesiresPayload<ExtArgs>
        fields: Prisma.ContractDesiresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractDesiresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractDesiresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>
          }
          findFirst: {
            args: Prisma.ContractDesiresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractDesiresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>
          }
          findMany: {
            args: Prisma.ContractDesiresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>[]
          }
          create: {
            args: Prisma.ContractDesiresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>
          }
          createMany: {
            args: Prisma.ContractDesiresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractDesiresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>[]
          }
          delete: {
            args: Prisma.ContractDesiresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>
          }
          update: {
            args: Prisma.ContractDesiresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>
          }
          deleteMany: {
            args: Prisma.ContractDesiresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractDesiresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractDesiresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>[]
          }
          upsert: {
            args: Prisma.ContractDesiresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDesiresPayload>
          }
          aggregate: {
            args: Prisma.ContractDesiresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractDesires>
          }
          groupBy: {
            args: Prisma.ContractDesiresGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractDesiresGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractDesiresCountArgs<ExtArgs>
            result: $Utils.Optional<ContractDesiresCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    player?: PlayerOmit
    team?: TeamOmit
    playerContract?: PlayerContractOmit
    contractBonus?: ContractBonusOmit
    salaryByYear?: SalaryByYearOmit
    capHitByYear?: CapHitByYearOmit
    deadCapByYear?: DeadCapByYearOmit
    optOutYear?: OptOutYearOmit
    restructureEvent?: RestructureEventOmit
    contractClause?: ContractClauseOmit
    performanceBonus?: PerformanceBonusOmit
    statMilestone?: StatMilestoneOmit
    rosterBonus?: RosterBonusOmit
    workoutBonus?: WorkoutBonusOmit
    optionBonus?: OptionBonusOmit
    agent?: AgentOmit
    rating?: RatingOmit
    stat?: StatOmit
    contractDesires?: ContractDesiresOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    players: number
    practiceSquad: number
    injuredReserve: number
    suspendedList: number
    playerContracts: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | TeamCountOutputTypeCountPlayersArgs
    practiceSquad?: boolean | TeamCountOutputTypeCountPracticeSquadArgs
    injuredReserve?: boolean | TeamCountOutputTypeCountInjuredReserveArgs
    suspendedList?: boolean | TeamCountOutputTypeCountSuspendedListArgs
    playerContracts?: boolean | TeamCountOutputTypeCountPlayerContractsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPracticeSquadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInjuredReserveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSuspendedListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlayerContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerContractWhereInput
  }


  /**
   * Count Type PlayerContractCountOutputType
   */

  export type PlayerContractCountOutputType = {
    bonuses: number
    salaries: number
    capHits: number
    deadCaps: number
    optOutYears: number
    restructureEvents: number
    clauses: number
  }

  export type PlayerContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bonuses?: boolean | PlayerContractCountOutputTypeCountBonusesArgs
    salaries?: boolean | PlayerContractCountOutputTypeCountSalariesArgs
    capHits?: boolean | PlayerContractCountOutputTypeCountCapHitsArgs
    deadCaps?: boolean | PlayerContractCountOutputTypeCountDeadCapsArgs
    optOutYears?: boolean | PlayerContractCountOutputTypeCountOptOutYearsArgs
    restructureEvents?: boolean | PlayerContractCountOutputTypeCountRestructureEventsArgs
    clauses?: boolean | PlayerContractCountOutputTypeCountClausesArgs
  }

  // Custom InputTypes
  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContractCountOutputType
     */
    select?: PlayerContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractBonusWhereInput
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryByYearWhereInput
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountCapHitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapHitByYearWhereInput
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountDeadCapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeadCapByYearWhereInput
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountOptOutYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptOutYearWhereInput
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountRestructureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestructureEventWhereInput
  }

  /**
   * PlayerContractCountOutputType without action
   */
  export type PlayerContractCountOutputTypeCountClausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractClauseWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    players: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | AgentCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Count Type ContractDesiresCountOutputType
   */

  export type ContractDesiresCountOutputType = {
    player: number
  }

  export type ContractDesiresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | ContractDesiresCountOutputTypeCountPlayerArgs
  }

  // Custom InputTypes
  /**
   * ContractDesiresCountOutputType without action
   */
  export type ContractDesiresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesiresCountOutputType
     */
    select?: ContractDesiresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractDesiresCountOutputType without action
   */
  export type ContractDesiresCountOutputTypeCountPlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    age: number | null
    heightInInches: number | null
    weightInPounds: number | null
    draftYear: number | null
    draftRound: number | null
    performanceRating: number | null
    impactRating: number | null
    potential: number | null
    experience: number | null
    morale: number | null
    leadership: number | null
    adaptability: number | null
    workEthic: number | null
    consistency: number | null
    clutchFactor: number | null
    footballIQ: number | null
    popularity: number | null
    trainingProgress: number | null
  }

  export type PlayerSumAggregateOutputType = {
    age: number | null
    heightInInches: number | null
    weightInPounds: number | null
    draftYear: number | null
    draftRound: number | null
    performanceRating: number | null
    impactRating: number | null
    potential: number | null
    experience: number | null
    morale: number | null
    leadership: number | null
    adaptability: number | null
    workEthic: number | null
    consistency: number | null
    clutchFactor: number | null
    footballIQ: number | null
    popularity: number | null
    trainingProgress: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    age: number | null
    college: string | null
    heightInInches: number | null
    weightInPounds: number | null
    teamId: string | null
    practiceSquadTeamId: string | null
    injuredReserveTeamId: string | null
    suspendedListTeamId: string | null
    currentContractId: string | null
    agentId: string | null
    ratingsId: string | null
    statsId: string | null
    position: $Enums.PlayerPositionEnum | null
    expectedRole: $Enums.PlayerRoleEnum | null
    actualRole: $Enums.PlayerRoleEnum | null
    currentInjury: $Enums.InjuryTypeEnum | null
    isStarter: boolean | null
    isCaptain: boolean | null
    isFreeAgent: boolean | null
    isRetired: boolean | null
    isSuspended: boolean | null
    isPracticeSquad: boolean | null
    isTradeBlock: boolean | null
    offense: boolean | null
    defense: boolean | null
    specialTeams: boolean | null
    draftYear: number | null
    draftRound: number | null
    isRecordHolder: boolean | null
    contractDesiresId: string | null
    contractNegotiationStatus: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate: Date | null
    performanceRating: number | null
    impactRating: number | null
    potential: number | null
    experience: number | null
    isInjured: boolean | null
    injuryProneness: boolean | null
    expectedReturnFromInjury: Date | null
    morale: number | null
    leadership: number | null
    adaptability: number | null
    workEthic: number | null
    consistency: number | null
    clutchFactor: number | null
    footballIQ: number | null
    popularity: number | null
    trainingFocus: string | null
    trainingProgress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    age: number | null
    college: string | null
    heightInInches: number | null
    weightInPounds: number | null
    teamId: string | null
    practiceSquadTeamId: string | null
    injuredReserveTeamId: string | null
    suspendedListTeamId: string | null
    currentContractId: string | null
    agentId: string | null
    ratingsId: string | null
    statsId: string | null
    position: $Enums.PlayerPositionEnum | null
    expectedRole: $Enums.PlayerRoleEnum | null
    actualRole: $Enums.PlayerRoleEnum | null
    currentInjury: $Enums.InjuryTypeEnum | null
    isStarter: boolean | null
    isCaptain: boolean | null
    isFreeAgent: boolean | null
    isRetired: boolean | null
    isSuspended: boolean | null
    isPracticeSquad: boolean | null
    isTradeBlock: boolean | null
    offense: boolean | null
    defense: boolean | null
    specialTeams: boolean | null
    draftYear: number | null
    draftRound: number | null
    isRecordHolder: boolean | null
    contractDesiresId: string | null
    contractNegotiationStatus: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate: Date | null
    performanceRating: number | null
    impactRating: number | null
    potential: number | null
    experience: number | null
    isInjured: boolean | null
    injuryProneness: boolean | null
    expectedReturnFromInjury: Date | null
    morale: number | null
    leadership: number | null
    adaptability: number | null
    workEthic: number | null
    consistency: number | null
    clutchFactor: number | null
    footballIQ: number | null
    popularity: number | null
    trainingFocus: string | null
    trainingProgress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    age: number
    college: number
    heightInInches: number
    weightInPounds: number
    teamId: number
    practiceSquadTeamId: number
    injuredReserveTeamId: number
    suspendedListTeamId: number
    currentContractId: number
    agentId: number
    ratingsId: number
    statsId: number
    position: number
    expectedRole: number
    actualRole: number
    recordsHeld: number
    currentInjury: number
    injuryHistory: number
    personalityTraits: number
    offFieldConcerns: number
    pastEvents: number
    isStarter: number
    isCaptain: number
    isFreeAgent: number
    isRetired: number
    isSuspended: number
    isPracticeSquad: number
    isTradeBlock: number
    offense: number
    defense: number
    specialTeams: number
    draftYear: number
    draftRound: number
    isRecordHolder: number
    contractDesiresId: number
    contractNegotiationStatus: number
    lastContractUpdate: number
    performanceRating: number
    impactRating: number
    potential: number
    experience: number
    isInjured: number
    injuryProneness: number
    expectedReturnFromInjury: number
    morale: number
    leadership: number
    adaptability: number
    workEthic: number
    consistency: number
    clutchFactor: number
    footballIQ: number
    popularity: number
    trainingFocus: number
    trainingProgress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    age?: true
    heightInInches?: true
    weightInPounds?: true
    draftYear?: true
    draftRound?: true
    performanceRating?: true
    impactRating?: true
    potential?: true
    experience?: true
    morale?: true
    leadership?: true
    adaptability?: true
    workEthic?: true
    consistency?: true
    clutchFactor?: true
    footballIQ?: true
    popularity?: true
    trainingProgress?: true
  }

  export type PlayerSumAggregateInputType = {
    age?: true
    heightInInches?: true
    weightInPounds?: true
    draftYear?: true
    draftRound?: true
    performanceRating?: true
    impactRating?: true
    potential?: true
    experience?: true
    morale?: true
    leadership?: true
    adaptability?: true
    workEthic?: true
    consistency?: true
    clutchFactor?: true
    footballIQ?: true
    popularity?: true
    trainingProgress?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    age?: true
    college?: true
    heightInInches?: true
    weightInPounds?: true
    teamId?: true
    practiceSquadTeamId?: true
    injuredReserveTeamId?: true
    suspendedListTeamId?: true
    currentContractId?: true
    agentId?: true
    ratingsId?: true
    statsId?: true
    position?: true
    expectedRole?: true
    actualRole?: true
    currentInjury?: true
    isStarter?: true
    isCaptain?: true
    isFreeAgent?: true
    isRetired?: true
    isSuspended?: true
    isPracticeSquad?: true
    isTradeBlock?: true
    offense?: true
    defense?: true
    specialTeams?: true
    draftYear?: true
    draftRound?: true
    isRecordHolder?: true
    contractDesiresId?: true
    contractNegotiationStatus?: true
    lastContractUpdate?: true
    performanceRating?: true
    impactRating?: true
    potential?: true
    experience?: true
    isInjured?: true
    injuryProneness?: true
    expectedReturnFromInjury?: true
    morale?: true
    leadership?: true
    adaptability?: true
    workEthic?: true
    consistency?: true
    clutchFactor?: true
    footballIQ?: true
    popularity?: true
    trainingFocus?: true
    trainingProgress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    age?: true
    college?: true
    heightInInches?: true
    weightInPounds?: true
    teamId?: true
    practiceSquadTeamId?: true
    injuredReserveTeamId?: true
    suspendedListTeamId?: true
    currentContractId?: true
    agentId?: true
    ratingsId?: true
    statsId?: true
    position?: true
    expectedRole?: true
    actualRole?: true
    currentInjury?: true
    isStarter?: true
    isCaptain?: true
    isFreeAgent?: true
    isRetired?: true
    isSuspended?: true
    isPracticeSquad?: true
    isTradeBlock?: true
    offense?: true
    defense?: true
    specialTeams?: true
    draftYear?: true
    draftRound?: true
    isRecordHolder?: true
    contractDesiresId?: true
    contractNegotiationStatus?: true
    lastContractUpdate?: true
    performanceRating?: true
    impactRating?: true
    potential?: true
    experience?: true
    isInjured?: true
    injuryProneness?: true
    expectedReturnFromInjury?: true
    morale?: true
    leadership?: true
    adaptability?: true
    workEthic?: true
    consistency?: true
    clutchFactor?: true
    footballIQ?: true
    popularity?: true
    trainingFocus?: true
    trainingProgress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    age?: true
    college?: true
    heightInInches?: true
    weightInPounds?: true
    teamId?: true
    practiceSquadTeamId?: true
    injuredReserveTeamId?: true
    suspendedListTeamId?: true
    currentContractId?: true
    agentId?: true
    ratingsId?: true
    statsId?: true
    position?: true
    expectedRole?: true
    actualRole?: true
    recordsHeld?: true
    currentInjury?: true
    injuryHistory?: true
    personalityTraits?: true
    offFieldConcerns?: true
    pastEvents?: true
    isStarter?: true
    isCaptain?: true
    isFreeAgent?: true
    isRetired?: true
    isSuspended?: true
    isPracticeSquad?: true
    isTradeBlock?: true
    offense?: true
    defense?: true
    specialTeams?: true
    draftYear?: true
    draftRound?: true
    isRecordHolder?: true
    contractDesiresId?: true
    contractNegotiationStatus?: true
    lastContractUpdate?: true
    performanceRating?: true
    impactRating?: true
    potential?: true
    experience?: true
    isInjured?: true
    injuryProneness?: true
    expectedReturnFromInjury?: true
    morale?: true
    leadership?: true
    adaptability?: true
    workEthic?: true
    consistency?: true
    clutchFactor?: true
    footballIQ?: true
    popularity?: true
    trainingFocus?: true
    trainingProgress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId: string | null
    practiceSquadTeamId: string | null
    injuredReserveTeamId: string | null
    suspendedListTeamId: string | null
    currentContractId: string | null
    agentId: string | null
    ratingsId: string | null
    statsId: string | null
    position: $Enums.PlayerPositionEnum | null
    expectedRole: $Enums.PlayerRoleEnum | null
    actualRole: $Enums.PlayerRoleEnum | null
    recordsHeld: $Enums.FootballRecordEnum[]
    currentInjury: $Enums.InjuryTypeEnum | null
    injuryHistory: $Enums.InjuryTypeEnum[]
    personalityTraits: $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns: $Enums.OffFieldConcernTypeEnum[]
    pastEvents: $Enums.PlayerEventEnum[]
    isStarter: boolean
    isCaptain: boolean
    isFreeAgent: boolean
    isRetired: boolean
    isSuspended: boolean
    isPracticeSquad: boolean
    isTradeBlock: boolean
    offense: boolean
    defense: boolean
    specialTeams: boolean
    draftYear: number | null
    draftRound: number | null
    isRecordHolder: boolean
    contractDesiresId: string | null
    contractNegotiationStatus: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate: Date | null
    performanceRating: number | null
    impactRating: number | null
    potential: number | null
    experience: number | null
    isInjured: boolean
    injuryProneness: boolean
    expectedReturnFromInjury: Date | null
    morale: number | null
    leadership: number | null
    adaptability: number | null
    workEthic: number | null
    consistency: number | null
    clutchFactor: number | null
    footballIQ: number | null
    popularity: number | null
    trainingFocus: string | null
    trainingProgress: number | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    college?: boolean
    heightInInches?: boolean
    weightInPounds?: boolean
    teamId?: boolean
    practiceSquadTeamId?: boolean
    injuredReserveTeamId?: boolean
    suspendedListTeamId?: boolean
    currentContractId?: boolean
    agentId?: boolean
    ratingsId?: boolean
    statsId?: boolean
    position?: boolean
    expectedRole?: boolean
    actualRole?: boolean
    recordsHeld?: boolean
    currentInjury?: boolean
    injuryHistory?: boolean
    personalityTraits?: boolean
    offFieldConcerns?: boolean
    pastEvents?: boolean
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: boolean
    draftRound?: boolean
    isRecordHolder?: boolean
    contractDesiresId?: boolean
    contractNegotiationStatus?: boolean
    lastContractUpdate?: boolean
    performanceRating?: boolean
    impactRating?: boolean
    potential?: boolean
    experience?: boolean
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: boolean
    morale?: boolean
    leadership?: boolean
    adaptability?: boolean
    workEthic?: boolean
    consistency?: boolean
    clutchFactor?: boolean
    footballIQ?: boolean
    popularity?: boolean
    trainingFocus?: boolean
    trainingProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | Player$teamArgs<ExtArgs>
    practiceSquadTeam?: boolean | Player$practiceSquadTeamArgs<ExtArgs>
    injuredReserveTeam?: boolean | Player$injuredReserveTeamArgs<ExtArgs>
    suspendedListTeam?: boolean | Player$suspendedListTeamArgs<ExtArgs>
    currentContract?: boolean | Player$currentContractArgs<ExtArgs>
    agent?: boolean | Player$agentArgs<ExtArgs>
    ratings?: boolean | Player$ratingsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    contractDesires?: boolean | Player$contractDesiresArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    college?: boolean
    heightInInches?: boolean
    weightInPounds?: boolean
    teamId?: boolean
    practiceSquadTeamId?: boolean
    injuredReserveTeamId?: boolean
    suspendedListTeamId?: boolean
    currentContractId?: boolean
    agentId?: boolean
    ratingsId?: boolean
    statsId?: boolean
    position?: boolean
    expectedRole?: boolean
    actualRole?: boolean
    recordsHeld?: boolean
    currentInjury?: boolean
    injuryHistory?: boolean
    personalityTraits?: boolean
    offFieldConcerns?: boolean
    pastEvents?: boolean
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: boolean
    draftRound?: boolean
    isRecordHolder?: boolean
    contractDesiresId?: boolean
    contractNegotiationStatus?: boolean
    lastContractUpdate?: boolean
    performanceRating?: boolean
    impactRating?: boolean
    potential?: boolean
    experience?: boolean
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: boolean
    morale?: boolean
    leadership?: boolean
    adaptability?: boolean
    workEthic?: boolean
    consistency?: boolean
    clutchFactor?: boolean
    footballIQ?: boolean
    popularity?: boolean
    trainingFocus?: boolean
    trainingProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | Player$teamArgs<ExtArgs>
    practiceSquadTeam?: boolean | Player$practiceSquadTeamArgs<ExtArgs>
    injuredReserveTeam?: boolean | Player$injuredReserveTeamArgs<ExtArgs>
    suspendedListTeam?: boolean | Player$suspendedListTeamArgs<ExtArgs>
    agent?: boolean | Player$agentArgs<ExtArgs>
    ratings?: boolean | Player$ratingsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    contractDesires?: boolean | Player$contractDesiresArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    college?: boolean
    heightInInches?: boolean
    weightInPounds?: boolean
    teamId?: boolean
    practiceSquadTeamId?: boolean
    injuredReserveTeamId?: boolean
    suspendedListTeamId?: boolean
    currentContractId?: boolean
    agentId?: boolean
    ratingsId?: boolean
    statsId?: boolean
    position?: boolean
    expectedRole?: boolean
    actualRole?: boolean
    recordsHeld?: boolean
    currentInjury?: boolean
    injuryHistory?: boolean
    personalityTraits?: boolean
    offFieldConcerns?: boolean
    pastEvents?: boolean
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: boolean
    draftRound?: boolean
    isRecordHolder?: boolean
    contractDesiresId?: boolean
    contractNegotiationStatus?: boolean
    lastContractUpdate?: boolean
    performanceRating?: boolean
    impactRating?: boolean
    potential?: boolean
    experience?: boolean
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: boolean
    morale?: boolean
    leadership?: boolean
    adaptability?: boolean
    workEthic?: boolean
    consistency?: boolean
    clutchFactor?: boolean
    footballIQ?: boolean
    popularity?: boolean
    trainingFocus?: boolean
    trainingProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | Player$teamArgs<ExtArgs>
    practiceSquadTeam?: boolean | Player$practiceSquadTeamArgs<ExtArgs>
    injuredReserveTeam?: boolean | Player$injuredReserveTeamArgs<ExtArgs>
    suspendedListTeam?: boolean | Player$suspendedListTeamArgs<ExtArgs>
    agent?: boolean | Player$agentArgs<ExtArgs>
    ratings?: boolean | Player$ratingsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    contractDesires?: boolean | Player$contractDesiresArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    college?: boolean
    heightInInches?: boolean
    weightInPounds?: boolean
    teamId?: boolean
    practiceSquadTeamId?: boolean
    injuredReserveTeamId?: boolean
    suspendedListTeamId?: boolean
    currentContractId?: boolean
    agentId?: boolean
    ratingsId?: boolean
    statsId?: boolean
    position?: boolean
    expectedRole?: boolean
    actualRole?: boolean
    recordsHeld?: boolean
    currentInjury?: boolean
    injuryHistory?: boolean
    personalityTraits?: boolean
    offFieldConcerns?: boolean
    pastEvents?: boolean
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: boolean
    draftRound?: boolean
    isRecordHolder?: boolean
    contractDesiresId?: boolean
    contractNegotiationStatus?: boolean
    lastContractUpdate?: boolean
    performanceRating?: boolean
    impactRating?: boolean
    potential?: boolean
    experience?: boolean
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: boolean
    morale?: boolean
    leadership?: boolean
    adaptability?: boolean
    workEthic?: boolean
    consistency?: boolean
    clutchFactor?: boolean
    footballIQ?: boolean
    popularity?: boolean
    trainingFocus?: boolean
    trainingProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "age" | "college" | "heightInInches" | "weightInPounds" | "teamId" | "practiceSquadTeamId" | "injuredReserveTeamId" | "suspendedListTeamId" | "currentContractId" | "agentId" | "ratingsId" | "statsId" | "position" | "expectedRole" | "actualRole" | "recordsHeld" | "currentInjury" | "injuryHistory" | "personalityTraits" | "offFieldConcerns" | "pastEvents" | "isStarter" | "isCaptain" | "isFreeAgent" | "isRetired" | "isSuspended" | "isPracticeSquad" | "isTradeBlock" | "offense" | "defense" | "specialTeams" | "draftYear" | "draftRound" | "isRecordHolder" | "contractDesiresId" | "contractNegotiationStatus" | "lastContractUpdate" | "performanceRating" | "impactRating" | "potential" | "experience" | "isInjured" | "injuryProneness" | "expectedReturnFromInjury" | "morale" | "leadership" | "adaptability" | "workEthic" | "consistency" | "clutchFactor" | "footballIQ" | "popularity" | "trainingFocus" | "trainingProgress" | "createdAt" | "updatedAt", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | Player$teamArgs<ExtArgs>
    practiceSquadTeam?: boolean | Player$practiceSquadTeamArgs<ExtArgs>
    injuredReserveTeam?: boolean | Player$injuredReserveTeamArgs<ExtArgs>
    suspendedListTeam?: boolean | Player$suspendedListTeamArgs<ExtArgs>
    currentContract?: boolean | Player$currentContractArgs<ExtArgs>
    agent?: boolean | Player$agentArgs<ExtArgs>
    ratings?: boolean | Player$ratingsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    contractDesires?: boolean | Player$contractDesiresArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | Player$teamArgs<ExtArgs>
    practiceSquadTeam?: boolean | Player$practiceSquadTeamArgs<ExtArgs>
    injuredReserveTeam?: boolean | Player$injuredReserveTeamArgs<ExtArgs>
    suspendedListTeam?: boolean | Player$suspendedListTeamArgs<ExtArgs>
    agent?: boolean | Player$agentArgs<ExtArgs>
    ratings?: boolean | Player$ratingsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    contractDesires?: boolean | Player$contractDesiresArgs<ExtArgs>
  }
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | Player$teamArgs<ExtArgs>
    practiceSquadTeam?: boolean | Player$practiceSquadTeamArgs<ExtArgs>
    injuredReserveTeam?: boolean | Player$injuredReserveTeamArgs<ExtArgs>
    suspendedListTeam?: boolean | Player$suspendedListTeamArgs<ExtArgs>
    agent?: boolean | Player$agentArgs<ExtArgs>
    ratings?: boolean | Player$ratingsArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    contractDesires?: boolean | Player$contractDesiresArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs> | null
      practiceSquadTeam: Prisma.$TeamPayload<ExtArgs> | null
      injuredReserveTeam: Prisma.$TeamPayload<ExtArgs> | null
      suspendedListTeam: Prisma.$TeamPayload<ExtArgs> | null
      currentContract: Prisma.$PlayerContractPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
      ratings: Prisma.$RatingPayload<ExtArgs> | null
      stats: Prisma.$StatPayload<ExtArgs> | null
      contractDesires: Prisma.$ContractDesiresPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      age: number
      college: string
      heightInInches: number
      weightInPounds: number
      teamId: string | null
      practiceSquadTeamId: string | null
      injuredReserveTeamId: string | null
      suspendedListTeamId: string | null
      currentContractId: string | null
      agentId: string | null
      ratingsId: string | null
      statsId: string | null
      position: $Enums.PlayerPositionEnum | null
      expectedRole: $Enums.PlayerRoleEnum | null
      actualRole: $Enums.PlayerRoleEnum | null
      recordsHeld: $Enums.FootballRecordEnum[]
      currentInjury: $Enums.InjuryTypeEnum | null
      injuryHistory: $Enums.InjuryTypeEnum[]
      personalityTraits: $Enums.PlayerPersonalityTraitEnum[]
      offFieldConcerns: $Enums.OffFieldConcernTypeEnum[]
      pastEvents: $Enums.PlayerEventEnum[]
      isStarter: boolean
      isCaptain: boolean
      isFreeAgent: boolean
      isRetired: boolean
      isSuspended: boolean
      isPracticeSquad: boolean
      isTradeBlock: boolean
      offense: boolean
      defense: boolean
      specialTeams: boolean
      draftYear: number | null
      draftRound: number | null
      isRecordHolder: boolean
      contractDesiresId: string | null
      contractNegotiationStatus: $Enums.ContractNegotiationStatusEnum | null
      lastContractUpdate: Date | null
      performanceRating: number | null
      impactRating: number | null
      potential: number | null
      experience: number | null
      isInjured: boolean
      injuryProneness: boolean
      expectedReturnFromInjury: Date | null
      morale: number | null
      leadership: number | null
      adaptability: number | null
      workEthic: number | null
      consistency: number | null
      clutchFactor: number | null
      footballIQ: number | null
      popularity: number | null
      trainingFocus: string | null
      trainingProgress: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends Player$teamArgs<ExtArgs> = {}>(args?: Subset<T, Player$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    practiceSquadTeam<T extends Player$practiceSquadTeamArgs<ExtArgs> = {}>(args?: Subset<T, Player$practiceSquadTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    injuredReserveTeam<T extends Player$injuredReserveTeamArgs<ExtArgs> = {}>(args?: Subset<T, Player$injuredReserveTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    suspendedListTeam<T extends Player$suspendedListTeamArgs<ExtArgs> = {}>(args?: Subset<T, Player$suspendedListTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currentContract<T extends Player$currentContractArgs<ExtArgs> = {}>(args?: Subset<T, Player$currentContractArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends Player$agentArgs<ExtArgs> = {}>(args?: Subset<T, Player$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ratings<T extends Player$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Player$ratingsArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stats<T extends Player$statsArgs<ExtArgs> = {}>(args?: Subset<T, Player$statsArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contractDesires<T extends Player$contractDesiresArgs<ExtArgs> = {}>(args?: Subset<T, Player$contractDesiresArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly firstName: FieldRef<"Player", 'String'>
    readonly lastName: FieldRef<"Player", 'String'>
    readonly age: FieldRef<"Player", 'Int'>
    readonly college: FieldRef<"Player", 'String'>
    readonly heightInInches: FieldRef<"Player", 'Int'>
    readonly weightInPounds: FieldRef<"Player", 'Int'>
    readonly teamId: FieldRef<"Player", 'String'>
    readonly practiceSquadTeamId: FieldRef<"Player", 'String'>
    readonly injuredReserveTeamId: FieldRef<"Player", 'String'>
    readonly suspendedListTeamId: FieldRef<"Player", 'String'>
    readonly currentContractId: FieldRef<"Player", 'String'>
    readonly agentId: FieldRef<"Player", 'String'>
    readonly ratingsId: FieldRef<"Player", 'String'>
    readonly statsId: FieldRef<"Player", 'String'>
    readonly position: FieldRef<"Player", 'PlayerPositionEnum'>
    readonly expectedRole: FieldRef<"Player", 'PlayerRoleEnum'>
    readonly actualRole: FieldRef<"Player", 'PlayerRoleEnum'>
    readonly recordsHeld: FieldRef<"Player", 'FootballRecordEnum[]'>
    readonly currentInjury: FieldRef<"Player", 'InjuryTypeEnum'>
    readonly injuryHistory: FieldRef<"Player", 'InjuryTypeEnum[]'>
    readonly personalityTraits: FieldRef<"Player", 'PlayerPersonalityTraitEnum[]'>
    readonly offFieldConcerns: FieldRef<"Player", 'OffFieldConcernTypeEnum[]'>
    readonly pastEvents: FieldRef<"Player", 'PlayerEventEnum[]'>
    readonly isStarter: FieldRef<"Player", 'Boolean'>
    readonly isCaptain: FieldRef<"Player", 'Boolean'>
    readonly isFreeAgent: FieldRef<"Player", 'Boolean'>
    readonly isRetired: FieldRef<"Player", 'Boolean'>
    readonly isSuspended: FieldRef<"Player", 'Boolean'>
    readonly isPracticeSquad: FieldRef<"Player", 'Boolean'>
    readonly isTradeBlock: FieldRef<"Player", 'Boolean'>
    readonly offense: FieldRef<"Player", 'Boolean'>
    readonly defense: FieldRef<"Player", 'Boolean'>
    readonly specialTeams: FieldRef<"Player", 'Boolean'>
    readonly draftYear: FieldRef<"Player", 'Int'>
    readonly draftRound: FieldRef<"Player", 'Int'>
    readonly isRecordHolder: FieldRef<"Player", 'Boolean'>
    readonly contractDesiresId: FieldRef<"Player", 'String'>
    readonly contractNegotiationStatus: FieldRef<"Player", 'ContractNegotiationStatusEnum'>
    readonly lastContractUpdate: FieldRef<"Player", 'DateTime'>
    readonly performanceRating: FieldRef<"Player", 'Int'>
    readonly impactRating: FieldRef<"Player", 'Int'>
    readonly potential: FieldRef<"Player", 'Int'>
    readonly experience: FieldRef<"Player", 'Int'>
    readonly isInjured: FieldRef<"Player", 'Boolean'>
    readonly injuryProneness: FieldRef<"Player", 'Boolean'>
    readonly expectedReturnFromInjury: FieldRef<"Player", 'DateTime'>
    readonly morale: FieldRef<"Player", 'Int'>
    readonly leadership: FieldRef<"Player", 'Int'>
    readonly adaptability: FieldRef<"Player", 'Int'>
    readonly workEthic: FieldRef<"Player", 'Int'>
    readonly consistency: FieldRef<"Player", 'Int'>
    readonly clutchFactor: FieldRef<"Player", 'Int'>
    readonly footballIQ: FieldRef<"Player", 'Int'>
    readonly popularity: FieldRef<"Player", 'Int'>
    readonly trainingFocus: FieldRef<"Player", 'String'>
    readonly trainingProgress: FieldRef<"Player", 'Int'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.team
   */
  export type Player$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Player.practiceSquadTeam
   */
  export type Player$practiceSquadTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Player.injuredReserveTeam
   */
  export type Player$injuredReserveTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Player.suspendedListTeam
   */
  export type Player$suspendedListTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Player.currentContract
   */
  export type Player$currentContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    where?: PlayerContractWhereInput
  }

  /**
   * Player.agent
   */
  export type Player$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Player.ratings
   */
  export type Player$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
  }

  /**
   * Player.stats
   */
  export type Player$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    where?: StatWhereInput
  }

  /**
   * Player.contractDesires
   */
  export type Player$contractDesiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    where?: ContractDesiresWhereInput
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    overallRating: number | null
    wins: number | null
    losses: number | null
    ties: number | null
    currentStreak: number | null
    longestWinningStreak: number | null
    playoffAppearances: number | null
    superBowlAppearances: number | null
    championships: number | null
    capSpace: number | null
    capLimit: number | null
    totalPayroll: number | null
    yearFounded: number | null
    allTimeWins: number | null
    allTimeLosses: number | null
    allTimeTies: number | null
    retiredNumbers: number | null
    fanBaseSize: number | null
    prestige: number | null
  }

  export type TeamSumAggregateOutputType = {
    overallRating: number | null
    wins: number | null
    losses: number | null
    ties: number | null
    currentStreak: number | null
    longestWinningStreak: number | null
    playoffAppearances: number | null
    superBowlAppearances: number | null
    championships: number | null
    capSpace: number | null
    capLimit: number | null
    totalPayroll: number | null
    yearFounded: number | null
    allTimeWins: number | null
    allTimeLosses: number | null
    allTimeTies: number | null
    retiredNumbers: number[]
    fanBaseSize: number | null
    prestige: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    nickname: string | null
    location: string | null
    abbreviation: string | null
    logoUrl: string | null
    division: $Enums.DivisionEnum | null
    conference: $Enums.ConferenceEnum | null
    overallRating: number | null
    offensiveScheme: $Enums.OffensiveSchemeEnum | null
    defensiveScheme: $Enums.DefensiveSchemeEnum | null
    wins: number | null
    losses: number | null
    ties: number | null
    currentStreak: number | null
    longestWinningStreak: number | null
    playoffAppearances: number | null
    superBowlAppearances: number | null
    championships: number | null
    capSpace: number | null
    capLimit: number | null
    totalPayroll: number | null
    financialHealth: $Enums.FinancialHealthEnum | null
    yearFounded: number | null
    allTimeWins: number | null
    allTimeLosses: number | null
    allTimeTies: number | null
    fanBaseSize: number | null
    prestige: number | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nickname: string | null
    location: string | null
    abbreviation: string | null
    logoUrl: string | null
    division: $Enums.DivisionEnum | null
    conference: $Enums.ConferenceEnum | null
    overallRating: number | null
    offensiveScheme: $Enums.OffensiveSchemeEnum | null
    defensiveScheme: $Enums.DefensiveSchemeEnum | null
    wins: number | null
    losses: number | null
    ties: number | null
    currentStreak: number | null
    longestWinningStreak: number | null
    playoffAppearances: number | null
    superBowlAppearances: number | null
    championships: number | null
    capSpace: number | null
    capLimit: number | null
    totalPayroll: number | null
    financialHealth: $Enums.FinancialHealthEnum | null
    yearFounded: number | null
    allTimeWins: number | null
    allTimeLosses: number | null
    allTimeTies: number | null
    fanBaseSize: number | null
    prestige: number | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    nickname: number
    location: number
    abbreviation: number
    logoUrl: number
    division: number
    conference: number
    overallRating: number
    offensiveScheme: number
    defensiveScheme: number
    teamNeeds: number
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: number
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers: number
    fanBaseSize: number
    prestige: number
    rivalTeams: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    overallRating?: true
    wins?: true
    losses?: true
    ties?: true
    currentStreak?: true
    longestWinningStreak?: true
    playoffAppearances?: true
    superBowlAppearances?: true
    championships?: true
    capSpace?: true
    capLimit?: true
    totalPayroll?: true
    yearFounded?: true
    allTimeWins?: true
    allTimeLosses?: true
    allTimeTies?: true
    retiredNumbers?: true
    fanBaseSize?: true
    prestige?: true
  }

  export type TeamSumAggregateInputType = {
    overallRating?: true
    wins?: true
    losses?: true
    ties?: true
    currentStreak?: true
    longestWinningStreak?: true
    playoffAppearances?: true
    superBowlAppearances?: true
    championships?: true
    capSpace?: true
    capLimit?: true
    totalPayroll?: true
    yearFounded?: true
    allTimeWins?: true
    allTimeLosses?: true
    allTimeTies?: true
    retiredNumbers?: true
    fanBaseSize?: true
    prestige?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    nickname?: true
    location?: true
    abbreviation?: true
    logoUrl?: true
    division?: true
    conference?: true
    overallRating?: true
    offensiveScheme?: true
    defensiveScheme?: true
    wins?: true
    losses?: true
    ties?: true
    currentStreak?: true
    longestWinningStreak?: true
    playoffAppearances?: true
    superBowlAppearances?: true
    championships?: true
    capSpace?: true
    capLimit?: true
    totalPayroll?: true
    financialHealth?: true
    yearFounded?: true
    allTimeWins?: true
    allTimeLosses?: true
    allTimeTies?: true
    fanBaseSize?: true
    prestige?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    nickname?: true
    location?: true
    abbreviation?: true
    logoUrl?: true
    division?: true
    conference?: true
    overallRating?: true
    offensiveScheme?: true
    defensiveScheme?: true
    wins?: true
    losses?: true
    ties?: true
    currentStreak?: true
    longestWinningStreak?: true
    playoffAppearances?: true
    superBowlAppearances?: true
    championships?: true
    capSpace?: true
    capLimit?: true
    totalPayroll?: true
    financialHealth?: true
    yearFounded?: true
    allTimeWins?: true
    allTimeLosses?: true
    allTimeTies?: true
    fanBaseSize?: true
    prestige?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    nickname?: true
    location?: true
    abbreviation?: true
    logoUrl?: true
    division?: true
    conference?: true
    overallRating?: true
    offensiveScheme?: true
    defensiveScheme?: true
    teamNeeds?: true
    wins?: true
    losses?: true
    ties?: true
    currentStreak?: true
    longestWinningStreak?: true
    playoffAppearances?: true
    superBowlAppearances?: true
    championships?: true
    capSpace?: true
    capLimit?: true
    totalPayroll?: true
    financialHealth?: true
    yearFounded?: true
    allTimeWins?: true
    allTimeLosses?: true
    allTimeTies?: true
    retiredNumbers?: true
    fanBaseSize?: true
    prestige?: true
    rivalTeams?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds: $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers: number[]
    fanBaseSize: number
    prestige: number
    rivalTeams: string[]
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nickname?: boolean
    location?: boolean
    abbreviation?: boolean
    logoUrl?: boolean
    division?: boolean
    conference?: boolean
    overallRating?: boolean
    offensiveScheme?: boolean
    defensiveScheme?: boolean
    teamNeeds?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    currentStreak?: boolean
    longestWinningStreak?: boolean
    playoffAppearances?: boolean
    superBowlAppearances?: boolean
    championships?: boolean
    capSpace?: boolean
    capLimit?: boolean
    totalPayroll?: boolean
    financialHealth?: boolean
    yearFounded?: boolean
    allTimeWins?: boolean
    allTimeLosses?: boolean
    allTimeTies?: boolean
    retiredNumbers?: boolean
    fanBaseSize?: boolean
    prestige?: boolean
    rivalTeams?: boolean
    players?: boolean | Team$playersArgs<ExtArgs>
    practiceSquad?: boolean | Team$practiceSquadArgs<ExtArgs>
    injuredReserve?: boolean | Team$injuredReserveArgs<ExtArgs>
    suspendedList?: boolean | Team$suspendedListArgs<ExtArgs>
    playerContracts?: boolean | Team$playerContractsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nickname?: boolean
    location?: boolean
    abbreviation?: boolean
    logoUrl?: boolean
    division?: boolean
    conference?: boolean
    overallRating?: boolean
    offensiveScheme?: boolean
    defensiveScheme?: boolean
    teamNeeds?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    currentStreak?: boolean
    longestWinningStreak?: boolean
    playoffAppearances?: boolean
    superBowlAppearances?: boolean
    championships?: boolean
    capSpace?: boolean
    capLimit?: boolean
    totalPayroll?: boolean
    financialHealth?: boolean
    yearFounded?: boolean
    allTimeWins?: boolean
    allTimeLosses?: boolean
    allTimeTies?: boolean
    retiredNumbers?: boolean
    fanBaseSize?: boolean
    prestige?: boolean
    rivalTeams?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nickname?: boolean
    location?: boolean
    abbreviation?: boolean
    logoUrl?: boolean
    division?: boolean
    conference?: boolean
    overallRating?: boolean
    offensiveScheme?: boolean
    defensiveScheme?: boolean
    teamNeeds?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    currentStreak?: boolean
    longestWinningStreak?: boolean
    playoffAppearances?: boolean
    superBowlAppearances?: boolean
    championships?: boolean
    capSpace?: boolean
    capLimit?: boolean
    totalPayroll?: boolean
    financialHealth?: boolean
    yearFounded?: boolean
    allTimeWins?: boolean
    allTimeLosses?: boolean
    allTimeTies?: boolean
    retiredNumbers?: boolean
    fanBaseSize?: boolean
    prestige?: boolean
    rivalTeams?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    nickname?: boolean
    location?: boolean
    abbreviation?: boolean
    logoUrl?: boolean
    division?: boolean
    conference?: boolean
    overallRating?: boolean
    offensiveScheme?: boolean
    defensiveScheme?: boolean
    teamNeeds?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    currentStreak?: boolean
    longestWinningStreak?: boolean
    playoffAppearances?: boolean
    superBowlAppearances?: boolean
    championships?: boolean
    capSpace?: boolean
    capLimit?: boolean
    totalPayroll?: boolean
    financialHealth?: boolean
    yearFounded?: boolean
    allTimeWins?: boolean
    allTimeLosses?: boolean
    allTimeTies?: boolean
    retiredNumbers?: boolean
    fanBaseSize?: boolean
    prestige?: boolean
    rivalTeams?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nickname" | "location" | "abbreviation" | "logoUrl" | "division" | "conference" | "overallRating" | "offensiveScheme" | "defensiveScheme" | "teamNeeds" | "wins" | "losses" | "ties" | "currentStreak" | "longestWinningStreak" | "playoffAppearances" | "superBowlAppearances" | "championships" | "capSpace" | "capLimit" | "totalPayroll" | "financialHealth" | "yearFounded" | "allTimeWins" | "allTimeLosses" | "allTimeTies" | "retiredNumbers" | "fanBaseSize" | "prestige" | "rivalTeams", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | Team$playersArgs<ExtArgs>
    practiceSquad?: boolean | Team$practiceSquadArgs<ExtArgs>
    injuredReserve?: boolean | Team$injuredReserveArgs<ExtArgs>
    suspendedList?: boolean | Team$suspendedListArgs<ExtArgs>
    playerContracts?: boolean | Team$playerContractsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      players: Prisma.$PlayerPayload<ExtArgs>[]
      practiceSquad: Prisma.$PlayerPayload<ExtArgs>[]
      injuredReserve: Prisma.$PlayerPayload<ExtArgs>[]
      suspendedList: Prisma.$PlayerPayload<ExtArgs>[]
      playerContracts: Prisma.$PlayerContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nickname: string
      location: string
      abbreviation: string
      logoUrl: string | null
      division: $Enums.DivisionEnum
      conference: $Enums.ConferenceEnum
      overallRating: number
      offensiveScheme: $Enums.OffensiveSchemeEnum
      defensiveScheme: $Enums.DefensiveSchemeEnum
      teamNeeds: $Enums.PlayerPositionEnum[]
      wins: number
      losses: number
      ties: number
      currentStreak: number
      longestWinningStreak: number
      playoffAppearances: number
      superBowlAppearances: number
      championships: number
      capSpace: number
      capLimit: number
      totalPayroll: number
      financialHealth: $Enums.FinancialHealthEnum
      yearFounded: number
      allTimeWins: number
      allTimeLosses: number
      allTimeTies: number
      retiredNumbers: number[]
      fanBaseSize: number
      prestige: number
      rivalTeams: string[]
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends Team$playersArgs<ExtArgs> = {}>(args?: Subset<T, Team$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    practiceSquad<T extends Team$practiceSquadArgs<ExtArgs> = {}>(args?: Subset<T, Team$practiceSquadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    injuredReserve<T extends Team$injuredReserveArgs<ExtArgs> = {}>(args?: Subset<T, Team$injuredReserveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suspendedList<T extends Team$suspendedListArgs<ExtArgs> = {}>(args?: Subset<T, Team$suspendedListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerContracts<T extends Team$playerContractsArgs<ExtArgs> = {}>(args?: Subset<T, Team$playerContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly nickname: FieldRef<"Team", 'String'>
    readonly location: FieldRef<"Team", 'String'>
    readonly abbreviation: FieldRef<"Team", 'String'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly division: FieldRef<"Team", 'DivisionEnum'>
    readonly conference: FieldRef<"Team", 'ConferenceEnum'>
    readonly overallRating: FieldRef<"Team", 'Int'>
    readonly offensiveScheme: FieldRef<"Team", 'OffensiveSchemeEnum'>
    readonly defensiveScheme: FieldRef<"Team", 'DefensiveSchemeEnum'>
    readonly teamNeeds: FieldRef<"Team", 'PlayerPositionEnum[]'>
    readonly wins: FieldRef<"Team", 'Int'>
    readonly losses: FieldRef<"Team", 'Int'>
    readonly ties: FieldRef<"Team", 'Int'>
    readonly currentStreak: FieldRef<"Team", 'Int'>
    readonly longestWinningStreak: FieldRef<"Team", 'Int'>
    readonly playoffAppearances: FieldRef<"Team", 'Int'>
    readonly superBowlAppearances: FieldRef<"Team", 'Int'>
    readonly championships: FieldRef<"Team", 'Int'>
    readonly capSpace: FieldRef<"Team", 'Int'>
    readonly capLimit: FieldRef<"Team", 'Int'>
    readonly totalPayroll: FieldRef<"Team", 'Int'>
    readonly financialHealth: FieldRef<"Team", 'FinancialHealthEnum'>
    readonly yearFounded: FieldRef<"Team", 'Int'>
    readonly allTimeWins: FieldRef<"Team", 'Int'>
    readonly allTimeLosses: FieldRef<"Team", 'Int'>
    readonly allTimeTies: FieldRef<"Team", 'Int'>
    readonly retiredNumbers: FieldRef<"Team", 'Int[]'>
    readonly fanBaseSize: FieldRef<"Team", 'Int'>
    readonly prestige: FieldRef<"Team", 'Int'>
    readonly rivalTeams: FieldRef<"Team", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.players
   */
  export type Team$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Team.practiceSquad
   */
  export type Team$practiceSquadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Team.injuredReserve
   */
  export type Team$injuredReserveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Team.suspendedList
   */
  export type Team$suspendedListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Team.playerContracts
   */
  export type Team$playerContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    where?: PlayerContractWhereInput
    orderBy?: PlayerContractOrderByWithRelationInput | PlayerContractOrderByWithRelationInput[]
    cursor?: PlayerContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerContractScalarFieldEnum | PlayerContractScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model PlayerContract
   */

  export type AggregatePlayerContract = {
    _count: PlayerContractCountAggregateOutputType | null
    _avg: PlayerContractAvgAggregateOutputType | null
    _sum: PlayerContractSumAggregateOutputType | null
    _min: PlayerContractMinAggregateOutputType | null
    _max: PlayerContractMaxAggregateOutputType | null
  }

  export type PlayerContractAvgAggregateOutputType = {
    startSeason: number | null
    endSeason: number | null
    totalValue: number | null
    averagePerYear: number | null
    totalGuaranteed: number | null
  }

  export type PlayerContractSumAggregateOutputType = {
    startSeason: number | null
    endSeason: number | null
    totalValue: number | null
    averagePerYear: number | null
    totalGuaranteed: number | null
  }

  export type PlayerContractMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    teamId: string | null
    signedDate: Date | null
    startSeason: number | null
    endSeason: number | null
    totalValue: number | null
    averagePerYear: number | null
    totalGuaranteed: number | null
    isRookieContract: boolean | null
    isFranchiseTag: boolean | null
    isExtension: boolean | null
    isPlayerOptOut: boolean | null
    isTeamOptOut: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerContractMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    teamId: string | null
    signedDate: Date | null
    startSeason: number | null
    endSeason: number | null
    totalValue: number | null
    averagePerYear: number | null
    totalGuaranteed: number | null
    isRookieContract: boolean | null
    isFranchiseTag: boolean | null
    isExtension: boolean | null
    isPlayerOptOut: boolean | null
    isTeamOptOut: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerContractCountAggregateOutputType = {
    id: number
    playerId: number
    teamId: number
    signedDate: number
    startSeason: number
    endSeason: number
    totalValue: number
    averagePerYear: number
    totalGuaranteed: number
    isRookieContract: number
    isFranchiseTag: number
    isExtension: number
    isPlayerOptOut: number
    isTeamOptOut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerContractAvgAggregateInputType = {
    startSeason?: true
    endSeason?: true
    totalValue?: true
    averagePerYear?: true
    totalGuaranteed?: true
  }

  export type PlayerContractSumAggregateInputType = {
    startSeason?: true
    endSeason?: true
    totalValue?: true
    averagePerYear?: true
    totalGuaranteed?: true
  }

  export type PlayerContractMinAggregateInputType = {
    id?: true
    playerId?: true
    teamId?: true
    signedDate?: true
    startSeason?: true
    endSeason?: true
    totalValue?: true
    averagePerYear?: true
    totalGuaranteed?: true
    isRookieContract?: true
    isFranchiseTag?: true
    isExtension?: true
    isPlayerOptOut?: true
    isTeamOptOut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerContractMaxAggregateInputType = {
    id?: true
    playerId?: true
    teamId?: true
    signedDate?: true
    startSeason?: true
    endSeason?: true
    totalValue?: true
    averagePerYear?: true
    totalGuaranteed?: true
    isRookieContract?: true
    isFranchiseTag?: true
    isExtension?: true
    isPlayerOptOut?: true
    isTeamOptOut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerContractCountAggregateInputType = {
    id?: true
    playerId?: true
    teamId?: true
    signedDate?: true
    startSeason?: true
    endSeason?: true
    totalValue?: true
    averagePerYear?: true
    totalGuaranteed?: true
    isRookieContract?: true
    isFranchiseTag?: true
    isExtension?: true
    isPlayerOptOut?: true
    isTeamOptOut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerContract to aggregate.
     */
    where?: PlayerContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerContracts to fetch.
     */
    orderBy?: PlayerContractOrderByWithRelationInput | PlayerContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerContracts
    **/
    _count?: true | PlayerContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerContractMaxAggregateInputType
  }

  export type GetPlayerContractAggregateType<T extends PlayerContractAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerContract[P]>
      : GetScalarType<T[P], AggregatePlayerContract[P]>
  }




  export type PlayerContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerContractWhereInput
    orderBy?: PlayerContractOrderByWithAggregationInput | PlayerContractOrderByWithAggregationInput[]
    by: PlayerContractScalarFieldEnum[] | PlayerContractScalarFieldEnum
    having?: PlayerContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerContractCountAggregateInputType | true
    _avg?: PlayerContractAvgAggregateInputType
    _sum?: PlayerContractSumAggregateInputType
    _min?: PlayerContractMinAggregateInputType
    _max?: PlayerContractMaxAggregateInputType
  }

  export type PlayerContractGroupByOutputType = {
    id: string
    playerId: string | null
    teamId: string | null
    signedDate: Date | null
    startSeason: number | null
    endSeason: number | null
    totalValue: number | null
    averagePerYear: number | null
    totalGuaranteed: number | null
    isRookieContract: boolean | null
    isFranchiseTag: boolean | null
    isExtension: boolean | null
    isPlayerOptOut: boolean | null
    isTeamOptOut: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerContractCountAggregateOutputType | null
    _avg: PlayerContractAvgAggregateOutputType | null
    _sum: PlayerContractSumAggregateOutputType | null
    _min: PlayerContractMinAggregateOutputType | null
    _max: PlayerContractMaxAggregateOutputType | null
  }

  type GetPlayerContractGroupByPayload<T extends PlayerContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerContractGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerContractGroupByOutputType[P]>
        }
      >
    >


  export type PlayerContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    teamId?: boolean
    signedDate?: boolean
    startSeason?: boolean
    endSeason?: boolean
    totalValue?: boolean
    averagePerYear?: boolean
    totalGuaranteed?: boolean
    isRookieContract?: boolean
    isFranchiseTag?: boolean
    isExtension?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerContract$playerArgs<ExtArgs>
    team?: boolean | PlayerContract$teamArgs<ExtArgs>
    bonuses?: boolean | PlayerContract$bonusesArgs<ExtArgs>
    salaries?: boolean | PlayerContract$salariesArgs<ExtArgs>
    capHits?: boolean | PlayerContract$capHitsArgs<ExtArgs>
    deadCaps?: boolean | PlayerContract$deadCapsArgs<ExtArgs>
    optOutYears?: boolean | PlayerContract$optOutYearsArgs<ExtArgs>
    restructureEvents?: boolean | PlayerContract$restructureEventsArgs<ExtArgs>
    clauses?: boolean | PlayerContract$clausesArgs<ExtArgs>
    _count?: boolean | PlayerContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerContract"]>

  export type PlayerContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    teamId?: boolean
    signedDate?: boolean
    startSeason?: boolean
    endSeason?: boolean
    totalValue?: boolean
    averagePerYear?: boolean
    totalGuaranteed?: boolean
    isRookieContract?: boolean
    isFranchiseTag?: boolean
    isExtension?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerContract$playerArgs<ExtArgs>
    team?: boolean | PlayerContract$teamArgs<ExtArgs>
  }, ExtArgs["result"]["playerContract"]>

  export type PlayerContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    teamId?: boolean
    signedDate?: boolean
    startSeason?: boolean
    endSeason?: boolean
    totalValue?: boolean
    averagePerYear?: boolean
    totalGuaranteed?: boolean
    isRookieContract?: boolean
    isFranchiseTag?: boolean
    isExtension?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerContract$playerArgs<ExtArgs>
    team?: boolean | PlayerContract$teamArgs<ExtArgs>
  }, ExtArgs["result"]["playerContract"]>

  export type PlayerContractSelectScalar = {
    id?: boolean
    playerId?: boolean
    teamId?: boolean
    signedDate?: boolean
    startSeason?: boolean
    endSeason?: boolean
    totalValue?: boolean
    averagePerYear?: boolean
    totalGuaranteed?: boolean
    isRookieContract?: boolean
    isFranchiseTag?: boolean
    isExtension?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "teamId" | "signedDate" | "startSeason" | "endSeason" | "totalValue" | "averagePerYear" | "totalGuaranteed" | "isRookieContract" | "isFranchiseTag" | "isExtension" | "isPlayerOptOut" | "isTeamOptOut" | "createdAt" | "updatedAt", ExtArgs["result"]["playerContract"]>
  export type PlayerContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerContract$playerArgs<ExtArgs>
    team?: boolean | PlayerContract$teamArgs<ExtArgs>
    bonuses?: boolean | PlayerContract$bonusesArgs<ExtArgs>
    salaries?: boolean | PlayerContract$salariesArgs<ExtArgs>
    capHits?: boolean | PlayerContract$capHitsArgs<ExtArgs>
    deadCaps?: boolean | PlayerContract$deadCapsArgs<ExtArgs>
    optOutYears?: boolean | PlayerContract$optOutYearsArgs<ExtArgs>
    restructureEvents?: boolean | PlayerContract$restructureEventsArgs<ExtArgs>
    clauses?: boolean | PlayerContract$clausesArgs<ExtArgs>
    _count?: boolean | PlayerContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerContract$playerArgs<ExtArgs>
    team?: boolean | PlayerContract$teamArgs<ExtArgs>
  }
  export type PlayerContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerContract$playerArgs<ExtArgs>
    team?: boolean | PlayerContract$teamArgs<ExtArgs>
  }

  export type $PlayerContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerContract"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
      bonuses: Prisma.$ContractBonusPayload<ExtArgs>[]
      salaries: Prisma.$SalaryByYearPayload<ExtArgs>[]
      capHits: Prisma.$CapHitByYearPayload<ExtArgs>[]
      deadCaps: Prisma.$DeadCapByYearPayload<ExtArgs>[]
      optOutYears: Prisma.$OptOutYearPayload<ExtArgs>[]
      restructureEvents: Prisma.$RestructureEventPayload<ExtArgs>[]
      clauses: Prisma.$ContractClausePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string | null
      teamId: string | null
      signedDate: Date | null
      startSeason: number | null
      endSeason: number | null
      totalValue: number | null
      averagePerYear: number | null
      totalGuaranteed: number | null
      isRookieContract: boolean | null
      isFranchiseTag: boolean | null
      isExtension: boolean | null
      isPlayerOptOut: boolean | null
      isTeamOptOut: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerContract"]>
    composites: {}
  }

  type PlayerContractGetPayload<S extends boolean | null | undefined | PlayerContractDefaultArgs> = $Result.GetResult<Prisma.$PlayerContractPayload, S>

  type PlayerContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerContractCountAggregateInputType | true
    }

  export interface PlayerContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerContract'], meta: { name: 'PlayerContract' } }
    /**
     * Find zero or one PlayerContract that matches the filter.
     * @param {PlayerContractFindUniqueArgs} args - Arguments to find a PlayerContract
     * @example
     * // Get one PlayerContract
     * const playerContract = await prisma.playerContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerContractFindUniqueArgs>(args: SelectSubset<T, PlayerContractFindUniqueArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerContract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerContractFindUniqueOrThrowArgs} args - Arguments to find a PlayerContract
     * @example
     * // Get one PlayerContract
     * const playerContract = await prisma.playerContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerContractFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractFindFirstArgs} args - Arguments to find a PlayerContract
     * @example
     * // Get one PlayerContract
     * const playerContract = await prisma.playerContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerContractFindFirstArgs>(args?: SelectSubset<T, PlayerContractFindFirstArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractFindFirstOrThrowArgs} args - Arguments to find a PlayerContract
     * @example
     * // Get one PlayerContract
     * const playerContract = await prisma.playerContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerContractFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerContracts
     * const playerContracts = await prisma.playerContract.findMany()
     * 
     * // Get first 10 PlayerContracts
     * const playerContracts = await prisma.playerContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerContractWithIdOnly = await prisma.playerContract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerContractFindManyArgs>(args?: SelectSubset<T, PlayerContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerContract.
     * @param {PlayerContractCreateArgs} args - Arguments to create a PlayerContract.
     * @example
     * // Create one PlayerContract
     * const PlayerContract = await prisma.playerContract.create({
     *   data: {
     *     // ... data to create a PlayerContract
     *   }
     * })
     * 
     */
    create<T extends PlayerContractCreateArgs>(args: SelectSubset<T, PlayerContractCreateArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerContracts.
     * @param {PlayerContractCreateManyArgs} args - Arguments to create many PlayerContracts.
     * @example
     * // Create many PlayerContracts
     * const playerContract = await prisma.playerContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerContractCreateManyArgs>(args?: SelectSubset<T, PlayerContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerContracts and returns the data saved in the database.
     * @param {PlayerContractCreateManyAndReturnArgs} args - Arguments to create many PlayerContracts.
     * @example
     * // Create many PlayerContracts
     * const playerContract = await prisma.playerContract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerContracts and only return the `id`
     * const playerContractWithIdOnly = await prisma.playerContract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerContractCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerContract.
     * @param {PlayerContractDeleteArgs} args - Arguments to delete one PlayerContract.
     * @example
     * // Delete one PlayerContract
     * const PlayerContract = await prisma.playerContract.delete({
     *   where: {
     *     // ... filter to delete one PlayerContract
     *   }
     * })
     * 
     */
    delete<T extends PlayerContractDeleteArgs>(args: SelectSubset<T, PlayerContractDeleteArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerContract.
     * @param {PlayerContractUpdateArgs} args - Arguments to update one PlayerContract.
     * @example
     * // Update one PlayerContract
     * const playerContract = await prisma.playerContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerContractUpdateArgs>(args: SelectSubset<T, PlayerContractUpdateArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerContracts.
     * @param {PlayerContractDeleteManyArgs} args - Arguments to filter PlayerContracts to delete.
     * @example
     * // Delete a few PlayerContracts
     * const { count } = await prisma.playerContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerContractDeleteManyArgs>(args?: SelectSubset<T, PlayerContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerContracts
     * const playerContract = await prisma.playerContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerContractUpdateManyArgs>(args: SelectSubset<T, PlayerContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerContracts and returns the data updated in the database.
     * @param {PlayerContractUpdateManyAndReturnArgs} args - Arguments to update many PlayerContracts.
     * @example
     * // Update many PlayerContracts
     * const playerContract = await prisma.playerContract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerContracts and only return the `id`
     * const playerContractWithIdOnly = await prisma.playerContract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerContractUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerContract.
     * @param {PlayerContractUpsertArgs} args - Arguments to update or create a PlayerContract.
     * @example
     * // Update or create a PlayerContract
     * const playerContract = await prisma.playerContract.upsert({
     *   create: {
     *     // ... data to create a PlayerContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerContract we want to update
     *   }
     * })
     */
    upsert<T extends PlayerContractUpsertArgs>(args: SelectSubset<T, PlayerContractUpsertArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractCountArgs} args - Arguments to filter PlayerContracts to count.
     * @example
     * // Count the number of PlayerContracts
     * const count = await prisma.playerContract.count({
     *   where: {
     *     // ... the filter for the PlayerContracts we want to count
     *   }
     * })
    **/
    count<T extends PlayerContractCountArgs>(
      args?: Subset<T, PlayerContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerContractAggregateArgs>(args: Subset<T, PlayerContractAggregateArgs>): Prisma.PrismaPromise<GetPlayerContractAggregateType<T>>

    /**
     * Group by PlayerContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerContractGroupByArgs['orderBy'] }
        : { orderBy?: PlayerContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerContract model
   */
  readonly fields: PlayerContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerContract$playerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends PlayerContract$teamArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bonuses<T extends PlayerContract$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaries<T extends PlayerContract$salariesArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$salariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capHits<T extends PlayerContract$capHitsArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$capHitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deadCaps<T extends PlayerContract$deadCapsArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$deadCapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    optOutYears<T extends PlayerContract$optOutYearsArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$optOutYearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    restructureEvents<T extends PlayerContract$restructureEventsArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$restructureEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clauses<T extends PlayerContract$clausesArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContract$clausesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerContract model
   */
  interface PlayerContractFieldRefs {
    readonly id: FieldRef<"PlayerContract", 'String'>
    readonly playerId: FieldRef<"PlayerContract", 'String'>
    readonly teamId: FieldRef<"PlayerContract", 'String'>
    readonly signedDate: FieldRef<"PlayerContract", 'DateTime'>
    readonly startSeason: FieldRef<"PlayerContract", 'Int'>
    readonly endSeason: FieldRef<"PlayerContract", 'Int'>
    readonly totalValue: FieldRef<"PlayerContract", 'Int'>
    readonly averagePerYear: FieldRef<"PlayerContract", 'Int'>
    readonly totalGuaranteed: FieldRef<"PlayerContract", 'Int'>
    readonly isRookieContract: FieldRef<"PlayerContract", 'Boolean'>
    readonly isFranchiseTag: FieldRef<"PlayerContract", 'Boolean'>
    readonly isExtension: FieldRef<"PlayerContract", 'Boolean'>
    readonly isPlayerOptOut: FieldRef<"PlayerContract", 'Boolean'>
    readonly isTeamOptOut: FieldRef<"PlayerContract", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerContract", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerContract findUnique
   */
  export type PlayerContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * Filter, which PlayerContract to fetch.
     */
    where: PlayerContractWhereUniqueInput
  }

  /**
   * PlayerContract findUniqueOrThrow
   */
  export type PlayerContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * Filter, which PlayerContract to fetch.
     */
    where: PlayerContractWhereUniqueInput
  }

  /**
   * PlayerContract findFirst
   */
  export type PlayerContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * Filter, which PlayerContract to fetch.
     */
    where?: PlayerContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerContracts to fetch.
     */
    orderBy?: PlayerContractOrderByWithRelationInput | PlayerContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerContracts.
     */
    cursor?: PlayerContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerContracts.
     */
    distinct?: PlayerContractScalarFieldEnum | PlayerContractScalarFieldEnum[]
  }

  /**
   * PlayerContract findFirstOrThrow
   */
  export type PlayerContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * Filter, which PlayerContract to fetch.
     */
    where?: PlayerContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerContracts to fetch.
     */
    orderBy?: PlayerContractOrderByWithRelationInput | PlayerContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerContracts.
     */
    cursor?: PlayerContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerContracts.
     */
    distinct?: PlayerContractScalarFieldEnum | PlayerContractScalarFieldEnum[]
  }

  /**
   * PlayerContract findMany
   */
  export type PlayerContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * Filter, which PlayerContracts to fetch.
     */
    where?: PlayerContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerContracts to fetch.
     */
    orderBy?: PlayerContractOrderByWithRelationInput | PlayerContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerContracts.
     */
    cursor?: PlayerContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerContracts.
     */
    skip?: number
    distinct?: PlayerContractScalarFieldEnum | PlayerContractScalarFieldEnum[]
  }

  /**
   * PlayerContract create
   */
  export type PlayerContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerContract.
     */
    data: XOR<PlayerContractCreateInput, PlayerContractUncheckedCreateInput>
  }

  /**
   * PlayerContract createMany
   */
  export type PlayerContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerContracts.
     */
    data: PlayerContractCreateManyInput | PlayerContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerContract createManyAndReturn
   */
  export type PlayerContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerContracts.
     */
    data: PlayerContractCreateManyInput | PlayerContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerContract update
   */
  export type PlayerContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerContract.
     */
    data: XOR<PlayerContractUpdateInput, PlayerContractUncheckedUpdateInput>
    /**
     * Choose, which PlayerContract to update.
     */
    where: PlayerContractWhereUniqueInput
  }

  /**
   * PlayerContract updateMany
   */
  export type PlayerContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerContracts.
     */
    data: XOR<PlayerContractUpdateManyMutationInput, PlayerContractUncheckedUpdateManyInput>
    /**
     * Filter which PlayerContracts to update
     */
    where?: PlayerContractWhereInput
    /**
     * Limit how many PlayerContracts to update.
     */
    limit?: number
  }

  /**
   * PlayerContract updateManyAndReturn
   */
  export type PlayerContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * The data used to update PlayerContracts.
     */
    data: XOR<PlayerContractUpdateManyMutationInput, PlayerContractUncheckedUpdateManyInput>
    /**
     * Filter which PlayerContracts to update
     */
    where?: PlayerContractWhereInput
    /**
     * Limit how many PlayerContracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerContract upsert
   */
  export type PlayerContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerContract to update in case it exists.
     */
    where: PlayerContractWhereUniqueInput
    /**
     * In case the PlayerContract found by the `where` argument doesn't exist, create a new PlayerContract with this data.
     */
    create: XOR<PlayerContractCreateInput, PlayerContractUncheckedCreateInput>
    /**
     * In case the PlayerContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerContractUpdateInput, PlayerContractUncheckedUpdateInput>
  }

  /**
   * PlayerContract delete
   */
  export type PlayerContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
    /**
     * Filter which PlayerContract to delete.
     */
    where: PlayerContractWhereUniqueInput
  }

  /**
   * PlayerContract deleteMany
   */
  export type PlayerContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerContracts to delete
     */
    where?: PlayerContractWhereInput
    /**
     * Limit how many PlayerContracts to delete.
     */
    limit?: number
  }

  /**
   * PlayerContract.player
   */
  export type PlayerContract$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * PlayerContract.team
   */
  export type PlayerContract$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * PlayerContract.bonuses
   */
  export type PlayerContract$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    where?: ContractBonusWhereInput
    orderBy?: ContractBonusOrderByWithRelationInput | ContractBonusOrderByWithRelationInput[]
    cursor?: ContractBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractBonusScalarFieldEnum | ContractBonusScalarFieldEnum[]
  }

  /**
   * PlayerContract.salaries
   */
  export type PlayerContract$salariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    where?: SalaryByYearWhereInput
    orderBy?: SalaryByYearOrderByWithRelationInput | SalaryByYearOrderByWithRelationInput[]
    cursor?: SalaryByYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryByYearScalarFieldEnum | SalaryByYearScalarFieldEnum[]
  }

  /**
   * PlayerContract.capHits
   */
  export type PlayerContract$capHitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    where?: CapHitByYearWhereInput
    orderBy?: CapHitByYearOrderByWithRelationInput | CapHitByYearOrderByWithRelationInput[]
    cursor?: CapHitByYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapHitByYearScalarFieldEnum | CapHitByYearScalarFieldEnum[]
  }

  /**
   * PlayerContract.deadCaps
   */
  export type PlayerContract$deadCapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    where?: DeadCapByYearWhereInput
    orderBy?: DeadCapByYearOrderByWithRelationInput | DeadCapByYearOrderByWithRelationInput[]
    cursor?: DeadCapByYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeadCapByYearScalarFieldEnum | DeadCapByYearScalarFieldEnum[]
  }

  /**
   * PlayerContract.optOutYears
   */
  export type PlayerContract$optOutYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    where?: OptOutYearWhereInput
    orderBy?: OptOutYearOrderByWithRelationInput | OptOutYearOrderByWithRelationInput[]
    cursor?: OptOutYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptOutYearScalarFieldEnum | OptOutYearScalarFieldEnum[]
  }

  /**
   * PlayerContract.restructureEvents
   */
  export type PlayerContract$restructureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    where?: RestructureEventWhereInput
    orderBy?: RestructureEventOrderByWithRelationInput | RestructureEventOrderByWithRelationInput[]
    cursor?: RestructureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestructureEventScalarFieldEnum | RestructureEventScalarFieldEnum[]
  }

  /**
   * PlayerContract.clauses
   */
  export type PlayerContract$clausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    where?: ContractClauseWhereInput
    orderBy?: ContractClauseOrderByWithRelationInput | ContractClauseOrderByWithRelationInput[]
    cursor?: ContractClauseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractClauseScalarFieldEnum | ContractClauseScalarFieldEnum[]
  }

  /**
   * PlayerContract without action
   */
  export type PlayerContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerContract
     */
    select?: PlayerContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerContract
     */
    omit?: PlayerContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerContractInclude<ExtArgs> | null
  }


  /**
   * Model ContractBonus
   */

  export type AggregateContractBonus = {
    _count: ContractBonusCountAggregateOutputType | null
    _avg: ContractBonusAvgAggregateOutputType | null
    _sum: ContractBonusSumAggregateOutputType | null
    _min: ContractBonusMinAggregateOutputType | null
    _max: ContractBonusMaxAggregateOutputType | null
  }

  export type ContractBonusAvgAggregateOutputType = {
    year: number | null
    signingBonus: number | null
    rosterBonus: number | null
    workoutBonus: number | null
    incentiveBonus: number | null
  }

  export type ContractBonusSumAggregateOutputType = {
    year: number | null
    signingBonus: number | null
    rosterBonus: number | null
    workoutBonus: number | null
    incentiveBonus: number | null
  }

  export type ContractBonusMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    signingBonus: number | null
    rosterBonus: number | null
    workoutBonus: number | null
    incentiveBonus: number | null
  }

  export type ContractBonusMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    signingBonus: number | null
    rosterBonus: number | null
    workoutBonus: number | null
    incentiveBonus: number | null
  }

  export type ContractBonusCountAggregateOutputType = {
    id: number
    contractId: number
    year: number
    signingBonus: number
    rosterBonus: number
    workoutBonus: number
    incentiveBonus: number
    _all: number
  }


  export type ContractBonusAvgAggregateInputType = {
    year?: true
    signingBonus?: true
    rosterBonus?: true
    workoutBonus?: true
    incentiveBonus?: true
  }

  export type ContractBonusSumAggregateInputType = {
    year?: true
    signingBonus?: true
    rosterBonus?: true
    workoutBonus?: true
    incentiveBonus?: true
  }

  export type ContractBonusMinAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    signingBonus?: true
    rosterBonus?: true
    workoutBonus?: true
    incentiveBonus?: true
  }

  export type ContractBonusMaxAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    signingBonus?: true
    rosterBonus?: true
    workoutBonus?: true
    incentiveBonus?: true
  }

  export type ContractBonusCountAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    signingBonus?: true
    rosterBonus?: true
    workoutBonus?: true
    incentiveBonus?: true
    _all?: true
  }

  export type ContractBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractBonus to aggregate.
     */
    where?: ContractBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractBonuses to fetch.
     */
    orderBy?: ContractBonusOrderByWithRelationInput | ContractBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractBonuses
    **/
    _count?: true | ContractBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractBonusMaxAggregateInputType
  }

  export type GetContractBonusAggregateType<T extends ContractBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateContractBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractBonus[P]>
      : GetScalarType<T[P], AggregateContractBonus[P]>
  }




  export type ContractBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractBonusWhereInput
    orderBy?: ContractBonusOrderByWithAggregationInput | ContractBonusOrderByWithAggregationInput[]
    by: ContractBonusScalarFieldEnum[] | ContractBonusScalarFieldEnum
    having?: ContractBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractBonusCountAggregateInputType | true
    _avg?: ContractBonusAvgAggregateInputType
    _sum?: ContractBonusSumAggregateInputType
    _min?: ContractBonusMinAggregateInputType
    _max?: ContractBonusMaxAggregateInputType
  }

  export type ContractBonusGroupByOutputType = {
    id: string
    contractId: string
    year: number
    signingBonus: number | null
    rosterBonus: number | null
    workoutBonus: number | null
    incentiveBonus: number | null
    _count: ContractBonusCountAggregateOutputType | null
    _avg: ContractBonusAvgAggregateOutputType | null
    _sum: ContractBonusSumAggregateOutputType | null
    _min: ContractBonusMinAggregateOutputType | null
    _max: ContractBonusMaxAggregateOutputType | null
  }

  type GetContractBonusGroupByPayload<T extends ContractBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractBonusGroupByOutputType[P]>
            : GetScalarType<T[P], ContractBonusGroupByOutputType[P]>
        }
      >
    >


  export type ContractBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    signingBonus?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentiveBonus?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractBonus"]>

  export type ContractBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    signingBonus?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentiveBonus?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractBonus"]>

  export type ContractBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    signingBonus?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentiveBonus?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractBonus"]>

  export type ContractBonusSelectScalar = {
    id?: boolean
    contractId?: boolean
    year?: boolean
    signingBonus?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentiveBonus?: boolean
  }

  export type ContractBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "year" | "signingBonus" | "rosterBonus" | "workoutBonus" | "incentiveBonus", ExtArgs["result"]["contractBonus"]>
  export type ContractBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type ContractBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type ContractBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $ContractBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractBonus"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      year: number
      signingBonus: number | null
      rosterBonus: number | null
      workoutBonus: number | null
      incentiveBonus: number | null
    }, ExtArgs["result"]["contractBonus"]>
    composites: {}
  }

  type ContractBonusGetPayload<S extends boolean | null | undefined | ContractBonusDefaultArgs> = $Result.GetResult<Prisma.$ContractBonusPayload, S>

  type ContractBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractBonusCountAggregateInputType | true
    }

  export interface ContractBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractBonus'], meta: { name: 'ContractBonus' } }
    /**
     * Find zero or one ContractBonus that matches the filter.
     * @param {ContractBonusFindUniqueArgs} args - Arguments to find a ContractBonus
     * @example
     * // Get one ContractBonus
     * const contractBonus = await prisma.contractBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractBonusFindUniqueArgs>(args: SelectSubset<T, ContractBonusFindUniqueArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractBonusFindUniqueOrThrowArgs} args - Arguments to find a ContractBonus
     * @example
     * // Get one ContractBonus
     * const contractBonus = await prisma.contractBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusFindFirstArgs} args - Arguments to find a ContractBonus
     * @example
     * // Get one ContractBonus
     * const contractBonus = await prisma.contractBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractBonusFindFirstArgs>(args?: SelectSubset<T, ContractBonusFindFirstArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusFindFirstOrThrowArgs} args - Arguments to find a ContractBonus
     * @example
     * // Get one ContractBonus
     * const contractBonus = await prisma.contractBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractBonuses
     * const contractBonuses = await prisma.contractBonus.findMany()
     * 
     * // Get first 10 ContractBonuses
     * const contractBonuses = await prisma.contractBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractBonusWithIdOnly = await prisma.contractBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractBonusFindManyArgs>(args?: SelectSubset<T, ContractBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractBonus.
     * @param {ContractBonusCreateArgs} args - Arguments to create a ContractBonus.
     * @example
     * // Create one ContractBonus
     * const ContractBonus = await prisma.contractBonus.create({
     *   data: {
     *     // ... data to create a ContractBonus
     *   }
     * })
     * 
     */
    create<T extends ContractBonusCreateArgs>(args: SelectSubset<T, ContractBonusCreateArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractBonuses.
     * @param {ContractBonusCreateManyArgs} args - Arguments to create many ContractBonuses.
     * @example
     * // Create many ContractBonuses
     * const contractBonus = await prisma.contractBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractBonusCreateManyArgs>(args?: SelectSubset<T, ContractBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractBonuses and returns the data saved in the database.
     * @param {ContractBonusCreateManyAndReturnArgs} args - Arguments to create many ContractBonuses.
     * @example
     * // Create many ContractBonuses
     * const contractBonus = await prisma.contractBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractBonuses and only return the `id`
     * const contractBonusWithIdOnly = await prisma.contractBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractBonus.
     * @param {ContractBonusDeleteArgs} args - Arguments to delete one ContractBonus.
     * @example
     * // Delete one ContractBonus
     * const ContractBonus = await prisma.contractBonus.delete({
     *   where: {
     *     // ... filter to delete one ContractBonus
     *   }
     * })
     * 
     */
    delete<T extends ContractBonusDeleteArgs>(args: SelectSubset<T, ContractBonusDeleteArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractBonus.
     * @param {ContractBonusUpdateArgs} args - Arguments to update one ContractBonus.
     * @example
     * // Update one ContractBonus
     * const contractBonus = await prisma.contractBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractBonusUpdateArgs>(args: SelectSubset<T, ContractBonusUpdateArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractBonuses.
     * @param {ContractBonusDeleteManyArgs} args - Arguments to filter ContractBonuses to delete.
     * @example
     * // Delete a few ContractBonuses
     * const { count } = await prisma.contractBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractBonusDeleteManyArgs>(args?: SelectSubset<T, ContractBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractBonuses
     * const contractBonus = await prisma.contractBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractBonusUpdateManyArgs>(args: SelectSubset<T, ContractBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractBonuses and returns the data updated in the database.
     * @param {ContractBonusUpdateManyAndReturnArgs} args - Arguments to update many ContractBonuses.
     * @example
     * // Update many ContractBonuses
     * const contractBonus = await prisma.contractBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractBonuses and only return the `id`
     * const contractBonusWithIdOnly = await prisma.contractBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractBonus.
     * @param {ContractBonusUpsertArgs} args - Arguments to update or create a ContractBonus.
     * @example
     * // Update or create a ContractBonus
     * const contractBonus = await prisma.contractBonus.upsert({
     *   create: {
     *     // ... data to create a ContractBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractBonus we want to update
     *   }
     * })
     */
    upsert<T extends ContractBonusUpsertArgs>(args: SelectSubset<T, ContractBonusUpsertArgs<ExtArgs>>): Prisma__ContractBonusClient<$Result.GetResult<Prisma.$ContractBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusCountArgs} args - Arguments to filter ContractBonuses to count.
     * @example
     * // Count the number of ContractBonuses
     * const count = await prisma.contractBonus.count({
     *   where: {
     *     // ... the filter for the ContractBonuses we want to count
     *   }
     * })
    **/
    count<T extends ContractBonusCountArgs>(
      args?: Subset<T, ContractBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractBonusAggregateArgs>(args: Subset<T, ContractBonusAggregateArgs>): Prisma.PrismaPromise<GetContractBonusAggregateType<T>>

    /**
     * Group by ContractBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractBonusGroupByArgs['orderBy'] }
        : { orderBy?: ContractBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractBonus model
   */
  readonly fields: ContractBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractBonus model
   */
  interface ContractBonusFieldRefs {
    readonly id: FieldRef<"ContractBonus", 'String'>
    readonly contractId: FieldRef<"ContractBonus", 'String'>
    readonly year: FieldRef<"ContractBonus", 'Int'>
    readonly signingBonus: FieldRef<"ContractBonus", 'Int'>
    readonly rosterBonus: FieldRef<"ContractBonus", 'Int'>
    readonly workoutBonus: FieldRef<"ContractBonus", 'Int'>
    readonly incentiveBonus: FieldRef<"ContractBonus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContractBonus findUnique
   */
  export type ContractBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * Filter, which ContractBonus to fetch.
     */
    where: ContractBonusWhereUniqueInput
  }

  /**
   * ContractBonus findUniqueOrThrow
   */
  export type ContractBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * Filter, which ContractBonus to fetch.
     */
    where: ContractBonusWhereUniqueInput
  }

  /**
   * ContractBonus findFirst
   */
  export type ContractBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * Filter, which ContractBonus to fetch.
     */
    where?: ContractBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractBonuses to fetch.
     */
    orderBy?: ContractBonusOrderByWithRelationInput | ContractBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractBonuses.
     */
    cursor?: ContractBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractBonuses.
     */
    distinct?: ContractBonusScalarFieldEnum | ContractBonusScalarFieldEnum[]
  }

  /**
   * ContractBonus findFirstOrThrow
   */
  export type ContractBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * Filter, which ContractBonus to fetch.
     */
    where?: ContractBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractBonuses to fetch.
     */
    orderBy?: ContractBonusOrderByWithRelationInput | ContractBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractBonuses.
     */
    cursor?: ContractBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractBonuses.
     */
    distinct?: ContractBonusScalarFieldEnum | ContractBonusScalarFieldEnum[]
  }

  /**
   * ContractBonus findMany
   */
  export type ContractBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * Filter, which ContractBonuses to fetch.
     */
    where?: ContractBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractBonuses to fetch.
     */
    orderBy?: ContractBonusOrderByWithRelationInput | ContractBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractBonuses.
     */
    cursor?: ContractBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractBonuses.
     */
    skip?: number
    distinct?: ContractBonusScalarFieldEnum | ContractBonusScalarFieldEnum[]
  }

  /**
   * ContractBonus create
   */
  export type ContractBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractBonus.
     */
    data: XOR<ContractBonusCreateInput, ContractBonusUncheckedCreateInput>
  }

  /**
   * ContractBonus createMany
   */
  export type ContractBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractBonuses.
     */
    data: ContractBonusCreateManyInput | ContractBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractBonus createManyAndReturn
   */
  export type ContractBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * The data used to create many ContractBonuses.
     */
    data: ContractBonusCreateManyInput | ContractBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractBonus update
   */
  export type ContractBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractBonus.
     */
    data: XOR<ContractBonusUpdateInput, ContractBonusUncheckedUpdateInput>
    /**
     * Choose, which ContractBonus to update.
     */
    where: ContractBonusWhereUniqueInput
  }

  /**
   * ContractBonus updateMany
   */
  export type ContractBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractBonuses.
     */
    data: XOR<ContractBonusUpdateManyMutationInput, ContractBonusUncheckedUpdateManyInput>
    /**
     * Filter which ContractBonuses to update
     */
    where?: ContractBonusWhereInput
    /**
     * Limit how many ContractBonuses to update.
     */
    limit?: number
  }

  /**
   * ContractBonus updateManyAndReturn
   */
  export type ContractBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * The data used to update ContractBonuses.
     */
    data: XOR<ContractBonusUpdateManyMutationInput, ContractBonusUncheckedUpdateManyInput>
    /**
     * Filter which ContractBonuses to update
     */
    where?: ContractBonusWhereInput
    /**
     * Limit how many ContractBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractBonus upsert
   */
  export type ContractBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractBonus to update in case it exists.
     */
    where: ContractBonusWhereUniqueInput
    /**
     * In case the ContractBonus found by the `where` argument doesn't exist, create a new ContractBonus with this data.
     */
    create: XOR<ContractBonusCreateInput, ContractBonusUncheckedCreateInput>
    /**
     * In case the ContractBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractBonusUpdateInput, ContractBonusUncheckedUpdateInput>
  }

  /**
   * ContractBonus delete
   */
  export type ContractBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
    /**
     * Filter which ContractBonus to delete.
     */
    where: ContractBonusWhereUniqueInput
  }

  /**
   * ContractBonus deleteMany
   */
  export type ContractBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractBonuses to delete
     */
    where?: ContractBonusWhereInput
    /**
     * Limit how many ContractBonuses to delete.
     */
    limit?: number
  }

  /**
   * ContractBonus without action
   */
  export type ContractBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractBonus
     */
    select?: ContractBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractBonus
     */
    omit?: ContractBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractBonusInclude<ExtArgs> | null
  }


  /**
   * Model SalaryByYear
   */

  export type AggregateSalaryByYear = {
    _count: SalaryByYearCountAggregateOutputType | null
    _avg: SalaryByYearAvgAggregateOutputType | null
    _sum: SalaryByYearSumAggregateOutputType | null
    _min: SalaryByYearMinAggregateOutputType | null
    _max: SalaryByYearMaxAggregateOutputType | null
  }

  export type SalaryByYearAvgAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type SalaryByYearSumAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type SalaryByYearMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    amount: number | null
  }

  export type SalaryByYearMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    amount: number | null
  }

  export type SalaryByYearCountAggregateOutputType = {
    id: number
    contractId: number
    year: number
    amount: number
    _all: number
  }


  export type SalaryByYearAvgAggregateInputType = {
    year?: true
    amount?: true
  }

  export type SalaryByYearSumAggregateInputType = {
    year?: true
    amount?: true
  }

  export type SalaryByYearMinAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
  }

  export type SalaryByYearMaxAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
  }

  export type SalaryByYearCountAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
    _all?: true
  }

  export type SalaryByYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryByYear to aggregate.
     */
    where?: SalaryByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryByYears to fetch.
     */
    orderBy?: SalaryByYearOrderByWithRelationInput | SalaryByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryByYears
    **/
    _count?: true | SalaryByYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryByYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryByYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryByYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryByYearMaxAggregateInputType
  }

  export type GetSalaryByYearAggregateType<T extends SalaryByYearAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryByYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryByYear[P]>
      : GetScalarType<T[P], AggregateSalaryByYear[P]>
  }




  export type SalaryByYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryByYearWhereInput
    orderBy?: SalaryByYearOrderByWithAggregationInput | SalaryByYearOrderByWithAggregationInput[]
    by: SalaryByYearScalarFieldEnum[] | SalaryByYearScalarFieldEnum
    having?: SalaryByYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryByYearCountAggregateInputType | true
    _avg?: SalaryByYearAvgAggregateInputType
    _sum?: SalaryByYearSumAggregateInputType
    _min?: SalaryByYearMinAggregateInputType
    _max?: SalaryByYearMaxAggregateInputType
  }

  export type SalaryByYearGroupByOutputType = {
    id: string
    contractId: string
    year: number
    amount: number
    _count: SalaryByYearCountAggregateOutputType | null
    _avg: SalaryByYearAvgAggregateOutputType | null
    _sum: SalaryByYearSumAggregateOutputType | null
    _min: SalaryByYearMinAggregateOutputType | null
    _max: SalaryByYearMaxAggregateOutputType | null
  }

  type GetSalaryByYearGroupByPayload<T extends SalaryByYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryByYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryByYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryByYearGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryByYearGroupByOutputType[P]>
        }
      >
    >


  export type SalaryByYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryByYear"]>

  export type SalaryByYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryByYear"]>

  export type SalaryByYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryByYear"]>

  export type SalaryByYearSelectScalar = {
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
  }

  export type SalaryByYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "year" | "amount", ExtArgs["result"]["salaryByYear"]>
  export type SalaryByYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type SalaryByYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type SalaryByYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $SalaryByYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryByYear"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      year: number
      amount: number
    }, ExtArgs["result"]["salaryByYear"]>
    composites: {}
  }

  type SalaryByYearGetPayload<S extends boolean | null | undefined | SalaryByYearDefaultArgs> = $Result.GetResult<Prisma.$SalaryByYearPayload, S>

  type SalaryByYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryByYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryByYearCountAggregateInputType | true
    }

  export interface SalaryByYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryByYear'], meta: { name: 'SalaryByYear' } }
    /**
     * Find zero or one SalaryByYear that matches the filter.
     * @param {SalaryByYearFindUniqueArgs} args - Arguments to find a SalaryByYear
     * @example
     * // Get one SalaryByYear
     * const salaryByYear = await prisma.salaryByYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryByYearFindUniqueArgs>(args: SelectSubset<T, SalaryByYearFindUniqueArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryByYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryByYearFindUniqueOrThrowArgs} args - Arguments to find a SalaryByYear
     * @example
     * // Get one SalaryByYear
     * const salaryByYear = await prisma.salaryByYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryByYearFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryByYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryByYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearFindFirstArgs} args - Arguments to find a SalaryByYear
     * @example
     * // Get one SalaryByYear
     * const salaryByYear = await prisma.salaryByYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryByYearFindFirstArgs>(args?: SelectSubset<T, SalaryByYearFindFirstArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryByYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearFindFirstOrThrowArgs} args - Arguments to find a SalaryByYear
     * @example
     * // Get one SalaryByYear
     * const salaryByYear = await prisma.salaryByYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryByYearFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryByYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryByYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryByYears
     * const salaryByYears = await prisma.salaryByYear.findMany()
     * 
     * // Get first 10 SalaryByYears
     * const salaryByYears = await prisma.salaryByYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryByYearWithIdOnly = await prisma.salaryByYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryByYearFindManyArgs>(args?: SelectSubset<T, SalaryByYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryByYear.
     * @param {SalaryByYearCreateArgs} args - Arguments to create a SalaryByYear.
     * @example
     * // Create one SalaryByYear
     * const SalaryByYear = await prisma.salaryByYear.create({
     *   data: {
     *     // ... data to create a SalaryByYear
     *   }
     * })
     * 
     */
    create<T extends SalaryByYearCreateArgs>(args: SelectSubset<T, SalaryByYearCreateArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryByYears.
     * @param {SalaryByYearCreateManyArgs} args - Arguments to create many SalaryByYears.
     * @example
     * // Create many SalaryByYears
     * const salaryByYear = await prisma.salaryByYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryByYearCreateManyArgs>(args?: SelectSubset<T, SalaryByYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryByYears and returns the data saved in the database.
     * @param {SalaryByYearCreateManyAndReturnArgs} args - Arguments to create many SalaryByYears.
     * @example
     * // Create many SalaryByYears
     * const salaryByYear = await prisma.salaryByYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryByYears and only return the `id`
     * const salaryByYearWithIdOnly = await prisma.salaryByYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryByYearCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryByYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryByYear.
     * @param {SalaryByYearDeleteArgs} args - Arguments to delete one SalaryByYear.
     * @example
     * // Delete one SalaryByYear
     * const SalaryByYear = await prisma.salaryByYear.delete({
     *   where: {
     *     // ... filter to delete one SalaryByYear
     *   }
     * })
     * 
     */
    delete<T extends SalaryByYearDeleteArgs>(args: SelectSubset<T, SalaryByYearDeleteArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryByYear.
     * @param {SalaryByYearUpdateArgs} args - Arguments to update one SalaryByYear.
     * @example
     * // Update one SalaryByYear
     * const salaryByYear = await prisma.salaryByYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryByYearUpdateArgs>(args: SelectSubset<T, SalaryByYearUpdateArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryByYears.
     * @param {SalaryByYearDeleteManyArgs} args - Arguments to filter SalaryByYears to delete.
     * @example
     * // Delete a few SalaryByYears
     * const { count } = await prisma.salaryByYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryByYearDeleteManyArgs>(args?: SelectSubset<T, SalaryByYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryByYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryByYears
     * const salaryByYear = await prisma.salaryByYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryByYearUpdateManyArgs>(args: SelectSubset<T, SalaryByYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryByYears and returns the data updated in the database.
     * @param {SalaryByYearUpdateManyAndReturnArgs} args - Arguments to update many SalaryByYears.
     * @example
     * // Update many SalaryByYears
     * const salaryByYear = await prisma.salaryByYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryByYears and only return the `id`
     * const salaryByYearWithIdOnly = await prisma.salaryByYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryByYearUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryByYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryByYear.
     * @param {SalaryByYearUpsertArgs} args - Arguments to update or create a SalaryByYear.
     * @example
     * // Update or create a SalaryByYear
     * const salaryByYear = await prisma.salaryByYear.upsert({
     *   create: {
     *     // ... data to create a SalaryByYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryByYear we want to update
     *   }
     * })
     */
    upsert<T extends SalaryByYearUpsertArgs>(args: SelectSubset<T, SalaryByYearUpsertArgs<ExtArgs>>): Prisma__SalaryByYearClient<$Result.GetResult<Prisma.$SalaryByYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryByYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearCountArgs} args - Arguments to filter SalaryByYears to count.
     * @example
     * // Count the number of SalaryByYears
     * const count = await prisma.salaryByYear.count({
     *   where: {
     *     // ... the filter for the SalaryByYears we want to count
     *   }
     * })
    **/
    count<T extends SalaryByYearCountArgs>(
      args?: Subset<T, SalaryByYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryByYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryByYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryByYearAggregateArgs>(args: Subset<T, SalaryByYearAggregateArgs>): Prisma.PrismaPromise<GetSalaryByYearAggregateType<T>>

    /**
     * Group by SalaryByYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryByYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryByYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryByYearGroupByArgs['orderBy'] }
        : { orderBy?: SalaryByYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryByYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryByYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryByYear model
   */
  readonly fields: SalaryByYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryByYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryByYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryByYear model
   */
  interface SalaryByYearFieldRefs {
    readonly id: FieldRef<"SalaryByYear", 'String'>
    readonly contractId: FieldRef<"SalaryByYear", 'String'>
    readonly year: FieldRef<"SalaryByYear", 'Int'>
    readonly amount: FieldRef<"SalaryByYear", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalaryByYear findUnique
   */
  export type SalaryByYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * Filter, which SalaryByYear to fetch.
     */
    where: SalaryByYearWhereUniqueInput
  }

  /**
   * SalaryByYear findUniqueOrThrow
   */
  export type SalaryByYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * Filter, which SalaryByYear to fetch.
     */
    where: SalaryByYearWhereUniqueInput
  }

  /**
   * SalaryByYear findFirst
   */
  export type SalaryByYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * Filter, which SalaryByYear to fetch.
     */
    where?: SalaryByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryByYears to fetch.
     */
    orderBy?: SalaryByYearOrderByWithRelationInput | SalaryByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryByYears.
     */
    cursor?: SalaryByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryByYears.
     */
    distinct?: SalaryByYearScalarFieldEnum | SalaryByYearScalarFieldEnum[]
  }

  /**
   * SalaryByYear findFirstOrThrow
   */
  export type SalaryByYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * Filter, which SalaryByYear to fetch.
     */
    where?: SalaryByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryByYears to fetch.
     */
    orderBy?: SalaryByYearOrderByWithRelationInput | SalaryByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryByYears.
     */
    cursor?: SalaryByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryByYears.
     */
    distinct?: SalaryByYearScalarFieldEnum | SalaryByYearScalarFieldEnum[]
  }

  /**
   * SalaryByYear findMany
   */
  export type SalaryByYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * Filter, which SalaryByYears to fetch.
     */
    where?: SalaryByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryByYears to fetch.
     */
    orderBy?: SalaryByYearOrderByWithRelationInput | SalaryByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryByYears.
     */
    cursor?: SalaryByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryByYears.
     */
    skip?: number
    distinct?: SalaryByYearScalarFieldEnum | SalaryByYearScalarFieldEnum[]
  }

  /**
   * SalaryByYear create
   */
  export type SalaryByYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryByYear.
     */
    data: XOR<SalaryByYearCreateInput, SalaryByYearUncheckedCreateInput>
  }

  /**
   * SalaryByYear createMany
   */
  export type SalaryByYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryByYears.
     */
    data: SalaryByYearCreateManyInput | SalaryByYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryByYear createManyAndReturn
   */
  export type SalaryByYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryByYears.
     */
    data: SalaryByYearCreateManyInput | SalaryByYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryByYear update
   */
  export type SalaryByYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryByYear.
     */
    data: XOR<SalaryByYearUpdateInput, SalaryByYearUncheckedUpdateInput>
    /**
     * Choose, which SalaryByYear to update.
     */
    where: SalaryByYearWhereUniqueInput
  }

  /**
   * SalaryByYear updateMany
   */
  export type SalaryByYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryByYears.
     */
    data: XOR<SalaryByYearUpdateManyMutationInput, SalaryByYearUncheckedUpdateManyInput>
    /**
     * Filter which SalaryByYears to update
     */
    where?: SalaryByYearWhereInput
    /**
     * Limit how many SalaryByYears to update.
     */
    limit?: number
  }

  /**
   * SalaryByYear updateManyAndReturn
   */
  export type SalaryByYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * The data used to update SalaryByYears.
     */
    data: XOR<SalaryByYearUpdateManyMutationInput, SalaryByYearUncheckedUpdateManyInput>
    /**
     * Filter which SalaryByYears to update
     */
    where?: SalaryByYearWhereInput
    /**
     * Limit how many SalaryByYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryByYear upsert
   */
  export type SalaryByYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryByYear to update in case it exists.
     */
    where: SalaryByYearWhereUniqueInput
    /**
     * In case the SalaryByYear found by the `where` argument doesn't exist, create a new SalaryByYear with this data.
     */
    create: XOR<SalaryByYearCreateInput, SalaryByYearUncheckedCreateInput>
    /**
     * In case the SalaryByYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryByYearUpdateInput, SalaryByYearUncheckedUpdateInput>
  }

  /**
   * SalaryByYear delete
   */
  export type SalaryByYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
    /**
     * Filter which SalaryByYear to delete.
     */
    where: SalaryByYearWhereUniqueInput
  }

  /**
   * SalaryByYear deleteMany
   */
  export type SalaryByYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryByYears to delete
     */
    where?: SalaryByYearWhereInput
    /**
     * Limit how many SalaryByYears to delete.
     */
    limit?: number
  }

  /**
   * SalaryByYear without action
   */
  export type SalaryByYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryByYear
     */
    select?: SalaryByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryByYear
     */
    omit?: SalaryByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryByYearInclude<ExtArgs> | null
  }


  /**
   * Model CapHitByYear
   */

  export type AggregateCapHitByYear = {
    _count: CapHitByYearCountAggregateOutputType | null
    _avg: CapHitByYearAvgAggregateOutputType | null
    _sum: CapHitByYearSumAggregateOutputType | null
    _min: CapHitByYearMinAggregateOutputType | null
    _max: CapHitByYearMaxAggregateOutputType | null
  }

  export type CapHitByYearAvgAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type CapHitByYearSumAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type CapHitByYearMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    amount: number | null
  }

  export type CapHitByYearMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    amount: number | null
  }

  export type CapHitByYearCountAggregateOutputType = {
    id: number
    contractId: number
    year: number
    amount: number
    _all: number
  }


  export type CapHitByYearAvgAggregateInputType = {
    year?: true
    amount?: true
  }

  export type CapHitByYearSumAggregateInputType = {
    year?: true
    amount?: true
  }

  export type CapHitByYearMinAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
  }

  export type CapHitByYearMaxAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
  }

  export type CapHitByYearCountAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
    _all?: true
  }

  export type CapHitByYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapHitByYear to aggregate.
     */
    where?: CapHitByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapHitByYears to fetch.
     */
    orderBy?: CapHitByYearOrderByWithRelationInput | CapHitByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapHitByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapHitByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapHitByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapHitByYears
    **/
    _count?: true | CapHitByYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapHitByYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapHitByYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapHitByYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapHitByYearMaxAggregateInputType
  }

  export type GetCapHitByYearAggregateType<T extends CapHitByYearAggregateArgs> = {
        [P in keyof T & keyof AggregateCapHitByYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapHitByYear[P]>
      : GetScalarType<T[P], AggregateCapHitByYear[P]>
  }




  export type CapHitByYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapHitByYearWhereInput
    orderBy?: CapHitByYearOrderByWithAggregationInput | CapHitByYearOrderByWithAggregationInput[]
    by: CapHitByYearScalarFieldEnum[] | CapHitByYearScalarFieldEnum
    having?: CapHitByYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapHitByYearCountAggregateInputType | true
    _avg?: CapHitByYearAvgAggregateInputType
    _sum?: CapHitByYearSumAggregateInputType
    _min?: CapHitByYearMinAggregateInputType
    _max?: CapHitByYearMaxAggregateInputType
  }

  export type CapHitByYearGroupByOutputType = {
    id: string
    contractId: string
    year: number
    amount: number
    _count: CapHitByYearCountAggregateOutputType | null
    _avg: CapHitByYearAvgAggregateOutputType | null
    _sum: CapHitByYearSumAggregateOutputType | null
    _min: CapHitByYearMinAggregateOutputType | null
    _max: CapHitByYearMaxAggregateOutputType | null
  }

  type GetCapHitByYearGroupByPayload<T extends CapHitByYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapHitByYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapHitByYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapHitByYearGroupByOutputType[P]>
            : GetScalarType<T[P], CapHitByYearGroupByOutputType[P]>
        }
      >
    >


  export type CapHitByYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capHitByYear"]>

  export type CapHitByYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capHitByYear"]>

  export type CapHitByYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capHitByYear"]>

  export type CapHitByYearSelectScalar = {
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
  }

  export type CapHitByYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "year" | "amount", ExtArgs["result"]["capHitByYear"]>
  export type CapHitByYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type CapHitByYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type CapHitByYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $CapHitByYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapHitByYear"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      year: number
      amount: number
    }, ExtArgs["result"]["capHitByYear"]>
    composites: {}
  }

  type CapHitByYearGetPayload<S extends boolean | null | undefined | CapHitByYearDefaultArgs> = $Result.GetResult<Prisma.$CapHitByYearPayload, S>

  type CapHitByYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapHitByYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapHitByYearCountAggregateInputType | true
    }

  export interface CapHitByYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapHitByYear'], meta: { name: 'CapHitByYear' } }
    /**
     * Find zero or one CapHitByYear that matches the filter.
     * @param {CapHitByYearFindUniqueArgs} args - Arguments to find a CapHitByYear
     * @example
     * // Get one CapHitByYear
     * const capHitByYear = await prisma.capHitByYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapHitByYearFindUniqueArgs>(args: SelectSubset<T, CapHitByYearFindUniqueArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CapHitByYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapHitByYearFindUniqueOrThrowArgs} args - Arguments to find a CapHitByYear
     * @example
     * // Get one CapHitByYear
     * const capHitByYear = await prisma.capHitByYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapHitByYearFindUniqueOrThrowArgs>(args: SelectSubset<T, CapHitByYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapHitByYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearFindFirstArgs} args - Arguments to find a CapHitByYear
     * @example
     * // Get one CapHitByYear
     * const capHitByYear = await prisma.capHitByYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapHitByYearFindFirstArgs>(args?: SelectSubset<T, CapHitByYearFindFirstArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapHitByYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearFindFirstOrThrowArgs} args - Arguments to find a CapHitByYear
     * @example
     * // Get one CapHitByYear
     * const capHitByYear = await prisma.capHitByYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapHitByYearFindFirstOrThrowArgs>(args?: SelectSubset<T, CapHitByYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapHitByYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapHitByYears
     * const capHitByYears = await prisma.capHitByYear.findMany()
     * 
     * // Get first 10 CapHitByYears
     * const capHitByYears = await prisma.capHitByYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capHitByYearWithIdOnly = await prisma.capHitByYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapHitByYearFindManyArgs>(args?: SelectSubset<T, CapHitByYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CapHitByYear.
     * @param {CapHitByYearCreateArgs} args - Arguments to create a CapHitByYear.
     * @example
     * // Create one CapHitByYear
     * const CapHitByYear = await prisma.capHitByYear.create({
     *   data: {
     *     // ... data to create a CapHitByYear
     *   }
     * })
     * 
     */
    create<T extends CapHitByYearCreateArgs>(args: SelectSubset<T, CapHitByYearCreateArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CapHitByYears.
     * @param {CapHitByYearCreateManyArgs} args - Arguments to create many CapHitByYears.
     * @example
     * // Create many CapHitByYears
     * const capHitByYear = await prisma.capHitByYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapHitByYearCreateManyArgs>(args?: SelectSubset<T, CapHitByYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CapHitByYears and returns the data saved in the database.
     * @param {CapHitByYearCreateManyAndReturnArgs} args - Arguments to create many CapHitByYears.
     * @example
     * // Create many CapHitByYears
     * const capHitByYear = await prisma.capHitByYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CapHitByYears and only return the `id`
     * const capHitByYearWithIdOnly = await prisma.capHitByYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapHitByYearCreateManyAndReturnArgs>(args?: SelectSubset<T, CapHitByYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CapHitByYear.
     * @param {CapHitByYearDeleteArgs} args - Arguments to delete one CapHitByYear.
     * @example
     * // Delete one CapHitByYear
     * const CapHitByYear = await prisma.capHitByYear.delete({
     *   where: {
     *     // ... filter to delete one CapHitByYear
     *   }
     * })
     * 
     */
    delete<T extends CapHitByYearDeleteArgs>(args: SelectSubset<T, CapHitByYearDeleteArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CapHitByYear.
     * @param {CapHitByYearUpdateArgs} args - Arguments to update one CapHitByYear.
     * @example
     * // Update one CapHitByYear
     * const capHitByYear = await prisma.capHitByYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapHitByYearUpdateArgs>(args: SelectSubset<T, CapHitByYearUpdateArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CapHitByYears.
     * @param {CapHitByYearDeleteManyArgs} args - Arguments to filter CapHitByYears to delete.
     * @example
     * // Delete a few CapHitByYears
     * const { count } = await prisma.capHitByYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapHitByYearDeleteManyArgs>(args?: SelectSubset<T, CapHitByYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapHitByYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapHitByYears
     * const capHitByYear = await prisma.capHitByYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapHitByYearUpdateManyArgs>(args: SelectSubset<T, CapHitByYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapHitByYears and returns the data updated in the database.
     * @param {CapHitByYearUpdateManyAndReturnArgs} args - Arguments to update many CapHitByYears.
     * @example
     * // Update many CapHitByYears
     * const capHitByYear = await prisma.capHitByYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CapHitByYears and only return the `id`
     * const capHitByYearWithIdOnly = await prisma.capHitByYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CapHitByYearUpdateManyAndReturnArgs>(args: SelectSubset<T, CapHitByYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CapHitByYear.
     * @param {CapHitByYearUpsertArgs} args - Arguments to update or create a CapHitByYear.
     * @example
     * // Update or create a CapHitByYear
     * const capHitByYear = await prisma.capHitByYear.upsert({
     *   create: {
     *     // ... data to create a CapHitByYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapHitByYear we want to update
     *   }
     * })
     */
    upsert<T extends CapHitByYearUpsertArgs>(args: SelectSubset<T, CapHitByYearUpsertArgs<ExtArgs>>): Prisma__CapHitByYearClient<$Result.GetResult<Prisma.$CapHitByYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CapHitByYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearCountArgs} args - Arguments to filter CapHitByYears to count.
     * @example
     * // Count the number of CapHitByYears
     * const count = await prisma.capHitByYear.count({
     *   where: {
     *     // ... the filter for the CapHitByYears we want to count
     *   }
     * })
    **/
    count<T extends CapHitByYearCountArgs>(
      args?: Subset<T, CapHitByYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapHitByYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapHitByYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapHitByYearAggregateArgs>(args: Subset<T, CapHitByYearAggregateArgs>): Prisma.PrismaPromise<GetCapHitByYearAggregateType<T>>

    /**
     * Group by CapHitByYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapHitByYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapHitByYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapHitByYearGroupByArgs['orderBy'] }
        : { orderBy?: CapHitByYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapHitByYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapHitByYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapHitByYear model
   */
  readonly fields: CapHitByYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapHitByYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapHitByYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapHitByYear model
   */
  interface CapHitByYearFieldRefs {
    readonly id: FieldRef<"CapHitByYear", 'String'>
    readonly contractId: FieldRef<"CapHitByYear", 'String'>
    readonly year: FieldRef<"CapHitByYear", 'Int'>
    readonly amount: FieldRef<"CapHitByYear", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CapHitByYear findUnique
   */
  export type CapHitByYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * Filter, which CapHitByYear to fetch.
     */
    where: CapHitByYearWhereUniqueInput
  }

  /**
   * CapHitByYear findUniqueOrThrow
   */
  export type CapHitByYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * Filter, which CapHitByYear to fetch.
     */
    where: CapHitByYearWhereUniqueInput
  }

  /**
   * CapHitByYear findFirst
   */
  export type CapHitByYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * Filter, which CapHitByYear to fetch.
     */
    where?: CapHitByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapHitByYears to fetch.
     */
    orderBy?: CapHitByYearOrderByWithRelationInput | CapHitByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapHitByYears.
     */
    cursor?: CapHitByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapHitByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapHitByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapHitByYears.
     */
    distinct?: CapHitByYearScalarFieldEnum | CapHitByYearScalarFieldEnum[]
  }

  /**
   * CapHitByYear findFirstOrThrow
   */
  export type CapHitByYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * Filter, which CapHitByYear to fetch.
     */
    where?: CapHitByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapHitByYears to fetch.
     */
    orderBy?: CapHitByYearOrderByWithRelationInput | CapHitByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapHitByYears.
     */
    cursor?: CapHitByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapHitByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapHitByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapHitByYears.
     */
    distinct?: CapHitByYearScalarFieldEnum | CapHitByYearScalarFieldEnum[]
  }

  /**
   * CapHitByYear findMany
   */
  export type CapHitByYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * Filter, which CapHitByYears to fetch.
     */
    where?: CapHitByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapHitByYears to fetch.
     */
    orderBy?: CapHitByYearOrderByWithRelationInput | CapHitByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapHitByYears.
     */
    cursor?: CapHitByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapHitByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapHitByYears.
     */
    skip?: number
    distinct?: CapHitByYearScalarFieldEnum | CapHitByYearScalarFieldEnum[]
  }

  /**
   * CapHitByYear create
   */
  export type CapHitByYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * The data needed to create a CapHitByYear.
     */
    data: XOR<CapHitByYearCreateInput, CapHitByYearUncheckedCreateInput>
  }

  /**
   * CapHitByYear createMany
   */
  export type CapHitByYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapHitByYears.
     */
    data: CapHitByYearCreateManyInput | CapHitByYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapHitByYear createManyAndReturn
   */
  export type CapHitByYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * The data used to create many CapHitByYears.
     */
    data: CapHitByYearCreateManyInput | CapHitByYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapHitByYear update
   */
  export type CapHitByYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * The data needed to update a CapHitByYear.
     */
    data: XOR<CapHitByYearUpdateInput, CapHitByYearUncheckedUpdateInput>
    /**
     * Choose, which CapHitByYear to update.
     */
    where: CapHitByYearWhereUniqueInput
  }

  /**
   * CapHitByYear updateMany
   */
  export type CapHitByYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapHitByYears.
     */
    data: XOR<CapHitByYearUpdateManyMutationInput, CapHitByYearUncheckedUpdateManyInput>
    /**
     * Filter which CapHitByYears to update
     */
    where?: CapHitByYearWhereInput
    /**
     * Limit how many CapHitByYears to update.
     */
    limit?: number
  }

  /**
   * CapHitByYear updateManyAndReturn
   */
  export type CapHitByYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * The data used to update CapHitByYears.
     */
    data: XOR<CapHitByYearUpdateManyMutationInput, CapHitByYearUncheckedUpdateManyInput>
    /**
     * Filter which CapHitByYears to update
     */
    where?: CapHitByYearWhereInput
    /**
     * Limit how many CapHitByYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapHitByYear upsert
   */
  export type CapHitByYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * The filter to search for the CapHitByYear to update in case it exists.
     */
    where: CapHitByYearWhereUniqueInput
    /**
     * In case the CapHitByYear found by the `where` argument doesn't exist, create a new CapHitByYear with this data.
     */
    create: XOR<CapHitByYearCreateInput, CapHitByYearUncheckedCreateInput>
    /**
     * In case the CapHitByYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapHitByYearUpdateInput, CapHitByYearUncheckedUpdateInput>
  }

  /**
   * CapHitByYear delete
   */
  export type CapHitByYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
    /**
     * Filter which CapHitByYear to delete.
     */
    where: CapHitByYearWhereUniqueInput
  }

  /**
   * CapHitByYear deleteMany
   */
  export type CapHitByYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapHitByYears to delete
     */
    where?: CapHitByYearWhereInput
    /**
     * Limit how many CapHitByYears to delete.
     */
    limit?: number
  }

  /**
   * CapHitByYear without action
   */
  export type CapHitByYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapHitByYear
     */
    select?: CapHitByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapHitByYear
     */
    omit?: CapHitByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapHitByYearInclude<ExtArgs> | null
  }


  /**
   * Model DeadCapByYear
   */

  export type AggregateDeadCapByYear = {
    _count: DeadCapByYearCountAggregateOutputType | null
    _avg: DeadCapByYearAvgAggregateOutputType | null
    _sum: DeadCapByYearSumAggregateOutputType | null
    _min: DeadCapByYearMinAggregateOutputType | null
    _max: DeadCapByYearMaxAggregateOutputType | null
  }

  export type DeadCapByYearAvgAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type DeadCapByYearSumAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type DeadCapByYearMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    amount: number | null
  }

  export type DeadCapByYearMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    amount: number | null
  }

  export type DeadCapByYearCountAggregateOutputType = {
    id: number
    contractId: number
    year: number
    amount: number
    _all: number
  }


  export type DeadCapByYearAvgAggregateInputType = {
    year?: true
    amount?: true
  }

  export type DeadCapByYearSumAggregateInputType = {
    year?: true
    amount?: true
  }

  export type DeadCapByYearMinAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
  }

  export type DeadCapByYearMaxAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
  }

  export type DeadCapByYearCountAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    amount?: true
    _all?: true
  }

  export type DeadCapByYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeadCapByYear to aggregate.
     */
    where?: DeadCapByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeadCapByYears to fetch.
     */
    orderBy?: DeadCapByYearOrderByWithRelationInput | DeadCapByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeadCapByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeadCapByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeadCapByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeadCapByYears
    **/
    _count?: true | DeadCapByYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeadCapByYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeadCapByYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeadCapByYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeadCapByYearMaxAggregateInputType
  }

  export type GetDeadCapByYearAggregateType<T extends DeadCapByYearAggregateArgs> = {
        [P in keyof T & keyof AggregateDeadCapByYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeadCapByYear[P]>
      : GetScalarType<T[P], AggregateDeadCapByYear[P]>
  }




  export type DeadCapByYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeadCapByYearWhereInput
    orderBy?: DeadCapByYearOrderByWithAggregationInput | DeadCapByYearOrderByWithAggregationInput[]
    by: DeadCapByYearScalarFieldEnum[] | DeadCapByYearScalarFieldEnum
    having?: DeadCapByYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeadCapByYearCountAggregateInputType | true
    _avg?: DeadCapByYearAvgAggregateInputType
    _sum?: DeadCapByYearSumAggregateInputType
    _min?: DeadCapByYearMinAggregateInputType
    _max?: DeadCapByYearMaxAggregateInputType
  }

  export type DeadCapByYearGroupByOutputType = {
    id: string
    contractId: string
    year: number
    amount: number
    _count: DeadCapByYearCountAggregateOutputType | null
    _avg: DeadCapByYearAvgAggregateOutputType | null
    _sum: DeadCapByYearSumAggregateOutputType | null
    _min: DeadCapByYearMinAggregateOutputType | null
    _max: DeadCapByYearMaxAggregateOutputType | null
  }

  type GetDeadCapByYearGroupByPayload<T extends DeadCapByYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeadCapByYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeadCapByYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeadCapByYearGroupByOutputType[P]>
            : GetScalarType<T[P], DeadCapByYearGroupByOutputType[P]>
        }
      >
    >


  export type DeadCapByYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deadCapByYear"]>

  export type DeadCapByYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deadCapByYear"]>

  export type DeadCapByYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deadCapByYear"]>

  export type DeadCapByYearSelectScalar = {
    id?: boolean
    contractId?: boolean
    year?: boolean
    amount?: boolean
  }

  export type DeadCapByYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "year" | "amount", ExtArgs["result"]["deadCapByYear"]>
  export type DeadCapByYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type DeadCapByYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type DeadCapByYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $DeadCapByYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeadCapByYear"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      year: number
      amount: number
    }, ExtArgs["result"]["deadCapByYear"]>
    composites: {}
  }

  type DeadCapByYearGetPayload<S extends boolean | null | undefined | DeadCapByYearDefaultArgs> = $Result.GetResult<Prisma.$DeadCapByYearPayload, S>

  type DeadCapByYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeadCapByYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeadCapByYearCountAggregateInputType | true
    }

  export interface DeadCapByYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeadCapByYear'], meta: { name: 'DeadCapByYear' } }
    /**
     * Find zero or one DeadCapByYear that matches the filter.
     * @param {DeadCapByYearFindUniqueArgs} args - Arguments to find a DeadCapByYear
     * @example
     * // Get one DeadCapByYear
     * const deadCapByYear = await prisma.deadCapByYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeadCapByYearFindUniqueArgs>(args: SelectSubset<T, DeadCapByYearFindUniqueArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeadCapByYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeadCapByYearFindUniqueOrThrowArgs} args - Arguments to find a DeadCapByYear
     * @example
     * // Get one DeadCapByYear
     * const deadCapByYear = await prisma.deadCapByYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeadCapByYearFindUniqueOrThrowArgs>(args: SelectSubset<T, DeadCapByYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeadCapByYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearFindFirstArgs} args - Arguments to find a DeadCapByYear
     * @example
     * // Get one DeadCapByYear
     * const deadCapByYear = await prisma.deadCapByYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeadCapByYearFindFirstArgs>(args?: SelectSubset<T, DeadCapByYearFindFirstArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeadCapByYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearFindFirstOrThrowArgs} args - Arguments to find a DeadCapByYear
     * @example
     * // Get one DeadCapByYear
     * const deadCapByYear = await prisma.deadCapByYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeadCapByYearFindFirstOrThrowArgs>(args?: SelectSubset<T, DeadCapByYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeadCapByYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeadCapByYears
     * const deadCapByYears = await prisma.deadCapByYear.findMany()
     * 
     * // Get first 10 DeadCapByYears
     * const deadCapByYears = await prisma.deadCapByYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deadCapByYearWithIdOnly = await prisma.deadCapByYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeadCapByYearFindManyArgs>(args?: SelectSubset<T, DeadCapByYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeadCapByYear.
     * @param {DeadCapByYearCreateArgs} args - Arguments to create a DeadCapByYear.
     * @example
     * // Create one DeadCapByYear
     * const DeadCapByYear = await prisma.deadCapByYear.create({
     *   data: {
     *     // ... data to create a DeadCapByYear
     *   }
     * })
     * 
     */
    create<T extends DeadCapByYearCreateArgs>(args: SelectSubset<T, DeadCapByYearCreateArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeadCapByYears.
     * @param {DeadCapByYearCreateManyArgs} args - Arguments to create many DeadCapByYears.
     * @example
     * // Create many DeadCapByYears
     * const deadCapByYear = await prisma.deadCapByYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeadCapByYearCreateManyArgs>(args?: SelectSubset<T, DeadCapByYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeadCapByYears and returns the data saved in the database.
     * @param {DeadCapByYearCreateManyAndReturnArgs} args - Arguments to create many DeadCapByYears.
     * @example
     * // Create many DeadCapByYears
     * const deadCapByYear = await prisma.deadCapByYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeadCapByYears and only return the `id`
     * const deadCapByYearWithIdOnly = await prisma.deadCapByYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeadCapByYearCreateManyAndReturnArgs>(args?: SelectSubset<T, DeadCapByYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeadCapByYear.
     * @param {DeadCapByYearDeleteArgs} args - Arguments to delete one DeadCapByYear.
     * @example
     * // Delete one DeadCapByYear
     * const DeadCapByYear = await prisma.deadCapByYear.delete({
     *   where: {
     *     // ... filter to delete one DeadCapByYear
     *   }
     * })
     * 
     */
    delete<T extends DeadCapByYearDeleteArgs>(args: SelectSubset<T, DeadCapByYearDeleteArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeadCapByYear.
     * @param {DeadCapByYearUpdateArgs} args - Arguments to update one DeadCapByYear.
     * @example
     * // Update one DeadCapByYear
     * const deadCapByYear = await prisma.deadCapByYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeadCapByYearUpdateArgs>(args: SelectSubset<T, DeadCapByYearUpdateArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeadCapByYears.
     * @param {DeadCapByYearDeleteManyArgs} args - Arguments to filter DeadCapByYears to delete.
     * @example
     * // Delete a few DeadCapByYears
     * const { count } = await prisma.deadCapByYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeadCapByYearDeleteManyArgs>(args?: SelectSubset<T, DeadCapByYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeadCapByYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeadCapByYears
     * const deadCapByYear = await prisma.deadCapByYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeadCapByYearUpdateManyArgs>(args: SelectSubset<T, DeadCapByYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeadCapByYears and returns the data updated in the database.
     * @param {DeadCapByYearUpdateManyAndReturnArgs} args - Arguments to update many DeadCapByYears.
     * @example
     * // Update many DeadCapByYears
     * const deadCapByYear = await prisma.deadCapByYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeadCapByYears and only return the `id`
     * const deadCapByYearWithIdOnly = await prisma.deadCapByYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeadCapByYearUpdateManyAndReturnArgs>(args: SelectSubset<T, DeadCapByYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeadCapByYear.
     * @param {DeadCapByYearUpsertArgs} args - Arguments to update or create a DeadCapByYear.
     * @example
     * // Update or create a DeadCapByYear
     * const deadCapByYear = await prisma.deadCapByYear.upsert({
     *   create: {
     *     // ... data to create a DeadCapByYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeadCapByYear we want to update
     *   }
     * })
     */
    upsert<T extends DeadCapByYearUpsertArgs>(args: SelectSubset<T, DeadCapByYearUpsertArgs<ExtArgs>>): Prisma__DeadCapByYearClient<$Result.GetResult<Prisma.$DeadCapByYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeadCapByYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearCountArgs} args - Arguments to filter DeadCapByYears to count.
     * @example
     * // Count the number of DeadCapByYears
     * const count = await prisma.deadCapByYear.count({
     *   where: {
     *     // ... the filter for the DeadCapByYears we want to count
     *   }
     * })
    **/
    count<T extends DeadCapByYearCountArgs>(
      args?: Subset<T, DeadCapByYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeadCapByYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeadCapByYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeadCapByYearAggregateArgs>(args: Subset<T, DeadCapByYearAggregateArgs>): Prisma.PrismaPromise<GetDeadCapByYearAggregateType<T>>

    /**
     * Group by DeadCapByYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeadCapByYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeadCapByYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeadCapByYearGroupByArgs['orderBy'] }
        : { orderBy?: DeadCapByYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeadCapByYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeadCapByYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeadCapByYear model
   */
  readonly fields: DeadCapByYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeadCapByYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeadCapByYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeadCapByYear model
   */
  interface DeadCapByYearFieldRefs {
    readonly id: FieldRef<"DeadCapByYear", 'String'>
    readonly contractId: FieldRef<"DeadCapByYear", 'String'>
    readonly year: FieldRef<"DeadCapByYear", 'Int'>
    readonly amount: FieldRef<"DeadCapByYear", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeadCapByYear findUnique
   */
  export type DeadCapByYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * Filter, which DeadCapByYear to fetch.
     */
    where: DeadCapByYearWhereUniqueInput
  }

  /**
   * DeadCapByYear findUniqueOrThrow
   */
  export type DeadCapByYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * Filter, which DeadCapByYear to fetch.
     */
    where: DeadCapByYearWhereUniqueInput
  }

  /**
   * DeadCapByYear findFirst
   */
  export type DeadCapByYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * Filter, which DeadCapByYear to fetch.
     */
    where?: DeadCapByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeadCapByYears to fetch.
     */
    orderBy?: DeadCapByYearOrderByWithRelationInput | DeadCapByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeadCapByYears.
     */
    cursor?: DeadCapByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeadCapByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeadCapByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeadCapByYears.
     */
    distinct?: DeadCapByYearScalarFieldEnum | DeadCapByYearScalarFieldEnum[]
  }

  /**
   * DeadCapByYear findFirstOrThrow
   */
  export type DeadCapByYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * Filter, which DeadCapByYear to fetch.
     */
    where?: DeadCapByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeadCapByYears to fetch.
     */
    orderBy?: DeadCapByYearOrderByWithRelationInput | DeadCapByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeadCapByYears.
     */
    cursor?: DeadCapByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeadCapByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeadCapByYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeadCapByYears.
     */
    distinct?: DeadCapByYearScalarFieldEnum | DeadCapByYearScalarFieldEnum[]
  }

  /**
   * DeadCapByYear findMany
   */
  export type DeadCapByYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * Filter, which DeadCapByYears to fetch.
     */
    where?: DeadCapByYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeadCapByYears to fetch.
     */
    orderBy?: DeadCapByYearOrderByWithRelationInput | DeadCapByYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeadCapByYears.
     */
    cursor?: DeadCapByYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeadCapByYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeadCapByYears.
     */
    skip?: number
    distinct?: DeadCapByYearScalarFieldEnum | DeadCapByYearScalarFieldEnum[]
  }

  /**
   * DeadCapByYear create
   */
  export type DeadCapByYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * The data needed to create a DeadCapByYear.
     */
    data: XOR<DeadCapByYearCreateInput, DeadCapByYearUncheckedCreateInput>
  }

  /**
   * DeadCapByYear createMany
   */
  export type DeadCapByYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeadCapByYears.
     */
    data: DeadCapByYearCreateManyInput | DeadCapByYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeadCapByYear createManyAndReturn
   */
  export type DeadCapByYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * The data used to create many DeadCapByYears.
     */
    data: DeadCapByYearCreateManyInput | DeadCapByYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeadCapByYear update
   */
  export type DeadCapByYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * The data needed to update a DeadCapByYear.
     */
    data: XOR<DeadCapByYearUpdateInput, DeadCapByYearUncheckedUpdateInput>
    /**
     * Choose, which DeadCapByYear to update.
     */
    where: DeadCapByYearWhereUniqueInput
  }

  /**
   * DeadCapByYear updateMany
   */
  export type DeadCapByYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeadCapByYears.
     */
    data: XOR<DeadCapByYearUpdateManyMutationInput, DeadCapByYearUncheckedUpdateManyInput>
    /**
     * Filter which DeadCapByYears to update
     */
    where?: DeadCapByYearWhereInput
    /**
     * Limit how many DeadCapByYears to update.
     */
    limit?: number
  }

  /**
   * DeadCapByYear updateManyAndReturn
   */
  export type DeadCapByYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * The data used to update DeadCapByYears.
     */
    data: XOR<DeadCapByYearUpdateManyMutationInput, DeadCapByYearUncheckedUpdateManyInput>
    /**
     * Filter which DeadCapByYears to update
     */
    where?: DeadCapByYearWhereInput
    /**
     * Limit how many DeadCapByYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeadCapByYear upsert
   */
  export type DeadCapByYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * The filter to search for the DeadCapByYear to update in case it exists.
     */
    where: DeadCapByYearWhereUniqueInput
    /**
     * In case the DeadCapByYear found by the `where` argument doesn't exist, create a new DeadCapByYear with this data.
     */
    create: XOR<DeadCapByYearCreateInput, DeadCapByYearUncheckedCreateInput>
    /**
     * In case the DeadCapByYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeadCapByYearUpdateInput, DeadCapByYearUncheckedUpdateInput>
  }

  /**
   * DeadCapByYear delete
   */
  export type DeadCapByYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
    /**
     * Filter which DeadCapByYear to delete.
     */
    where: DeadCapByYearWhereUniqueInput
  }

  /**
   * DeadCapByYear deleteMany
   */
  export type DeadCapByYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeadCapByYears to delete
     */
    where?: DeadCapByYearWhereInput
    /**
     * Limit how many DeadCapByYears to delete.
     */
    limit?: number
  }

  /**
   * DeadCapByYear without action
   */
  export type DeadCapByYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeadCapByYear
     */
    select?: DeadCapByYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeadCapByYear
     */
    omit?: DeadCapByYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeadCapByYearInclude<ExtArgs> | null
  }


  /**
   * Model OptOutYear
   */

  export type AggregateOptOutYear = {
    _count: OptOutYearCountAggregateOutputType | null
    _avg: OptOutYearAvgAggregateOutputType | null
    _sum: OptOutYearSumAggregateOutputType | null
    _min: OptOutYearMinAggregateOutputType | null
    _max: OptOutYearMaxAggregateOutputType | null
  }

  export type OptOutYearAvgAggregateOutputType = {
    year: number | null
  }

  export type OptOutYearSumAggregateOutputType = {
    year: number | null
  }

  export type OptOutYearMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
  }

  export type OptOutYearMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
  }

  export type OptOutYearCountAggregateOutputType = {
    id: number
    contractId: number
    year: number
    _all: number
  }


  export type OptOutYearAvgAggregateInputType = {
    year?: true
  }

  export type OptOutYearSumAggregateInputType = {
    year?: true
  }

  export type OptOutYearMinAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
  }

  export type OptOutYearMaxAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
  }

  export type OptOutYearCountAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    _all?: true
  }

  export type OptOutYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptOutYear to aggregate.
     */
    where?: OptOutYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptOutYears to fetch.
     */
    orderBy?: OptOutYearOrderByWithRelationInput | OptOutYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptOutYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptOutYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptOutYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptOutYears
    **/
    _count?: true | OptOutYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptOutYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptOutYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptOutYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptOutYearMaxAggregateInputType
  }

  export type GetOptOutYearAggregateType<T extends OptOutYearAggregateArgs> = {
        [P in keyof T & keyof AggregateOptOutYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptOutYear[P]>
      : GetScalarType<T[P], AggregateOptOutYear[P]>
  }




  export type OptOutYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptOutYearWhereInput
    orderBy?: OptOutYearOrderByWithAggregationInput | OptOutYearOrderByWithAggregationInput[]
    by: OptOutYearScalarFieldEnum[] | OptOutYearScalarFieldEnum
    having?: OptOutYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptOutYearCountAggregateInputType | true
    _avg?: OptOutYearAvgAggregateInputType
    _sum?: OptOutYearSumAggregateInputType
    _min?: OptOutYearMinAggregateInputType
    _max?: OptOutYearMaxAggregateInputType
  }

  export type OptOutYearGroupByOutputType = {
    id: string
    contractId: string
    year: number
    _count: OptOutYearCountAggregateOutputType | null
    _avg: OptOutYearAvgAggregateOutputType | null
    _sum: OptOutYearSumAggregateOutputType | null
    _min: OptOutYearMinAggregateOutputType | null
    _max: OptOutYearMaxAggregateOutputType | null
  }

  type GetOptOutYearGroupByPayload<T extends OptOutYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptOutYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptOutYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptOutYearGroupByOutputType[P]>
            : GetScalarType<T[P], OptOutYearGroupByOutputType[P]>
        }
      >
    >


  export type OptOutYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optOutYear"]>

  export type OptOutYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optOutYear"]>

  export type OptOutYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optOutYear"]>

  export type OptOutYearSelectScalar = {
    id?: boolean
    contractId?: boolean
    year?: boolean
  }

  export type OptOutYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "year", ExtArgs["result"]["optOutYear"]>
  export type OptOutYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type OptOutYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type OptOutYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $OptOutYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptOutYear"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      year: number
    }, ExtArgs["result"]["optOutYear"]>
    composites: {}
  }

  type OptOutYearGetPayload<S extends boolean | null | undefined | OptOutYearDefaultArgs> = $Result.GetResult<Prisma.$OptOutYearPayload, S>

  type OptOutYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptOutYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptOutYearCountAggregateInputType | true
    }

  export interface OptOutYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptOutYear'], meta: { name: 'OptOutYear' } }
    /**
     * Find zero or one OptOutYear that matches the filter.
     * @param {OptOutYearFindUniqueArgs} args - Arguments to find a OptOutYear
     * @example
     * // Get one OptOutYear
     * const optOutYear = await prisma.optOutYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptOutYearFindUniqueArgs>(args: SelectSubset<T, OptOutYearFindUniqueArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OptOutYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptOutYearFindUniqueOrThrowArgs} args - Arguments to find a OptOutYear
     * @example
     * // Get one OptOutYear
     * const optOutYear = await prisma.optOutYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptOutYearFindUniqueOrThrowArgs>(args: SelectSubset<T, OptOutYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptOutYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearFindFirstArgs} args - Arguments to find a OptOutYear
     * @example
     * // Get one OptOutYear
     * const optOutYear = await prisma.optOutYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptOutYearFindFirstArgs>(args?: SelectSubset<T, OptOutYearFindFirstArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptOutYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearFindFirstOrThrowArgs} args - Arguments to find a OptOutYear
     * @example
     * // Get one OptOutYear
     * const optOutYear = await prisma.optOutYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptOutYearFindFirstOrThrowArgs>(args?: SelectSubset<T, OptOutYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OptOutYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptOutYears
     * const optOutYears = await prisma.optOutYear.findMany()
     * 
     * // Get first 10 OptOutYears
     * const optOutYears = await prisma.optOutYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optOutYearWithIdOnly = await prisma.optOutYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptOutYearFindManyArgs>(args?: SelectSubset<T, OptOutYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OptOutYear.
     * @param {OptOutYearCreateArgs} args - Arguments to create a OptOutYear.
     * @example
     * // Create one OptOutYear
     * const OptOutYear = await prisma.optOutYear.create({
     *   data: {
     *     // ... data to create a OptOutYear
     *   }
     * })
     * 
     */
    create<T extends OptOutYearCreateArgs>(args: SelectSubset<T, OptOutYearCreateArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OptOutYears.
     * @param {OptOutYearCreateManyArgs} args - Arguments to create many OptOutYears.
     * @example
     * // Create many OptOutYears
     * const optOutYear = await prisma.optOutYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptOutYearCreateManyArgs>(args?: SelectSubset<T, OptOutYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OptOutYears and returns the data saved in the database.
     * @param {OptOutYearCreateManyAndReturnArgs} args - Arguments to create many OptOutYears.
     * @example
     * // Create many OptOutYears
     * const optOutYear = await prisma.optOutYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OptOutYears and only return the `id`
     * const optOutYearWithIdOnly = await prisma.optOutYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptOutYearCreateManyAndReturnArgs>(args?: SelectSubset<T, OptOutYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OptOutYear.
     * @param {OptOutYearDeleteArgs} args - Arguments to delete one OptOutYear.
     * @example
     * // Delete one OptOutYear
     * const OptOutYear = await prisma.optOutYear.delete({
     *   where: {
     *     // ... filter to delete one OptOutYear
     *   }
     * })
     * 
     */
    delete<T extends OptOutYearDeleteArgs>(args: SelectSubset<T, OptOutYearDeleteArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OptOutYear.
     * @param {OptOutYearUpdateArgs} args - Arguments to update one OptOutYear.
     * @example
     * // Update one OptOutYear
     * const optOutYear = await prisma.optOutYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptOutYearUpdateArgs>(args: SelectSubset<T, OptOutYearUpdateArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OptOutYears.
     * @param {OptOutYearDeleteManyArgs} args - Arguments to filter OptOutYears to delete.
     * @example
     * // Delete a few OptOutYears
     * const { count } = await prisma.optOutYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptOutYearDeleteManyArgs>(args?: SelectSubset<T, OptOutYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptOutYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptOutYears
     * const optOutYear = await prisma.optOutYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptOutYearUpdateManyArgs>(args: SelectSubset<T, OptOutYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptOutYears and returns the data updated in the database.
     * @param {OptOutYearUpdateManyAndReturnArgs} args - Arguments to update many OptOutYears.
     * @example
     * // Update many OptOutYears
     * const optOutYear = await prisma.optOutYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OptOutYears and only return the `id`
     * const optOutYearWithIdOnly = await prisma.optOutYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptOutYearUpdateManyAndReturnArgs>(args: SelectSubset<T, OptOutYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OptOutYear.
     * @param {OptOutYearUpsertArgs} args - Arguments to update or create a OptOutYear.
     * @example
     * // Update or create a OptOutYear
     * const optOutYear = await prisma.optOutYear.upsert({
     *   create: {
     *     // ... data to create a OptOutYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptOutYear we want to update
     *   }
     * })
     */
    upsert<T extends OptOutYearUpsertArgs>(args: SelectSubset<T, OptOutYearUpsertArgs<ExtArgs>>): Prisma__OptOutYearClient<$Result.GetResult<Prisma.$OptOutYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OptOutYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearCountArgs} args - Arguments to filter OptOutYears to count.
     * @example
     * // Count the number of OptOutYears
     * const count = await prisma.optOutYear.count({
     *   where: {
     *     // ... the filter for the OptOutYears we want to count
     *   }
     * })
    **/
    count<T extends OptOutYearCountArgs>(
      args?: Subset<T, OptOutYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptOutYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptOutYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptOutYearAggregateArgs>(args: Subset<T, OptOutYearAggregateArgs>): Prisma.PrismaPromise<GetOptOutYearAggregateType<T>>

    /**
     * Group by OptOutYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptOutYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptOutYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptOutYearGroupByArgs['orderBy'] }
        : { orderBy?: OptOutYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptOutYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptOutYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptOutYear model
   */
  readonly fields: OptOutYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptOutYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptOutYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptOutYear model
   */
  interface OptOutYearFieldRefs {
    readonly id: FieldRef<"OptOutYear", 'String'>
    readonly contractId: FieldRef<"OptOutYear", 'String'>
    readonly year: FieldRef<"OptOutYear", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OptOutYear findUnique
   */
  export type OptOutYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * Filter, which OptOutYear to fetch.
     */
    where: OptOutYearWhereUniqueInput
  }

  /**
   * OptOutYear findUniqueOrThrow
   */
  export type OptOutYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * Filter, which OptOutYear to fetch.
     */
    where: OptOutYearWhereUniqueInput
  }

  /**
   * OptOutYear findFirst
   */
  export type OptOutYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * Filter, which OptOutYear to fetch.
     */
    where?: OptOutYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptOutYears to fetch.
     */
    orderBy?: OptOutYearOrderByWithRelationInput | OptOutYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptOutYears.
     */
    cursor?: OptOutYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptOutYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptOutYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptOutYears.
     */
    distinct?: OptOutYearScalarFieldEnum | OptOutYearScalarFieldEnum[]
  }

  /**
   * OptOutYear findFirstOrThrow
   */
  export type OptOutYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * Filter, which OptOutYear to fetch.
     */
    where?: OptOutYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptOutYears to fetch.
     */
    orderBy?: OptOutYearOrderByWithRelationInput | OptOutYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptOutYears.
     */
    cursor?: OptOutYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptOutYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptOutYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptOutYears.
     */
    distinct?: OptOutYearScalarFieldEnum | OptOutYearScalarFieldEnum[]
  }

  /**
   * OptOutYear findMany
   */
  export type OptOutYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * Filter, which OptOutYears to fetch.
     */
    where?: OptOutYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptOutYears to fetch.
     */
    orderBy?: OptOutYearOrderByWithRelationInput | OptOutYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptOutYears.
     */
    cursor?: OptOutYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptOutYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptOutYears.
     */
    skip?: number
    distinct?: OptOutYearScalarFieldEnum | OptOutYearScalarFieldEnum[]
  }

  /**
   * OptOutYear create
   */
  export type OptOutYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * The data needed to create a OptOutYear.
     */
    data: XOR<OptOutYearCreateInput, OptOutYearUncheckedCreateInput>
  }

  /**
   * OptOutYear createMany
   */
  export type OptOutYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptOutYears.
     */
    data: OptOutYearCreateManyInput | OptOutYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OptOutYear createManyAndReturn
   */
  export type OptOutYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * The data used to create many OptOutYears.
     */
    data: OptOutYearCreateManyInput | OptOutYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptOutYear update
   */
  export type OptOutYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * The data needed to update a OptOutYear.
     */
    data: XOR<OptOutYearUpdateInput, OptOutYearUncheckedUpdateInput>
    /**
     * Choose, which OptOutYear to update.
     */
    where: OptOutYearWhereUniqueInput
  }

  /**
   * OptOutYear updateMany
   */
  export type OptOutYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptOutYears.
     */
    data: XOR<OptOutYearUpdateManyMutationInput, OptOutYearUncheckedUpdateManyInput>
    /**
     * Filter which OptOutYears to update
     */
    where?: OptOutYearWhereInput
    /**
     * Limit how many OptOutYears to update.
     */
    limit?: number
  }

  /**
   * OptOutYear updateManyAndReturn
   */
  export type OptOutYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * The data used to update OptOutYears.
     */
    data: XOR<OptOutYearUpdateManyMutationInput, OptOutYearUncheckedUpdateManyInput>
    /**
     * Filter which OptOutYears to update
     */
    where?: OptOutYearWhereInput
    /**
     * Limit how many OptOutYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptOutYear upsert
   */
  export type OptOutYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * The filter to search for the OptOutYear to update in case it exists.
     */
    where: OptOutYearWhereUniqueInput
    /**
     * In case the OptOutYear found by the `where` argument doesn't exist, create a new OptOutYear with this data.
     */
    create: XOR<OptOutYearCreateInput, OptOutYearUncheckedCreateInput>
    /**
     * In case the OptOutYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptOutYearUpdateInput, OptOutYearUncheckedUpdateInput>
  }

  /**
   * OptOutYear delete
   */
  export type OptOutYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
    /**
     * Filter which OptOutYear to delete.
     */
    where: OptOutYearWhereUniqueInput
  }

  /**
   * OptOutYear deleteMany
   */
  export type OptOutYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptOutYears to delete
     */
    where?: OptOutYearWhereInput
    /**
     * Limit how many OptOutYears to delete.
     */
    limit?: number
  }

  /**
   * OptOutYear without action
   */
  export type OptOutYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptOutYear
     */
    select?: OptOutYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptOutYear
     */
    omit?: OptOutYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptOutYearInclude<ExtArgs> | null
  }


  /**
   * Model RestructureEvent
   */

  export type AggregateRestructureEvent = {
    _count: RestructureEventCountAggregateOutputType | null
    _avg: RestructureEventAvgAggregateOutputType | null
    _sum: RestructureEventSumAggregateOutputType | null
    _min: RestructureEventMinAggregateOutputType | null
    _max: RestructureEventMaxAggregateOutputType | null
  }

  export type RestructureEventAvgAggregateOutputType = {
    year: number | null
    amountConvertedToBonus: number | null
    newCapHit: number | null
    newDeadCap: number | null
  }

  export type RestructureEventSumAggregateOutputType = {
    year: number | null
    amountConvertedToBonus: number | null
    newCapHit: number | null
    newDeadCap: number | null
  }

  export type RestructureEventMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    date: Date | null
    amountConvertedToBonus: number | null
    newCapHit: number | null
    newDeadCap: number | null
  }

  export type RestructureEventMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    year: number | null
    date: Date | null
    amountConvertedToBonus: number | null
    newCapHit: number | null
    newDeadCap: number | null
  }

  export type RestructureEventCountAggregateOutputType = {
    id: number
    contractId: number
    year: number
    date: number
    amountConvertedToBonus: number
    newCapHit: number
    newDeadCap: number
    _all: number
  }


  export type RestructureEventAvgAggregateInputType = {
    year?: true
    amountConvertedToBonus?: true
    newCapHit?: true
    newDeadCap?: true
  }

  export type RestructureEventSumAggregateInputType = {
    year?: true
    amountConvertedToBonus?: true
    newCapHit?: true
    newDeadCap?: true
  }

  export type RestructureEventMinAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    date?: true
    amountConvertedToBonus?: true
    newCapHit?: true
    newDeadCap?: true
  }

  export type RestructureEventMaxAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    date?: true
    amountConvertedToBonus?: true
    newCapHit?: true
    newDeadCap?: true
  }

  export type RestructureEventCountAggregateInputType = {
    id?: true
    contractId?: true
    year?: true
    date?: true
    amountConvertedToBonus?: true
    newCapHit?: true
    newDeadCap?: true
    _all?: true
  }

  export type RestructureEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestructureEvent to aggregate.
     */
    where?: RestructureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestructureEvents to fetch.
     */
    orderBy?: RestructureEventOrderByWithRelationInput | RestructureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestructureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestructureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestructureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestructureEvents
    **/
    _count?: true | RestructureEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestructureEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestructureEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestructureEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestructureEventMaxAggregateInputType
  }

  export type GetRestructureEventAggregateType<T extends RestructureEventAggregateArgs> = {
        [P in keyof T & keyof AggregateRestructureEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestructureEvent[P]>
      : GetScalarType<T[P], AggregateRestructureEvent[P]>
  }




  export type RestructureEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestructureEventWhereInput
    orderBy?: RestructureEventOrderByWithAggregationInput | RestructureEventOrderByWithAggregationInput[]
    by: RestructureEventScalarFieldEnum[] | RestructureEventScalarFieldEnum
    having?: RestructureEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestructureEventCountAggregateInputType | true
    _avg?: RestructureEventAvgAggregateInputType
    _sum?: RestructureEventSumAggregateInputType
    _min?: RestructureEventMinAggregateInputType
    _max?: RestructureEventMaxAggregateInputType
  }

  export type RestructureEventGroupByOutputType = {
    id: string
    contractId: string
    year: number | null
    date: Date | null
    amountConvertedToBonus: number | null
    newCapHit: number | null
    newDeadCap: number | null
    _count: RestructureEventCountAggregateOutputType | null
    _avg: RestructureEventAvgAggregateOutputType | null
    _sum: RestructureEventSumAggregateOutputType | null
    _min: RestructureEventMinAggregateOutputType | null
    _max: RestructureEventMaxAggregateOutputType | null
  }

  type GetRestructureEventGroupByPayload<T extends RestructureEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestructureEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestructureEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestructureEventGroupByOutputType[P]>
            : GetScalarType<T[P], RestructureEventGroupByOutputType[P]>
        }
      >
    >


  export type RestructureEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    date?: boolean
    amountConvertedToBonus?: boolean
    newCapHit?: boolean
    newDeadCap?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restructureEvent"]>

  export type RestructureEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    date?: boolean
    amountConvertedToBonus?: boolean
    newCapHit?: boolean
    newDeadCap?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restructureEvent"]>

  export type RestructureEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    year?: boolean
    date?: boolean
    amountConvertedToBonus?: boolean
    newCapHit?: boolean
    newDeadCap?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restructureEvent"]>

  export type RestructureEventSelectScalar = {
    id?: boolean
    contractId?: boolean
    year?: boolean
    date?: boolean
    amountConvertedToBonus?: boolean
    newCapHit?: boolean
    newDeadCap?: boolean
  }

  export type RestructureEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "year" | "date" | "amountConvertedToBonus" | "newCapHit" | "newDeadCap", ExtArgs["result"]["restructureEvent"]>
  export type RestructureEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type RestructureEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type RestructureEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $RestructureEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestructureEvent"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      year: number | null
      date: Date | null
      amountConvertedToBonus: number | null
      newCapHit: number | null
      newDeadCap: number | null
    }, ExtArgs["result"]["restructureEvent"]>
    composites: {}
  }

  type RestructureEventGetPayload<S extends boolean | null | undefined | RestructureEventDefaultArgs> = $Result.GetResult<Prisma.$RestructureEventPayload, S>

  type RestructureEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestructureEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestructureEventCountAggregateInputType | true
    }

  export interface RestructureEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestructureEvent'], meta: { name: 'RestructureEvent' } }
    /**
     * Find zero or one RestructureEvent that matches the filter.
     * @param {RestructureEventFindUniqueArgs} args - Arguments to find a RestructureEvent
     * @example
     * // Get one RestructureEvent
     * const restructureEvent = await prisma.restructureEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestructureEventFindUniqueArgs>(args: SelectSubset<T, RestructureEventFindUniqueArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestructureEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestructureEventFindUniqueOrThrowArgs} args - Arguments to find a RestructureEvent
     * @example
     * // Get one RestructureEvent
     * const restructureEvent = await prisma.restructureEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestructureEventFindUniqueOrThrowArgs>(args: SelectSubset<T, RestructureEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestructureEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventFindFirstArgs} args - Arguments to find a RestructureEvent
     * @example
     * // Get one RestructureEvent
     * const restructureEvent = await prisma.restructureEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestructureEventFindFirstArgs>(args?: SelectSubset<T, RestructureEventFindFirstArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestructureEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventFindFirstOrThrowArgs} args - Arguments to find a RestructureEvent
     * @example
     * // Get one RestructureEvent
     * const restructureEvent = await prisma.restructureEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestructureEventFindFirstOrThrowArgs>(args?: SelectSubset<T, RestructureEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestructureEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestructureEvents
     * const restructureEvents = await prisma.restructureEvent.findMany()
     * 
     * // Get first 10 RestructureEvents
     * const restructureEvents = await prisma.restructureEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restructureEventWithIdOnly = await prisma.restructureEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestructureEventFindManyArgs>(args?: SelectSubset<T, RestructureEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestructureEvent.
     * @param {RestructureEventCreateArgs} args - Arguments to create a RestructureEvent.
     * @example
     * // Create one RestructureEvent
     * const RestructureEvent = await prisma.restructureEvent.create({
     *   data: {
     *     // ... data to create a RestructureEvent
     *   }
     * })
     * 
     */
    create<T extends RestructureEventCreateArgs>(args: SelectSubset<T, RestructureEventCreateArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestructureEvents.
     * @param {RestructureEventCreateManyArgs} args - Arguments to create many RestructureEvents.
     * @example
     * // Create many RestructureEvents
     * const restructureEvent = await prisma.restructureEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestructureEventCreateManyArgs>(args?: SelectSubset<T, RestructureEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestructureEvents and returns the data saved in the database.
     * @param {RestructureEventCreateManyAndReturnArgs} args - Arguments to create many RestructureEvents.
     * @example
     * // Create many RestructureEvents
     * const restructureEvent = await prisma.restructureEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestructureEvents and only return the `id`
     * const restructureEventWithIdOnly = await prisma.restructureEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestructureEventCreateManyAndReturnArgs>(args?: SelectSubset<T, RestructureEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestructureEvent.
     * @param {RestructureEventDeleteArgs} args - Arguments to delete one RestructureEvent.
     * @example
     * // Delete one RestructureEvent
     * const RestructureEvent = await prisma.restructureEvent.delete({
     *   where: {
     *     // ... filter to delete one RestructureEvent
     *   }
     * })
     * 
     */
    delete<T extends RestructureEventDeleteArgs>(args: SelectSubset<T, RestructureEventDeleteArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestructureEvent.
     * @param {RestructureEventUpdateArgs} args - Arguments to update one RestructureEvent.
     * @example
     * // Update one RestructureEvent
     * const restructureEvent = await prisma.restructureEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestructureEventUpdateArgs>(args: SelectSubset<T, RestructureEventUpdateArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestructureEvents.
     * @param {RestructureEventDeleteManyArgs} args - Arguments to filter RestructureEvents to delete.
     * @example
     * // Delete a few RestructureEvents
     * const { count } = await prisma.restructureEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestructureEventDeleteManyArgs>(args?: SelectSubset<T, RestructureEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestructureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestructureEvents
     * const restructureEvent = await prisma.restructureEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestructureEventUpdateManyArgs>(args: SelectSubset<T, RestructureEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestructureEvents and returns the data updated in the database.
     * @param {RestructureEventUpdateManyAndReturnArgs} args - Arguments to update many RestructureEvents.
     * @example
     * // Update many RestructureEvents
     * const restructureEvent = await prisma.restructureEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestructureEvents and only return the `id`
     * const restructureEventWithIdOnly = await prisma.restructureEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestructureEventUpdateManyAndReturnArgs>(args: SelectSubset<T, RestructureEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestructureEvent.
     * @param {RestructureEventUpsertArgs} args - Arguments to update or create a RestructureEvent.
     * @example
     * // Update or create a RestructureEvent
     * const restructureEvent = await prisma.restructureEvent.upsert({
     *   create: {
     *     // ... data to create a RestructureEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestructureEvent we want to update
     *   }
     * })
     */
    upsert<T extends RestructureEventUpsertArgs>(args: SelectSubset<T, RestructureEventUpsertArgs<ExtArgs>>): Prisma__RestructureEventClient<$Result.GetResult<Prisma.$RestructureEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestructureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventCountArgs} args - Arguments to filter RestructureEvents to count.
     * @example
     * // Count the number of RestructureEvents
     * const count = await prisma.restructureEvent.count({
     *   where: {
     *     // ... the filter for the RestructureEvents we want to count
     *   }
     * })
    **/
    count<T extends RestructureEventCountArgs>(
      args?: Subset<T, RestructureEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestructureEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestructureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestructureEventAggregateArgs>(args: Subset<T, RestructureEventAggregateArgs>): Prisma.PrismaPromise<GetRestructureEventAggregateType<T>>

    /**
     * Group by RestructureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestructureEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestructureEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestructureEventGroupByArgs['orderBy'] }
        : { orderBy?: RestructureEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestructureEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestructureEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestructureEvent model
   */
  readonly fields: RestructureEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestructureEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestructureEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestructureEvent model
   */
  interface RestructureEventFieldRefs {
    readonly id: FieldRef<"RestructureEvent", 'String'>
    readonly contractId: FieldRef<"RestructureEvent", 'String'>
    readonly year: FieldRef<"RestructureEvent", 'Int'>
    readonly date: FieldRef<"RestructureEvent", 'DateTime'>
    readonly amountConvertedToBonus: FieldRef<"RestructureEvent", 'Int'>
    readonly newCapHit: FieldRef<"RestructureEvent", 'Int'>
    readonly newDeadCap: FieldRef<"RestructureEvent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RestructureEvent findUnique
   */
  export type RestructureEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * Filter, which RestructureEvent to fetch.
     */
    where: RestructureEventWhereUniqueInput
  }

  /**
   * RestructureEvent findUniqueOrThrow
   */
  export type RestructureEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * Filter, which RestructureEvent to fetch.
     */
    where: RestructureEventWhereUniqueInput
  }

  /**
   * RestructureEvent findFirst
   */
  export type RestructureEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * Filter, which RestructureEvent to fetch.
     */
    where?: RestructureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestructureEvents to fetch.
     */
    orderBy?: RestructureEventOrderByWithRelationInput | RestructureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestructureEvents.
     */
    cursor?: RestructureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestructureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestructureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestructureEvents.
     */
    distinct?: RestructureEventScalarFieldEnum | RestructureEventScalarFieldEnum[]
  }

  /**
   * RestructureEvent findFirstOrThrow
   */
  export type RestructureEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * Filter, which RestructureEvent to fetch.
     */
    where?: RestructureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestructureEvents to fetch.
     */
    orderBy?: RestructureEventOrderByWithRelationInput | RestructureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestructureEvents.
     */
    cursor?: RestructureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestructureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestructureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestructureEvents.
     */
    distinct?: RestructureEventScalarFieldEnum | RestructureEventScalarFieldEnum[]
  }

  /**
   * RestructureEvent findMany
   */
  export type RestructureEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * Filter, which RestructureEvents to fetch.
     */
    where?: RestructureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestructureEvents to fetch.
     */
    orderBy?: RestructureEventOrderByWithRelationInput | RestructureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestructureEvents.
     */
    cursor?: RestructureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestructureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestructureEvents.
     */
    skip?: number
    distinct?: RestructureEventScalarFieldEnum | RestructureEventScalarFieldEnum[]
  }

  /**
   * RestructureEvent create
   */
  export type RestructureEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * The data needed to create a RestructureEvent.
     */
    data: XOR<RestructureEventCreateInput, RestructureEventUncheckedCreateInput>
  }

  /**
   * RestructureEvent createMany
   */
  export type RestructureEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestructureEvents.
     */
    data: RestructureEventCreateManyInput | RestructureEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RestructureEvent createManyAndReturn
   */
  export type RestructureEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * The data used to create many RestructureEvents.
     */
    data: RestructureEventCreateManyInput | RestructureEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestructureEvent update
   */
  export type RestructureEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * The data needed to update a RestructureEvent.
     */
    data: XOR<RestructureEventUpdateInput, RestructureEventUncheckedUpdateInput>
    /**
     * Choose, which RestructureEvent to update.
     */
    where: RestructureEventWhereUniqueInput
  }

  /**
   * RestructureEvent updateMany
   */
  export type RestructureEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestructureEvents.
     */
    data: XOR<RestructureEventUpdateManyMutationInput, RestructureEventUncheckedUpdateManyInput>
    /**
     * Filter which RestructureEvents to update
     */
    where?: RestructureEventWhereInput
    /**
     * Limit how many RestructureEvents to update.
     */
    limit?: number
  }

  /**
   * RestructureEvent updateManyAndReturn
   */
  export type RestructureEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * The data used to update RestructureEvents.
     */
    data: XOR<RestructureEventUpdateManyMutationInput, RestructureEventUncheckedUpdateManyInput>
    /**
     * Filter which RestructureEvents to update
     */
    where?: RestructureEventWhereInput
    /**
     * Limit how many RestructureEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestructureEvent upsert
   */
  export type RestructureEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * The filter to search for the RestructureEvent to update in case it exists.
     */
    where: RestructureEventWhereUniqueInput
    /**
     * In case the RestructureEvent found by the `where` argument doesn't exist, create a new RestructureEvent with this data.
     */
    create: XOR<RestructureEventCreateInput, RestructureEventUncheckedCreateInput>
    /**
     * In case the RestructureEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestructureEventUpdateInput, RestructureEventUncheckedUpdateInput>
  }

  /**
   * RestructureEvent delete
   */
  export type RestructureEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
    /**
     * Filter which RestructureEvent to delete.
     */
    where: RestructureEventWhereUniqueInput
  }

  /**
   * RestructureEvent deleteMany
   */
  export type RestructureEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestructureEvents to delete
     */
    where?: RestructureEventWhereInput
    /**
     * Limit how many RestructureEvents to delete.
     */
    limit?: number
  }

  /**
   * RestructureEvent without action
   */
  export type RestructureEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestructureEvent
     */
    select?: RestructureEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestructureEvent
     */
    omit?: RestructureEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestructureEventInclude<ExtArgs> | null
  }


  /**
   * Model ContractClause
   */

  export type AggregateContractClause = {
    _count: ContractClauseCountAggregateOutputType | null
    _avg: ContractClauseAvgAggregateOutputType | null
    _sum: ContractClauseSumAggregateOutputType | null
    _min: ContractClauseMinAggregateOutputType | null
    _max: ContractClauseMaxAggregateOutputType | null
  }

  export type ContractClauseAvgAggregateOutputType = {
    earlyTerminationPenalty: number | null
  }

  export type ContractClauseSumAggregateOutputType = {
    earlyTerminationPenalty: number | null
  }

  export type ContractClauseMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    noTradeClause: boolean | null
    injuryGuarantee: boolean | null
    restructureEligible: boolean | null
    earlyTerminationPenalty: number | null
    performanceBonusId: string | null
    rosterBonusId: string | null
    workoutBonusId: string | null
    optionBonusId: string | null
  }

  export type ContractClauseMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    noTradeClause: boolean | null
    injuryGuarantee: boolean | null
    restructureEligible: boolean | null
    earlyTerminationPenalty: number | null
    performanceBonusId: string | null
    rosterBonusId: string | null
    workoutBonusId: string | null
    optionBonusId: string | null
  }

  export type ContractClauseCountAggregateOutputType = {
    id: number
    contractId: number
    noTradeClause: number
    injuryGuarantee: number
    restructureEligible: number
    earlyTerminationPenalty: number
    performanceBonusId: number
    rosterBonusId: number
    workoutBonusId: number
    optionBonusId: number
    _all: number
  }


  export type ContractClauseAvgAggregateInputType = {
    earlyTerminationPenalty?: true
  }

  export type ContractClauseSumAggregateInputType = {
    earlyTerminationPenalty?: true
  }

  export type ContractClauseMinAggregateInputType = {
    id?: true
    contractId?: true
    noTradeClause?: true
    injuryGuarantee?: true
    restructureEligible?: true
    earlyTerminationPenalty?: true
    performanceBonusId?: true
    rosterBonusId?: true
    workoutBonusId?: true
    optionBonusId?: true
  }

  export type ContractClauseMaxAggregateInputType = {
    id?: true
    contractId?: true
    noTradeClause?: true
    injuryGuarantee?: true
    restructureEligible?: true
    earlyTerminationPenalty?: true
    performanceBonusId?: true
    rosterBonusId?: true
    workoutBonusId?: true
    optionBonusId?: true
  }

  export type ContractClauseCountAggregateInputType = {
    id?: true
    contractId?: true
    noTradeClause?: true
    injuryGuarantee?: true
    restructureEligible?: true
    earlyTerminationPenalty?: true
    performanceBonusId?: true
    rosterBonusId?: true
    workoutBonusId?: true
    optionBonusId?: true
    _all?: true
  }

  export type ContractClauseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractClause to aggregate.
     */
    where?: ContractClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractClauses to fetch.
     */
    orderBy?: ContractClauseOrderByWithRelationInput | ContractClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractClauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractClauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractClauses
    **/
    _count?: true | ContractClauseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractClauseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractClauseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractClauseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractClauseMaxAggregateInputType
  }

  export type GetContractClauseAggregateType<T extends ContractClauseAggregateArgs> = {
        [P in keyof T & keyof AggregateContractClause]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractClause[P]>
      : GetScalarType<T[P], AggregateContractClause[P]>
  }




  export type ContractClauseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractClauseWhereInput
    orderBy?: ContractClauseOrderByWithAggregationInput | ContractClauseOrderByWithAggregationInput[]
    by: ContractClauseScalarFieldEnum[] | ContractClauseScalarFieldEnum
    having?: ContractClauseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractClauseCountAggregateInputType | true
    _avg?: ContractClauseAvgAggregateInputType
    _sum?: ContractClauseSumAggregateInputType
    _min?: ContractClauseMinAggregateInputType
    _max?: ContractClauseMaxAggregateInputType
  }

  export type ContractClauseGroupByOutputType = {
    id: string
    contractId: string
    noTradeClause: boolean | null
    injuryGuarantee: boolean | null
    restructureEligible: boolean | null
    earlyTerminationPenalty: number | null
    performanceBonusId: string | null
    rosterBonusId: string | null
    workoutBonusId: string | null
    optionBonusId: string | null
    _count: ContractClauseCountAggregateOutputType | null
    _avg: ContractClauseAvgAggregateOutputType | null
    _sum: ContractClauseSumAggregateOutputType | null
    _min: ContractClauseMinAggregateOutputType | null
    _max: ContractClauseMaxAggregateOutputType | null
  }

  type GetContractClauseGroupByPayload<T extends ContractClauseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractClauseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractClauseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractClauseGroupByOutputType[P]>
            : GetScalarType<T[P], ContractClauseGroupByOutputType[P]>
        }
      >
    >


  export type ContractClauseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    noTradeClause?: boolean
    injuryGuarantee?: boolean
    restructureEligible?: boolean
    earlyTerminationPenalty?: boolean
    performanceBonusId?: boolean
    rosterBonusId?: boolean
    workoutBonusId?: boolean
    optionBonusId?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
    performanceBonus?: boolean | ContractClause$performanceBonusArgs<ExtArgs>
    rosterBonus?: boolean | ContractClause$rosterBonusArgs<ExtArgs>
    workoutBonus?: boolean | ContractClause$workoutBonusArgs<ExtArgs>
    optionBonus?: boolean | ContractClause$optionBonusArgs<ExtArgs>
  }, ExtArgs["result"]["contractClause"]>

  export type ContractClauseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    noTradeClause?: boolean
    injuryGuarantee?: boolean
    restructureEligible?: boolean
    earlyTerminationPenalty?: boolean
    performanceBonusId?: boolean
    rosterBonusId?: boolean
    workoutBonusId?: boolean
    optionBonusId?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractClause"]>

  export type ContractClauseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    noTradeClause?: boolean
    injuryGuarantee?: boolean
    restructureEligible?: boolean
    earlyTerminationPenalty?: boolean
    performanceBonusId?: boolean
    rosterBonusId?: boolean
    workoutBonusId?: boolean
    optionBonusId?: boolean
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractClause"]>

  export type ContractClauseSelectScalar = {
    id?: boolean
    contractId?: boolean
    noTradeClause?: boolean
    injuryGuarantee?: boolean
    restructureEligible?: boolean
    earlyTerminationPenalty?: boolean
    performanceBonusId?: boolean
    rosterBonusId?: boolean
    workoutBonusId?: boolean
    optionBonusId?: boolean
  }

  export type ContractClauseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "noTradeClause" | "injuryGuarantee" | "restructureEligible" | "earlyTerminationPenalty" | "performanceBonusId" | "rosterBonusId" | "workoutBonusId" | "optionBonusId", ExtArgs["result"]["contractClause"]>
  export type ContractClauseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
    performanceBonus?: boolean | ContractClause$performanceBonusArgs<ExtArgs>
    rosterBonus?: boolean | ContractClause$rosterBonusArgs<ExtArgs>
    workoutBonus?: boolean | ContractClause$workoutBonusArgs<ExtArgs>
    optionBonus?: boolean | ContractClause$optionBonusArgs<ExtArgs>
  }
  export type ContractClauseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }
  export type ContractClauseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | PlayerContractDefaultArgs<ExtArgs>
  }

  export type $ContractClausePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractClause"
    objects: {
      contract: Prisma.$PlayerContractPayload<ExtArgs>
      performanceBonus: Prisma.$PerformanceBonusPayload<ExtArgs> | null
      rosterBonus: Prisma.$RosterBonusPayload<ExtArgs> | null
      workoutBonus: Prisma.$WorkoutBonusPayload<ExtArgs> | null
      optionBonus: Prisma.$OptionBonusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      noTradeClause: boolean | null
      injuryGuarantee: boolean | null
      restructureEligible: boolean | null
      earlyTerminationPenalty: number | null
      performanceBonusId: string | null
      rosterBonusId: string | null
      workoutBonusId: string | null
      optionBonusId: string | null
    }, ExtArgs["result"]["contractClause"]>
    composites: {}
  }

  type ContractClauseGetPayload<S extends boolean | null | undefined | ContractClauseDefaultArgs> = $Result.GetResult<Prisma.$ContractClausePayload, S>

  type ContractClauseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractClauseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractClauseCountAggregateInputType | true
    }

  export interface ContractClauseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractClause'], meta: { name: 'ContractClause' } }
    /**
     * Find zero or one ContractClause that matches the filter.
     * @param {ContractClauseFindUniqueArgs} args - Arguments to find a ContractClause
     * @example
     * // Get one ContractClause
     * const contractClause = await prisma.contractClause.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractClauseFindUniqueArgs>(args: SelectSubset<T, ContractClauseFindUniqueArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractClause that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractClauseFindUniqueOrThrowArgs} args - Arguments to find a ContractClause
     * @example
     * // Get one ContractClause
     * const contractClause = await prisma.contractClause.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractClauseFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractClauseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractClause that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseFindFirstArgs} args - Arguments to find a ContractClause
     * @example
     * // Get one ContractClause
     * const contractClause = await prisma.contractClause.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractClauseFindFirstArgs>(args?: SelectSubset<T, ContractClauseFindFirstArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractClause that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseFindFirstOrThrowArgs} args - Arguments to find a ContractClause
     * @example
     * // Get one ContractClause
     * const contractClause = await prisma.contractClause.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractClauseFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractClauseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractClauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractClauses
     * const contractClauses = await prisma.contractClause.findMany()
     * 
     * // Get first 10 ContractClauses
     * const contractClauses = await prisma.contractClause.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractClauseWithIdOnly = await prisma.contractClause.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractClauseFindManyArgs>(args?: SelectSubset<T, ContractClauseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractClause.
     * @param {ContractClauseCreateArgs} args - Arguments to create a ContractClause.
     * @example
     * // Create one ContractClause
     * const ContractClause = await prisma.contractClause.create({
     *   data: {
     *     // ... data to create a ContractClause
     *   }
     * })
     * 
     */
    create<T extends ContractClauseCreateArgs>(args: SelectSubset<T, ContractClauseCreateArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractClauses.
     * @param {ContractClauseCreateManyArgs} args - Arguments to create many ContractClauses.
     * @example
     * // Create many ContractClauses
     * const contractClause = await prisma.contractClause.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractClauseCreateManyArgs>(args?: SelectSubset<T, ContractClauseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractClauses and returns the data saved in the database.
     * @param {ContractClauseCreateManyAndReturnArgs} args - Arguments to create many ContractClauses.
     * @example
     * // Create many ContractClauses
     * const contractClause = await prisma.contractClause.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractClauses and only return the `id`
     * const contractClauseWithIdOnly = await prisma.contractClause.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractClauseCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractClauseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractClause.
     * @param {ContractClauseDeleteArgs} args - Arguments to delete one ContractClause.
     * @example
     * // Delete one ContractClause
     * const ContractClause = await prisma.contractClause.delete({
     *   where: {
     *     // ... filter to delete one ContractClause
     *   }
     * })
     * 
     */
    delete<T extends ContractClauseDeleteArgs>(args: SelectSubset<T, ContractClauseDeleteArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractClause.
     * @param {ContractClauseUpdateArgs} args - Arguments to update one ContractClause.
     * @example
     * // Update one ContractClause
     * const contractClause = await prisma.contractClause.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractClauseUpdateArgs>(args: SelectSubset<T, ContractClauseUpdateArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractClauses.
     * @param {ContractClauseDeleteManyArgs} args - Arguments to filter ContractClauses to delete.
     * @example
     * // Delete a few ContractClauses
     * const { count } = await prisma.contractClause.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractClauseDeleteManyArgs>(args?: SelectSubset<T, ContractClauseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractClauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractClauses
     * const contractClause = await prisma.contractClause.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractClauseUpdateManyArgs>(args: SelectSubset<T, ContractClauseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractClauses and returns the data updated in the database.
     * @param {ContractClauseUpdateManyAndReturnArgs} args - Arguments to update many ContractClauses.
     * @example
     * // Update many ContractClauses
     * const contractClause = await prisma.contractClause.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractClauses and only return the `id`
     * const contractClauseWithIdOnly = await prisma.contractClause.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractClauseUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractClauseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractClause.
     * @param {ContractClauseUpsertArgs} args - Arguments to update or create a ContractClause.
     * @example
     * // Update or create a ContractClause
     * const contractClause = await prisma.contractClause.upsert({
     *   create: {
     *     // ... data to create a ContractClause
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractClause we want to update
     *   }
     * })
     */
    upsert<T extends ContractClauseUpsertArgs>(args: SelectSubset<T, ContractClauseUpsertArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractClauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseCountArgs} args - Arguments to filter ContractClauses to count.
     * @example
     * // Count the number of ContractClauses
     * const count = await prisma.contractClause.count({
     *   where: {
     *     // ... the filter for the ContractClauses we want to count
     *   }
     * })
    **/
    count<T extends ContractClauseCountArgs>(
      args?: Subset<T, ContractClauseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractClauseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractClause.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractClauseAggregateArgs>(args: Subset<T, ContractClauseAggregateArgs>): Prisma.PrismaPromise<GetContractClauseAggregateType<T>>

    /**
     * Group by ContractClause.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractClauseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractClauseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractClauseGroupByArgs['orderBy'] }
        : { orderBy?: ContractClauseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractClauseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractClauseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractClause model
   */
  readonly fields: ContractClauseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractClause.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClauseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends PlayerContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerContractDefaultArgs<ExtArgs>>): Prisma__PlayerContractClient<$Result.GetResult<Prisma.$PlayerContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    performanceBonus<T extends ContractClause$performanceBonusArgs<ExtArgs> = {}>(args?: Subset<T, ContractClause$performanceBonusArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rosterBonus<T extends ContractClause$rosterBonusArgs<ExtArgs> = {}>(args?: Subset<T, ContractClause$rosterBonusArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workoutBonus<T extends ContractClause$workoutBonusArgs<ExtArgs> = {}>(args?: Subset<T, ContractClause$workoutBonusArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    optionBonus<T extends ContractClause$optionBonusArgs<ExtArgs> = {}>(args?: Subset<T, ContractClause$optionBonusArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractClause model
   */
  interface ContractClauseFieldRefs {
    readonly id: FieldRef<"ContractClause", 'String'>
    readonly contractId: FieldRef<"ContractClause", 'String'>
    readonly noTradeClause: FieldRef<"ContractClause", 'Boolean'>
    readonly injuryGuarantee: FieldRef<"ContractClause", 'Boolean'>
    readonly restructureEligible: FieldRef<"ContractClause", 'Boolean'>
    readonly earlyTerminationPenalty: FieldRef<"ContractClause", 'Float'>
    readonly performanceBonusId: FieldRef<"ContractClause", 'String'>
    readonly rosterBonusId: FieldRef<"ContractClause", 'String'>
    readonly workoutBonusId: FieldRef<"ContractClause", 'String'>
    readonly optionBonusId: FieldRef<"ContractClause", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContractClause findUnique
   */
  export type ContractClauseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * Filter, which ContractClause to fetch.
     */
    where: ContractClauseWhereUniqueInput
  }

  /**
   * ContractClause findUniqueOrThrow
   */
  export type ContractClauseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * Filter, which ContractClause to fetch.
     */
    where: ContractClauseWhereUniqueInput
  }

  /**
   * ContractClause findFirst
   */
  export type ContractClauseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * Filter, which ContractClause to fetch.
     */
    where?: ContractClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractClauses to fetch.
     */
    orderBy?: ContractClauseOrderByWithRelationInput | ContractClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractClauses.
     */
    cursor?: ContractClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractClauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractClauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractClauses.
     */
    distinct?: ContractClauseScalarFieldEnum | ContractClauseScalarFieldEnum[]
  }

  /**
   * ContractClause findFirstOrThrow
   */
  export type ContractClauseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * Filter, which ContractClause to fetch.
     */
    where?: ContractClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractClauses to fetch.
     */
    orderBy?: ContractClauseOrderByWithRelationInput | ContractClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractClauses.
     */
    cursor?: ContractClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractClauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractClauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractClauses.
     */
    distinct?: ContractClauseScalarFieldEnum | ContractClauseScalarFieldEnum[]
  }

  /**
   * ContractClause findMany
   */
  export type ContractClauseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * Filter, which ContractClauses to fetch.
     */
    where?: ContractClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractClauses to fetch.
     */
    orderBy?: ContractClauseOrderByWithRelationInput | ContractClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractClauses.
     */
    cursor?: ContractClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractClauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractClauses.
     */
    skip?: number
    distinct?: ContractClauseScalarFieldEnum | ContractClauseScalarFieldEnum[]
  }

  /**
   * ContractClause create
   */
  export type ContractClauseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractClause.
     */
    data: XOR<ContractClauseCreateInput, ContractClauseUncheckedCreateInput>
  }

  /**
   * ContractClause createMany
   */
  export type ContractClauseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractClauses.
     */
    data: ContractClauseCreateManyInput | ContractClauseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractClause createManyAndReturn
   */
  export type ContractClauseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * The data used to create many ContractClauses.
     */
    data: ContractClauseCreateManyInput | ContractClauseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractClause update
   */
  export type ContractClauseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractClause.
     */
    data: XOR<ContractClauseUpdateInput, ContractClauseUncheckedUpdateInput>
    /**
     * Choose, which ContractClause to update.
     */
    where: ContractClauseWhereUniqueInput
  }

  /**
   * ContractClause updateMany
   */
  export type ContractClauseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractClauses.
     */
    data: XOR<ContractClauseUpdateManyMutationInput, ContractClauseUncheckedUpdateManyInput>
    /**
     * Filter which ContractClauses to update
     */
    where?: ContractClauseWhereInput
    /**
     * Limit how many ContractClauses to update.
     */
    limit?: number
  }

  /**
   * ContractClause updateManyAndReturn
   */
  export type ContractClauseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * The data used to update ContractClauses.
     */
    data: XOR<ContractClauseUpdateManyMutationInput, ContractClauseUncheckedUpdateManyInput>
    /**
     * Filter which ContractClauses to update
     */
    where?: ContractClauseWhereInput
    /**
     * Limit how many ContractClauses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractClause upsert
   */
  export type ContractClauseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractClause to update in case it exists.
     */
    where: ContractClauseWhereUniqueInput
    /**
     * In case the ContractClause found by the `where` argument doesn't exist, create a new ContractClause with this data.
     */
    create: XOR<ContractClauseCreateInput, ContractClauseUncheckedCreateInput>
    /**
     * In case the ContractClause was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractClauseUpdateInput, ContractClauseUncheckedUpdateInput>
  }

  /**
   * ContractClause delete
   */
  export type ContractClauseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
    /**
     * Filter which ContractClause to delete.
     */
    where: ContractClauseWhereUniqueInput
  }

  /**
   * ContractClause deleteMany
   */
  export type ContractClauseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractClauses to delete
     */
    where?: ContractClauseWhereInput
    /**
     * Limit how many ContractClauses to delete.
     */
    limit?: number
  }

  /**
   * ContractClause.performanceBonus
   */
  export type ContractClause$performanceBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    where?: PerformanceBonusWhereInput
  }

  /**
   * ContractClause.rosterBonus
   */
  export type ContractClause$rosterBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    where?: RosterBonusWhereInput
  }

  /**
   * ContractClause.workoutBonus
   */
  export type ContractClause$workoutBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    where?: WorkoutBonusWhereInput
  }

  /**
   * ContractClause.optionBonus
   */
  export type ContractClause$optionBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    where?: OptionBonusWhereInput
  }

  /**
   * ContractClause without action
   */
  export type ContractClauseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractClause
     */
    select?: ContractClauseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractClause
     */
    omit?: ContractClauseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractClauseInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceBonus
   */

  export type AggregatePerformanceBonus = {
    _count: PerformanceBonusCountAggregateOutputType | null
    _avg: PerformanceBonusAvgAggregateOutputType | null
    _sum: PerformanceBonusSumAggregateOutputType | null
    _min: PerformanceBonusMinAggregateOutputType | null
    _max: PerformanceBonusMaxAggregateOutputType | null
  }

  export type PerformanceBonusAvgAggregateOutputType = {
    proBowl: number | null
    allPro: number | null
    mvp: number | null
    superBowlMVP: number | null
    playoffAppearance: number | null
  }

  export type PerformanceBonusSumAggregateOutputType = {
    proBowl: number | null
    allPro: number | null
    mvp: number | null
    superBowlMVP: number | null
    playoffAppearance: number | null
  }

  export type PerformanceBonusMinAggregateOutputType = {
    id: string | null
    clauseId: string | null
    proBowl: number | null
    allPro: number | null
    mvp: number | null
    superBowlMVP: number | null
    playoffAppearance: number | null
  }

  export type PerformanceBonusMaxAggregateOutputType = {
    id: string | null
    clauseId: string | null
    proBowl: number | null
    allPro: number | null
    mvp: number | null
    superBowlMVP: number | null
    playoffAppearance: number | null
  }

  export type PerformanceBonusCountAggregateOutputType = {
    id: number
    clauseId: number
    proBowl: number
    allPro: number
    mvp: number
    superBowlMVP: number
    playoffAppearance: number
    _all: number
  }


  export type PerformanceBonusAvgAggregateInputType = {
    proBowl?: true
    allPro?: true
    mvp?: true
    superBowlMVP?: true
    playoffAppearance?: true
  }

  export type PerformanceBonusSumAggregateInputType = {
    proBowl?: true
    allPro?: true
    mvp?: true
    superBowlMVP?: true
    playoffAppearance?: true
  }

  export type PerformanceBonusMinAggregateInputType = {
    id?: true
    clauseId?: true
    proBowl?: true
    allPro?: true
    mvp?: true
    superBowlMVP?: true
    playoffAppearance?: true
  }

  export type PerformanceBonusMaxAggregateInputType = {
    id?: true
    clauseId?: true
    proBowl?: true
    allPro?: true
    mvp?: true
    superBowlMVP?: true
    playoffAppearance?: true
  }

  export type PerformanceBonusCountAggregateInputType = {
    id?: true
    clauseId?: true
    proBowl?: true
    allPro?: true
    mvp?: true
    superBowlMVP?: true
    playoffAppearance?: true
    _all?: true
  }

  export type PerformanceBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceBonus to aggregate.
     */
    where?: PerformanceBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceBonuses to fetch.
     */
    orderBy?: PerformanceBonusOrderByWithRelationInput | PerformanceBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceBonuses
    **/
    _count?: true | PerformanceBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceBonusMaxAggregateInputType
  }

  export type GetPerformanceBonusAggregateType<T extends PerformanceBonusAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceBonus[P]>
      : GetScalarType<T[P], AggregatePerformanceBonus[P]>
  }




  export type PerformanceBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceBonusWhereInput
    orderBy?: PerformanceBonusOrderByWithAggregationInput | PerformanceBonusOrderByWithAggregationInput[]
    by: PerformanceBonusScalarFieldEnum[] | PerformanceBonusScalarFieldEnum
    having?: PerformanceBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceBonusCountAggregateInputType | true
    _avg?: PerformanceBonusAvgAggregateInputType
    _sum?: PerformanceBonusSumAggregateInputType
    _min?: PerformanceBonusMinAggregateInputType
    _max?: PerformanceBonusMaxAggregateInputType
  }

  export type PerformanceBonusGroupByOutputType = {
    id: string
    clauseId: string
    proBowl: number | null
    allPro: number | null
    mvp: number | null
    superBowlMVP: number | null
    playoffAppearance: number | null
    _count: PerformanceBonusCountAggregateOutputType | null
    _avg: PerformanceBonusAvgAggregateOutputType | null
    _sum: PerformanceBonusSumAggregateOutputType | null
    _min: PerformanceBonusMinAggregateOutputType | null
    _max: PerformanceBonusMaxAggregateOutputType | null
  }

  type GetPerformanceBonusGroupByPayload<T extends PerformanceBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceBonusGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceBonusGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    proBowl?: boolean
    allPro?: boolean
    mvp?: boolean
    superBowlMVP?: boolean
    playoffAppearance?: boolean
    clauses?: boolean | ContractClauseDefaultArgs<ExtArgs>
    statMilestones?: boolean | PerformanceBonus$statMilestonesArgs<ExtArgs>
  }, ExtArgs["result"]["performanceBonus"]>

  export type PerformanceBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    proBowl?: boolean
    allPro?: boolean
    mvp?: boolean
    superBowlMVP?: boolean
    playoffAppearance?: boolean
    clauses?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceBonus"]>

  export type PerformanceBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    proBowl?: boolean
    allPro?: boolean
    mvp?: boolean
    superBowlMVP?: boolean
    playoffAppearance?: boolean
    clauses?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceBonus"]>

  export type PerformanceBonusSelectScalar = {
    id?: boolean
    clauseId?: boolean
    proBowl?: boolean
    allPro?: boolean
    mvp?: boolean
    superBowlMVP?: boolean
    playoffAppearance?: boolean
  }

  export type PerformanceBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clauseId" | "proBowl" | "allPro" | "mvp" | "superBowlMVP" | "playoffAppearance", ExtArgs["result"]["performanceBonus"]>
  export type PerformanceBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clauses?: boolean | ContractClauseDefaultArgs<ExtArgs>
    statMilestones?: boolean | PerformanceBonus$statMilestonesArgs<ExtArgs>
  }
  export type PerformanceBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clauses?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type PerformanceBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clauses?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }

  export type $PerformanceBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceBonus"
    objects: {
      clauses: Prisma.$ContractClausePayload<ExtArgs>
      statMilestones: Prisma.$StatMilestonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clauseId: string
      proBowl: number | null
      allPro: number | null
      mvp: number | null
      superBowlMVP: number | null
      playoffAppearance: number | null
    }, ExtArgs["result"]["performanceBonus"]>
    composites: {}
  }

  type PerformanceBonusGetPayload<S extends boolean | null | undefined | PerformanceBonusDefaultArgs> = $Result.GetResult<Prisma.$PerformanceBonusPayload, S>

  type PerformanceBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceBonusCountAggregateInputType | true
    }

  export interface PerformanceBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceBonus'], meta: { name: 'PerformanceBonus' } }
    /**
     * Find zero or one PerformanceBonus that matches the filter.
     * @param {PerformanceBonusFindUniqueArgs} args - Arguments to find a PerformanceBonus
     * @example
     * // Get one PerformanceBonus
     * const performanceBonus = await prisma.performanceBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceBonusFindUniqueArgs>(args: SelectSubset<T, PerformanceBonusFindUniqueArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceBonusFindUniqueOrThrowArgs} args - Arguments to find a PerformanceBonus
     * @example
     * // Get one PerformanceBonus
     * const performanceBonus = await prisma.performanceBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusFindFirstArgs} args - Arguments to find a PerformanceBonus
     * @example
     * // Get one PerformanceBonus
     * const performanceBonus = await prisma.performanceBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceBonusFindFirstArgs>(args?: SelectSubset<T, PerformanceBonusFindFirstArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusFindFirstOrThrowArgs} args - Arguments to find a PerformanceBonus
     * @example
     * // Get one PerformanceBonus
     * const performanceBonus = await prisma.performanceBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceBonuses
     * const performanceBonuses = await prisma.performanceBonus.findMany()
     * 
     * // Get first 10 PerformanceBonuses
     * const performanceBonuses = await prisma.performanceBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceBonusWithIdOnly = await prisma.performanceBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceBonusFindManyArgs>(args?: SelectSubset<T, PerformanceBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceBonus.
     * @param {PerformanceBonusCreateArgs} args - Arguments to create a PerformanceBonus.
     * @example
     * // Create one PerformanceBonus
     * const PerformanceBonus = await prisma.performanceBonus.create({
     *   data: {
     *     // ... data to create a PerformanceBonus
     *   }
     * })
     * 
     */
    create<T extends PerformanceBonusCreateArgs>(args: SelectSubset<T, PerformanceBonusCreateArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceBonuses.
     * @param {PerformanceBonusCreateManyArgs} args - Arguments to create many PerformanceBonuses.
     * @example
     * // Create many PerformanceBonuses
     * const performanceBonus = await prisma.performanceBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceBonusCreateManyArgs>(args?: SelectSubset<T, PerformanceBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceBonuses and returns the data saved in the database.
     * @param {PerformanceBonusCreateManyAndReturnArgs} args - Arguments to create many PerformanceBonuses.
     * @example
     * // Create many PerformanceBonuses
     * const performanceBonus = await prisma.performanceBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceBonuses and only return the `id`
     * const performanceBonusWithIdOnly = await prisma.performanceBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceBonus.
     * @param {PerformanceBonusDeleteArgs} args - Arguments to delete one PerformanceBonus.
     * @example
     * // Delete one PerformanceBonus
     * const PerformanceBonus = await prisma.performanceBonus.delete({
     *   where: {
     *     // ... filter to delete one PerformanceBonus
     *   }
     * })
     * 
     */
    delete<T extends PerformanceBonusDeleteArgs>(args: SelectSubset<T, PerformanceBonusDeleteArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceBonus.
     * @param {PerformanceBonusUpdateArgs} args - Arguments to update one PerformanceBonus.
     * @example
     * // Update one PerformanceBonus
     * const performanceBonus = await prisma.performanceBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceBonusUpdateArgs>(args: SelectSubset<T, PerformanceBonusUpdateArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceBonuses.
     * @param {PerformanceBonusDeleteManyArgs} args - Arguments to filter PerformanceBonuses to delete.
     * @example
     * // Delete a few PerformanceBonuses
     * const { count } = await prisma.performanceBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceBonusDeleteManyArgs>(args?: SelectSubset<T, PerformanceBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceBonuses
     * const performanceBonus = await prisma.performanceBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceBonusUpdateManyArgs>(args: SelectSubset<T, PerformanceBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceBonuses and returns the data updated in the database.
     * @param {PerformanceBonusUpdateManyAndReturnArgs} args - Arguments to update many PerformanceBonuses.
     * @example
     * // Update many PerformanceBonuses
     * const performanceBonus = await prisma.performanceBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceBonuses and only return the `id`
     * const performanceBonusWithIdOnly = await prisma.performanceBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceBonus.
     * @param {PerformanceBonusUpsertArgs} args - Arguments to update or create a PerformanceBonus.
     * @example
     * // Update or create a PerformanceBonus
     * const performanceBonus = await prisma.performanceBonus.upsert({
     *   create: {
     *     // ... data to create a PerformanceBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceBonus we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceBonusUpsertArgs>(args: SelectSubset<T, PerformanceBonusUpsertArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusCountArgs} args - Arguments to filter PerformanceBonuses to count.
     * @example
     * // Count the number of PerformanceBonuses
     * const count = await prisma.performanceBonus.count({
     *   where: {
     *     // ... the filter for the PerformanceBonuses we want to count
     *   }
     * })
    **/
    count<T extends PerformanceBonusCountArgs>(
      args?: Subset<T, PerformanceBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceBonusAggregateArgs>(args: Subset<T, PerformanceBonusAggregateArgs>): Prisma.PrismaPromise<GetPerformanceBonusAggregateType<T>>

    /**
     * Group by PerformanceBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceBonusGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceBonus model
   */
  readonly fields: PerformanceBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clauses<T extends ContractClauseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractClauseDefaultArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    statMilestones<T extends PerformanceBonus$statMilestonesArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceBonus$statMilestonesArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceBonus model
   */
  interface PerformanceBonusFieldRefs {
    readonly id: FieldRef<"PerformanceBonus", 'String'>
    readonly clauseId: FieldRef<"PerformanceBonus", 'String'>
    readonly proBowl: FieldRef<"PerformanceBonus", 'Int'>
    readonly allPro: FieldRef<"PerformanceBonus", 'Int'>
    readonly mvp: FieldRef<"PerformanceBonus", 'Int'>
    readonly superBowlMVP: FieldRef<"PerformanceBonus", 'Int'>
    readonly playoffAppearance: FieldRef<"PerformanceBonus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceBonus findUnique
   */
  export type PerformanceBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceBonus to fetch.
     */
    where: PerformanceBonusWhereUniqueInput
  }

  /**
   * PerformanceBonus findUniqueOrThrow
   */
  export type PerformanceBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceBonus to fetch.
     */
    where: PerformanceBonusWhereUniqueInput
  }

  /**
   * PerformanceBonus findFirst
   */
  export type PerformanceBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceBonus to fetch.
     */
    where?: PerformanceBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceBonuses to fetch.
     */
    orderBy?: PerformanceBonusOrderByWithRelationInput | PerformanceBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceBonuses.
     */
    cursor?: PerformanceBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceBonuses.
     */
    distinct?: PerformanceBonusScalarFieldEnum | PerformanceBonusScalarFieldEnum[]
  }

  /**
   * PerformanceBonus findFirstOrThrow
   */
  export type PerformanceBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceBonus to fetch.
     */
    where?: PerformanceBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceBonuses to fetch.
     */
    orderBy?: PerformanceBonusOrderByWithRelationInput | PerformanceBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceBonuses.
     */
    cursor?: PerformanceBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceBonuses.
     */
    distinct?: PerformanceBonusScalarFieldEnum | PerformanceBonusScalarFieldEnum[]
  }

  /**
   * PerformanceBonus findMany
   */
  export type PerformanceBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceBonuses to fetch.
     */
    where?: PerformanceBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceBonuses to fetch.
     */
    orderBy?: PerformanceBonusOrderByWithRelationInput | PerformanceBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceBonuses.
     */
    cursor?: PerformanceBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceBonuses.
     */
    skip?: number
    distinct?: PerformanceBonusScalarFieldEnum | PerformanceBonusScalarFieldEnum[]
  }

  /**
   * PerformanceBonus create
   */
  export type PerformanceBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceBonus.
     */
    data: XOR<PerformanceBonusCreateInput, PerformanceBonusUncheckedCreateInput>
  }

  /**
   * PerformanceBonus createMany
   */
  export type PerformanceBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceBonuses.
     */
    data: PerformanceBonusCreateManyInput | PerformanceBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceBonus createManyAndReturn
   */
  export type PerformanceBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceBonuses.
     */
    data: PerformanceBonusCreateManyInput | PerformanceBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceBonus update
   */
  export type PerformanceBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceBonus.
     */
    data: XOR<PerformanceBonusUpdateInput, PerformanceBonusUncheckedUpdateInput>
    /**
     * Choose, which PerformanceBonus to update.
     */
    where: PerformanceBonusWhereUniqueInput
  }

  /**
   * PerformanceBonus updateMany
   */
  export type PerformanceBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceBonuses.
     */
    data: XOR<PerformanceBonusUpdateManyMutationInput, PerformanceBonusUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceBonuses to update
     */
    where?: PerformanceBonusWhereInput
    /**
     * Limit how many PerformanceBonuses to update.
     */
    limit?: number
  }

  /**
   * PerformanceBonus updateManyAndReturn
   */
  export type PerformanceBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceBonuses.
     */
    data: XOR<PerformanceBonusUpdateManyMutationInput, PerformanceBonusUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceBonuses to update
     */
    where?: PerformanceBonusWhereInput
    /**
     * Limit how many PerformanceBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceBonus upsert
   */
  export type PerformanceBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceBonus to update in case it exists.
     */
    where: PerformanceBonusWhereUniqueInput
    /**
     * In case the PerformanceBonus found by the `where` argument doesn't exist, create a new PerformanceBonus with this data.
     */
    create: XOR<PerformanceBonusCreateInput, PerformanceBonusUncheckedCreateInput>
    /**
     * In case the PerformanceBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceBonusUpdateInput, PerformanceBonusUncheckedUpdateInput>
  }

  /**
   * PerformanceBonus delete
   */
  export type PerformanceBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
    /**
     * Filter which PerformanceBonus to delete.
     */
    where: PerformanceBonusWhereUniqueInput
  }

  /**
   * PerformanceBonus deleteMany
   */
  export type PerformanceBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceBonuses to delete
     */
    where?: PerformanceBonusWhereInput
    /**
     * Limit how many PerformanceBonuses to delete.
     */
    limit?: number
  }

  /**
   * PerformanceBonus.statMilestones
   */
  export type PerformanceBonus$statMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    where?: StatMilestoneWhereInput
  }

  /**
   * PerformanceBonus without action
   */
  export type PerformanceBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceBonus
     */
    select?: PerformanceBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceBonus
     */
    omit?: PerformanceBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceBonusInclude<ExtArgs> | null
  }


  /**
   * Model StatMilestone
   */

  export type AggregateStatMilestone = {
    _count: StatMilestoneCountAggregateOutputType | null
    _avg: StatMilestoneAvgAggregateOutputType | null
    _sum: StatMilestoneSumAggregateOutputType | null
    _min: StatMilestoneMinAggregateOutputType | null
    _max: StatMilestoneMaxAggregateOutputType | null
  }

  export type StatMilestoneAvgAggregateOutputType = {
    yards: number | null
    touchdowns: number | null
    sacks: number | null
    interceptions: number | null
  }

  export type StatMilestoneSumAggregateOutputType = {
    yards: number | null
    touchdowns: number | null
    sacks: number | null
    interceptions: number | null
  }

  export type StatMilestoneMinAggregateOutputType = {
    id: string | null
    performanceId: string | null
    yards: number | null
    touchdowns: number | null
    sacks: number | null
    interceptions: number | null
  }

  export type StatMilestoneMaxAggregateOutputType = {
    id: string | null
    performanceId: string | null
    yards: number | null
    touchdowns: number | null
    sacks: number | null
    interceptions: number | null
  }

  export type StatMilestoneCountAggregateOutputType = {
    id: number
    performanceId: number
    yards: number
    touchdowns: number
    sacks: number
    interceptions: number
    _all: number
  }


  export type StatMilestoneAvgAggregateInputType = {
    yards?: true
    touchdowns?: true
    sacks?: true
    interceptions?: true
  }

  export type StatMilestoneSumAggregateInputType = {
    yards?: true
    touchdowns?: true
    sacks?: true
    interceptions?: true
  }

  export type StatMilestoneMinAggregateInputType = {
    id?: true
    performanceId?: true
    yards?: true
    touchdowns?: true
    sacks?: true
    interceptions?: true
  }

  export type StatMilestoneMaxAggregateInputType = {
    id?: true
    performanceId?: true
    yards?: true
    touchdowns?: true
    sacks?: true
    interceptions?: true
  }

  export type StatMilestoneCountAggregateInputType = {
    id?: true
    performanceId?: true
    yards?: true
    touchdowns?: true
    sacks?: true
    interceptions?: true
    _all?: true
  }

  export type StatMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatMilestone to aggregate.
     */
    where?: StatMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatMilestones to fetch.
     */
    orderBy?: StatMilestoneOrderByWithRelationInput | StatMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatMilestones
    **/
    _count?: true | StatMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatMilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatMilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatMilestoneMaxAggregateInputType
  }

  export type GetStatMilestoneAggregateType<T extends StatMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateStatMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatMilestone[P]>
      : GetScalarType<T[P], AggregateStatMilestone[P]>
  }




  export type StatMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatMilestoneWhereInput
    orderBy?: StatMilestoneOrderByWithAggregationInput | StatMilestoneOrderByWithAggregationInput[]
    by: StatMilestoneScalarFieldEnum[] | StatMilestoneScalarFieldEnum
    having?: StatMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatMilestoneCountAggregateInputType | true
    _avg?: StatMilestoneAvgAggregateInputType
    _sum?: StatMilestoneSumAggregateInputType
    _min?: StatMilestoneMinAggregateInputType
    _max?: StatMilestoneMaxAggregateInputType
  }

  export type StatMilestoneGroupByOutputType = {
    id: string
    performanceId: string
    yards: number | null
    touchdowns: number | null
    sacks: number | null
    interceptions: number | null
    _count: StatMilestoneCountAggregateOutputType | null
    _avg: StatMilestoneAvgAggregateOutputType | null
    _sum: StatMilestoneSumAggregateOutputType | null
    _min: StatMilestoneMinAggregateOutputType | null
    _max: StatMilestoneMaxAggregateOutputType | null
  }

  type GetStatMilestoneGroupByPayload<T extends StatMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], StatMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type StatMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    performanceId?: boolean
    yards?: boolean
    touchdowns?: boolean
    sacks?: boolean
    interceptions?: boolean
    performanceBonus?: boolean | PerformanceBonusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statMilestone"]>

  export type StatMilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    performanceId?: boolean
    yards?: boolean
    touchdowns?: boolean
    sacks?: boolean
    interceptions?: boolean
    performanceBonus?: boolean | PerformanceBonusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statMilestone"]>

  export type StatMilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    performanceId?: boolean
    yards?: boolean
    touchdowns?: boolean
    sacks?: boolean
    interceptions?: boolean
    performanceBonus?: boolean | PerformanceBonusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statMilestone"]>

  export type StatMilestoneSelectScalar = {
    id?: boolean
    performanceId?: boolean
    yards?: boolean
    touchdowns?: boolean
    sacks?: boolean
    interceptions?: boolean
  }

  export type StatMilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "performanceId" | "yards" | "touchdowns" | "sacks" | "interceptions", ExtArgs["result"]["statMilestone"]>
  export type StatMilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performanceBonus?: boolean | PerformanceBonusDefaultArgs<ExtArgs>
  }
  export type StatMilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performanceBonus?: boolean | PerformanceBonusDefaultArgs<ExtArgs>
  }
  export type StatMilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performanceBonus?: boolean | PerformanceBonusDefaultArgs<ExtArgs>
  }

  export type $StatMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatMilestone"
    objects: {
      performanceBonus: Prisma.$PerformanceBonusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      performanceId: string
      yards: number | null
      touchdowns: number | null
      sacks: number | null
      interceptions: number | null
    }, ExtArgs["result"]["statMilestone"]>
    composites: {}
  }

  type StatMilestoneGetPayload<S extends boolean | null | undefined | StatMilestoneDefaultArgs> = $Result.GetResult<Prisma.$StatMilestonePayload, S>

  type StatMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatMilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatMilestoneCountAggregateInputType | true
    }

  export interface StatMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatMilestone'], meta: { name: 'StatMilestone' } }
    /**
     * Find zero or one StatMilestone that matches the filter.
     * @param {StatMilestoneFindUniqueArgs} args - Arguments to find a StatMilestone
     * @example
     * // Get one StatMilestone
     * const statMilestone = await prisma.statMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatMilestoneFindUniqueArgs>(args: SelectSubset<T, StatMilestoneFindUniqueArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StatMilestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatMilestoneFindUniqueOrThrowArgs} args - Arguments to find a StatMilestone
     * @example
     * // Get one StatMilestone
     * const statMilestone = await prisma.statMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, StatMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneFindFirstArgs} args - Arguments to find a StatMilestone
     * @example
     * // Get one StatMilestone
     * const statMilestone = await prisma.statMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatMilestoneFindFirstArgs>(args?: SelectSubset<T, StatMilestoneFindFirstArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneFindFirstOrThrowArgs} args - Arguments to find a StatMilestone
     * @example
     * // Get one StatMilestone
     * const statMilestone = await prisma.statMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, StatMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StatMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatMilestones
     * const statMilestones = await prisma.statMilestone.findMany()
     * 
     * // Get first 10 StatMilestones
     * const statMilestones = await prisma.statMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statMilestoneWithIdOnly = await prisma.statMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatMilestoneFindManyArgs>(args?: SelectSubset<T, StatMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StatMilestone.
     * @param {StatMilestoneCreateArgs} args - Arguments to create a StatMilestone.
     * @example
     * // Create one StatMilestone
     * const StatMilestone = await prisma.statMilestone.create({
     *   data: {
     *     // ... data to create a StatMilestone
     *   }
     * })
     * 
     */
    create<T extends StatMilestoneCreateArgs>(args: SelectSubset<T, StatMilestoneCreateArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StatMilestones.
     * @param {StatMilestoneCreateManyArgs} args - Arguments to create many StatMilestones.
     * @example
     * // Create many StatMilestones
     * const statMilestone = await prisma.statMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatMilestoneCreateManyArgs>(args?: SelectSubset<T, StatMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatMilestones and returns the data saved in the database.
     * @param {StatMilestoneCreateManyAndReturnArgs} args - Arguments to create many StatMilestones.
     * @example
     * // Create many StatMilestones
     * const statMilestone = await prisma.statMilestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatMilestones and only return the `id`
     * const statMilestoneWithIdOnly = await prisma.statMilestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatMilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, StatMilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StatMilestone.
     * @param {StatMilestoneDeleteArgs} args - Arguments to delete one StatMilestone.
     * @example
     * // Delete one StatMilestone
     * const StatMilestone = await prisma.statMilestone.delete({
     *   where: {
     *     // ... filter to delete one StatMilestone
     *   }
     * })
     * 
     */
    delete<T extends StatMilestoneDeleteArgs>(args: SelectSubset<T, StatMilestoneDeleteArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StatMilestone.
     * @param {StatMilestoneUpdateArgs} args - Arguments to update one StatMilestone.
     * @example
     * // Update one StatMilestone
     * const statMilestone = await prisma.statMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatMilestoneUpdateArgs>(args: SelectSubset<T, StatMilestoneUpdateArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StatMilestones.
     * @param {StatMilestoneDeleteManyArgs} args - Arguments to filter StatMilestones to delete.
     * @example
     * // Delete a few StatMilestones
     * const { count } = await prisma.statMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatMilestoneDeleteManyArgs>(args?: SelectSubset<T, StatMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatMilestones
     * const statMilestone = await prisma.statMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatMilestoneUpdateManyArgs>(args: SelectSubset<T, StatMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatMilestones and returns the data updated in the database.
     * @param {StatMilestoneUpdateManyAndReturnArgs} args - Arguments to update many StatMilestones.
     * @example
     * // Update many StatMilestones
     * const statMilestone = await prisma.statMilestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StatMilestones and only return the `id`
     * const statMilestoneWithIdOnly = await prisma.statMilestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatMilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, StatMilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StatMilestone.
     * @param {StatMilestoneUpsertArgs} args - Arguments to update or create a StatMilestone.
     * @example
     * // Update or create a StatMilestone
     * const statMilestone = await prisma.statMilestone.upsert({
     *   create: {
     *     // ... data to create a StatMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatMilestone we want to update
     *   }
     * })
     */
    upsert<T extends StatMilestoneUpsertArgs>(args: SelectSubset<T, StatMilestoneUpsertArgs<ExtArgs>>): Prisma__StatMilestoneClient<$Result.GetResult<Prisma.$StatMilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StatMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneCountArgs} args - Arguments to filter StatMilestones to count.
     * @example
     * // Count the number of StatMilestones
     * const count = await prisma.statMilestone.count({
     *   where: {
     *     // ... the filter for the StatMilestones we want to count
     *   }
     * })
    **/
    count<T extends StatMilestoneCountArgs>(
      args?: Subset<T, StatMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatMilestoneAggregateArgs>(args: Subset<T, StatMilestoneAggregateArgs>): Prisma.PrismaPromise<GetStatMilestoneAggregateType<T>>

    /**
     * Group by StatMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: StatMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatMilestone model
   */
  readonly fields: StatMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performanceBonus<T extends PerformanceBonusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceBonusDefaultArgs<ExtArgs>>): Prisma__PerformanceBonusClient<$Result.GetResult<Prisma.$PerformanceBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatMilestone model
   */
  interface StatMilestoneFieldRefs {
    readonly id: FieldRef<"StatMilestone", 'String'>
    readonly performanceId: FieldRef<"StatMilestone", 'String'>
    readonly yards: FieldRef<"StatMilestone", 'Int'>
    readonly touchdowns: FieldRef<"StatMilestone", 'Int'>
    readonly sacks: FieldRef<"StatMilestone", 'Int'>
    readonly interceptions: FieldRef<"StatMilestone", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StatMilestone findUnique
   */
  export type StatMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which StatMilestone to fetch.
     */
    where: StatMilestoneWhereUniqueInput
  }

  /**
   * StatMilestone findUniqueOrThrow
   */
  export type StatMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which StatMilestone to fetch.
     */
    where: StatMilestoneWhereUniqueInput
  }

  /**
   * StatMilestone findFirst
   */
  export type StatMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which StatMilestone to fetch.
     */
    where?: StatMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatMilestones to fetch.
     */
    orderBy?: StatMilestoneOrderByWithRelationInput | StatMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatMilestones.
     */
    cursor?: StatMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatMilestones.
     */
    distinct?: StatMilestoneScalarFieldEnum | StatMilestoneScalarFieldEnum[]
  }

  /**
   * StatMilestone findFirstOrThrow
   */
  export type StatMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which StatMilestone to fetch.
     */
    where?: StatMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatMilestones to fetch.
     */
    orderBy?: StatMilestoneOrderByWithRelationInput | StatMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatMilestones.
     */
    cursor?: StatMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatMilestones.
     */
    distinct?: StatMilestoneScalarFieldEnum | StatMilestoneScalarFieldEnum[]
  }

  /**
   * StatMilestone findMany
   */
  export type StatMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which StatMilestones to fetch.
     */
    where?: StatMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatMilestones to fetch.
     */
    orderBy?: StatMilestoneOrderByWithRelationInput | StatMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatMilestones.
     */
    cursor?: StatMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatMilestones.
     */
    skip?: number
    distinct?: StatMilestoneScalarFieldEnum | StatMilestoneScalarFieldEnum[]
  }

  /**
   * StatMilestone create
   */
  export type StatMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a StatMilestone.
     */
    data: XOR<StatMilestoneCreateInput, StatMilestoneUncheckedCreateInput>
  }

  /**
   * StatMilestone createMany
   */
  export type StatMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatMilestones.
     */
    data: StatMilestoneCreateManyInput | StatMilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatMilestone createManyAndReturn
   */
  export type StatMilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many StatMilestones.
     */
    data: StatMilestoneCreateManyInput | StatMilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatMilestone update
   */
  export type StatMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a StatMilestone.
     */
    data: XOR<StatMilestoneUpdateInput, StatMilestoneUncheckedUpdateInput>
    /**
     * Choose, which StatMilestone to update.
     */
    where: StatMilestoneWhereUniqueInput
  }

  /**
   * StatMilestone updateMany
   */
  export type StatMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatMilestones.
     */
    data: XOR<StatMilestoneUpdateManyMutationInput, StatMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which StatMilestones to update
     */
    where?: StatMilestoneWhereInput
    /**
     * Limit how many StatMilestones to update.
     */
    limit?: number
  }

  /**
   * StatMilestone updateManyAndReturn
   */
  export type StatMilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * The data used to update StatMilestones.
     */
    data: XOR<StatMilestoneUpdateManyMutationInput, StatMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which StatMilestones to update
     */
    where?: StatMilestoneWhereInput
    /**
     * Limit how many StatMilestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatMilestone upsert
   */
  export type StatMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the StatMilestone to update in case it exists.
     */
    where: StatMilestoneWhereUniqueInput
    /**
     * In case the StatMilestone found by the `where` argument doesn't exist, create a new StatMilestone with this data.
     */
    create: XOR<StatMilestoneCreateInput, StatMilestoneUncheckedCreateInput>
    /**
     * In case the StatMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatMilestoneUpdateInput, StatMilestoneUncheckedUpdateInput>
  }

  /**
   * StatMilestone delete
   */
  export type StatMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
    /**
     * Filter which StatMilestone to delete.
     */
    where: StatMilestoneWhereUniqueInput
  }

  /**
   * StatMilestone deleteMany
   */
  export type StatMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatMilestones to delete
     */
    where?: StatMilestoneWhereInput
    /**
     * Limit how many StatMilestones to delete.
     */
    limit?: number
  }

  /**
   * StatMilestone without action
   */
  export type StatMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatMilestone
     */
    select?: StatMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatMilestone
     */
    omit?: StatMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatMilestoneInclude<ExtArgs> | null
  }


  /**
   * Model RosterBonus
   */

  export type AggregateRosterBonus = {
    _count: RosterBonusCountAggregateOutputType | null
    _avg: RosterBonusAvgAggregateOutputType | null
    _sum: RosterBonusSumAggregateOutputType | null
    _min: RosterBonusMinAggregateOutputType | null
    _max: RosterBonusMaxAggregateOutputType | null
  }

  export type RosterBonusAvgAggregateOutputType = {
    amount: number | null
  }

  export type RosterBonusSumAggregateOutputType = {
    amount: number | null
  }

  export type RosterBonusMinAggregateOutputType = {
    id: string | null
    clauseId: string | null
    amount: number | null
    perGame: boolean | null
  }

  export type RosterBonusMaxAggregateOutputType = {
    id: string | null
    clauseId: string | null
    amount: number | null
    perGame: boolean | null
  }

  export type RosterBonusCountAggregateOutputType = {
    id: number
    clauseId: number
    amount: number
    perGame: number
    _all: number
  }


  export type RosterBonusAvgAggregateInputType = {
    amount?: true
  }

  export type RosterBonusSumAggregateInputType = {
    amount?: true
  }

  export type RosterBonusMinAggregateInputType = {
    id?: true
    clauseId?: true
    amount?: true
    perGame?: true
  }

  export type RosterBonusMaxAggregateInputType = {
    id?: true
    clauseId?: true
    amount?: true
    perGame?: true
  }

  export type RosterBonusCountAggregateInputType = {
    id?: true
    clauseId?: true
    amount?: true
    perGame?: true
    _all?: true
  }

  export type RosterBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RosterBonus to aggregate.
     */
    where?: RosterBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterBonuses to fetch.
     */
    orderBy?: RosterBonusOrderByWithRelationInput | RosterBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RosterBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RosterBonuses
    **/
    _count?: true | RosterBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RosterBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RosterBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RosterBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RosterBonusMaxAggregateInputType
  }

  export type GetRosterBonusAggregateType<T extends RosterBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateRosterBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRosterBonus[P]>
      : GetScalarType<T[P], AggregateRosterBonus[P]>
  }




  export type RosterBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RosterBonusWhereInput
    orderBy?: RosterBonusOrderByWithAggregationInput | RosterBonusOrderByWithAggregationInput[]
    by: RosterBonusScalarFieldEnum[] | RosterBonusScalarFieldEnum
    having?: RosterBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RosterBonusCountAggregateInputType | true
    _avg?: RosterBonusAvgAggregateInputType
    _sum?: RosterBonusSumAggregateInputType
    _min?: RosterBonusMinAggregateInputType
    _max?: RosterBonusMaxAggregateInputType
  }

  export type RosterBonusGroupByOutputType = {
    id: string
    clauseId: string
    amount: number | null
    perGame: boolean | null
    _count: RosterBonusCountAggregateOutputType | null
    _avg: RosterBonusAvgAggregateOutputType | null
    _sum: RosterBonusSumAggregateOutputType | null
    _min: RosterBonusMinAggregateOutputType | null
    _max: RosterBonusMaxAggregateOutputType | null
  }

  type GetRosterBonusGroupByPayload<T extends RosterBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RosterBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RosterBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RosterBonusGroupByOutputType[P]>
            : GetScalarType<T[P], RosterBonusGroupByOutputType[P]>
        }
      >
    >


  export type RosterBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    perGame?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rosterBonus"]>

  export type RosterBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    perGame?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rosterBonus"]>

  export type RosterBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    perGame?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rosterBonus"]>

  export type RosterBonusSelectScalar = {
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    perGame?: boolean
  }

  export type RosterBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clauseId" | "amount" | "perGame", ExtArgs["result"]["rosterBonus"]>
  export type RosterBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type RosterBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type RosterBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }

  export type $RosterBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RosterBonus"
    objects: {
      clause: Prisma.$ContractClausePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clauseId: string
      amount: number | null
      perGame: boolean | null
    }, ExtArgs["result"]["rosterBonus"]>
    composites: {}
  }

  type RosterBonusGetPayload<S extends boolean | null | undefined | RosterBonusDefaultArgs> = $Result.GetResult<Prisma.$RosterBonusPayload, S>

  type RosterBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RosterBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RosterBonusCountAggregateInputType | true
    }

  export interface RosterBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RosterBonus'], meta: { name: 'RosterBonus' } }
    /**
     * Find zero or one RosterBonus that matches the filter.
     * @param {RosterBonusFindUniqueArgs} args - Arguments to find a RosterBonus
     * @example
     * // Get one RosterBonus
     * const rosterBonus = await prisma.rosterBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RosterBonusFindUniqueArgs>(args: SelectSubset<T, RosterBonusFindUniqueArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RosterBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RosterBonusFindUniqueOrThrowArgs} args - Arguments to find a RosterBonus
     * @example
     * // Get one RosterBonus
     * const rosterBonus = await prisma.rosterBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RosterBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, RosterBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RosterBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusFindFirstArgs} args - Arguments to find a RosterBonus
     * @example
     * // Get one RosterBonus
     * const rosterBonus = await prisma.rosterBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RosterBonusFindFirstArgs>(args?: SelectSubset<T, RosterBonusFindFirstArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RosterBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusFindFirstOrThrowArgs} args - Arguments to find a RosterBonus
     * @example
     * // Get one RosterBonus
     * const rosterBonus = await prisma.rosterBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RosterBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, RosterBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RosterBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RosterBonuses
     * const rosterBonuses = await prisma.rosterBonus.findMany()
     * 
     * // Get first 10 RosterBonuses
     * const rosterBonuses = await prisma.rosterBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rosterBonusWithIdOnly = await prisma.rosterBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RosterBonusFindManyArgs>(args?: SelectSubset<T, RosterBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RosterBonus.
     * @param {RosterBonusCreateArgs} args - Arguments to create a RosterBonus.
     * @example
     * // Create one RosterBonus
     * const RosterBonus = await prisma.rosterBonus.create({
     *   data: {
     *     // ... data to create a RosterBonus
     *   }
     * })
     * 
     */
    create<T extends RosterBonusCreateArgs>(args: SelectSubset<T, RosterBonusCreateArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RosterBonuses.
     * @param {RosterBonusCreateManyArgs} args - Arguments to create many RosterBonuses.
     * @example
     * // Create many RosterBonuses
     * const rosterBonus = await prisma.rosterBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RosterBonusCreateManyArgs>(args?: SelectSubset<T, RosterBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RosterBonuses and returns the data saved in the database.
     * @param {RosterBonusCreateManyAndReturnArgs} args - Arguments to create many RosterBonuses.
     * @example
     * // Create many RosterBonuses
     * const rosterBonus = await prisma.rosterBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RosterBonuses and only return the `id`
     * const rosterBonusWithIdOnly = await prisma.rosterBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RosterBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, RosterBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RosterBonus.
     * @param {RosterBonusDeleteArgs} args - Arguments to delete one RosterBonus.
     * @example
     * // Delete one RosterBonus
     * const RosterBonus = await prisma.rosterBonus.delete({
     *   where: {
     *     // ... filter to delete one RosterBonus
     *   }
     * })
     * 
     */
    delete<T extends RosterBonusDeleteArgs>(args: SelectSubset<T, RosterBonusDeleteArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RosterBonus.
     * @param {RosterBonusUpdateArgs} args - Arguments to update one RosterBonus.
     * @example
     * // Update one RosterBonus
     * const rosterBonus = await prisma.rosterBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RosterBonusUpdateArgs>(args: SelectSubset<T, RosterBonusUpdateArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RosterBonuses.
     * @param {RosterBonusDeleteManyArgs} args - Arguments to filter RosterBonuses to delete.
     * @example
     * // Delete a few RosterBonuses
     * const { count } = await prisma.rosterBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RosterBonusDeleteManyArgs>(args?: SelectSubset<T, RosterBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RosterBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RosterBonuses
     * const rosterBonus = await prisma.rosterBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RosterBonusUpdateManyArgs>(args: SelectSubset<T, RosterBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RosterBonuses and returns the data updated in the database.
     * @param {RosterBonusUpdateManyAndReturnArgs} args - Arguments to update many RosterBonuses.
     * @example
     * // Update many RosterBonuses
     * const rosterBonus = await prisma.rosterBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RosterBonuses and only return the `id`
     * const rosterBonusWithIdOnly = await prisma.rosterBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RosterBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, RosterBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RosterBonus.
     * @param {RosterBonusUpsertArgs} args - Arguments to update or create a RosterBonus.
     * @example
     * // Update or create a RosterBonus
     * const rosterBonus = await prisma.rosterBonus.upsert({
     *   create: {
     *     // ... data to create a RosterBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RosterBonus we want to update
     *   }
     * })
     */
    upsert<T extends RosterBonusUpsertArgs>(args: SelectSubset<T, RosterBonusUpsertArgs<ExtArgs>>): Prisma__RosterBonusClient<$Result.GetResult<Prisma.$RosterBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RosterBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusCountArgs} args - Arguments to filter RosterBonuses to count.
     * @example
     * // Count the number of RosterBonuses
     * const count = await prisma.rosterBonus.count({
     *   where: {
     *     // ... the filter for the RosterBonuses we want to count
     *   }
     * })
    **/
    count<T extends RosterBonusCountArgs>(
      args?: Subset<T, RosterBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RosterBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RosterBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RosterBonusAggregateArgs>(args: Subset<T, RosterBonusAggregateArgs>): Prisma.PrismaPromise<GetRosterBonusAggregateType<T>>

    /**
     * Group by RosterBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RosterBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RosterBonusGroupByArgs['orderBy'] }
        : { orderBy?: RosterBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RosterBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRosterBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RosterBonus model
   */
  readonly fields: RosterBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RosterBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RosterBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clause<T extends ContractClauseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractClauseDefaultArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RosterBonus model
   */
  interface RosterBonusFieldRefs {
    readonly id: FieldRef<"RosterBonus", 'String'>
    readonly clauseId: FieldRef<"RosterBonus", 'String'>
    readonly amount: FieldRef<"RosterBonus", 'Int'>
    readonly perGame: FieldRef<"RosterBonus", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RosterBonus findUnique
   */
  export type RosterBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * Filter, which RosterBonus to fetch.
     */
    where: RosterBonusWhereUniqueInput
  }

  /**
   * RosterBonus findUniqueOrThrow
   */
  export type RosterBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * Filter, which RosterBonus to fetch.
     */
    where: RosterBonusWhereUniqueInput
  }

  /**
   * RosterBonus findFirst
   */
  export type RosterBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * Filter, which RosterBonus to fetch.
     */
    where?: RosterBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterBonuses to fetch.
     */
    orderBy?: RosterBonusOrderByWithRelationInput | RosterBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RosterBonuses.
     */
    cursor?: RosterBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RosterBonuses.
     */
    distinct?: RosterBonusScalarFieldEnum | RosterBonusScalarFieldEnum[]
  }

  /**
   * RosterBonus findFirstOrThrow
   */
  export type RosterBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * Filter, which RosterBonus to fetch.
     */
    where?: RosterBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterBonuses to fetch.
     */
    orderBy?: RosterBonusOrderByWithRelationInput | RosterBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RosterBonuses.
     */
    cursor?: RosterBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RosterBonuses.
     */
    distinct?: RosterBonusScalarFieldEnum | RosterBonusScalarFieldEnum[]
  }

  /**
   * RosterBonus findMany
   */
  export type RosterBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * Filter, which RosterBonuses to fetch.
     */
    where?: RosterBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterBonuses to fetch.
     */
    orderBy?: RosterBonusOrderByWithRelationInput | RosterBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RosterBonuses.
     */
    cursor?: RosterBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterBonuses.
     */
    skip?: number
    distinct?: RosterBonusScalarFieldEnum | RosterBonusScalarFieldEnum[]
  }

  /**
   * RosterBonus create
   */
  export type RosterBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a RosterBonus.
     */
    data: XOR<RosterBonusCreateInput, RosterBonusUncheckedCreateInput>
  }

  /**
   * RosterBonus createMany
   */
  export type RosterBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RosterBonuses.
     */
    data: RosterBonusCreateManyInput | RosterBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RosterBonus createManyAndReturn
   */
  export type RosterBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * The data used to create many RosterBonuses.
     */
    data: RosterBonusCreateManyInput | RosterBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RosterBonus update
   */
  export type RosterBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a RosterBonus.
     */
    data: XOR<RosterBonusUpdateInput, RosterBonusUncheckedUpdateInput>
    /**
     * Choose, which RosterBonus to update.
     */
    where: RosterBonusWhereUniqueInput
  }

  /**
   * RosterBonus updateMany
   */
  export type RosterBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RosterBonuses.
     */
    data: XOR<RosterBonusUpdateManyMutationInput, RosterBonusUncheckedUpdateManyInput>
    /**
     * Filter which RosterBonuses to update
     */
    where?: RosterBonusWhereInput
    /**
     * Limit how many RosterBonuses to update.
     */
    limit?: number
  }

  /**
   * RosterBonus updateManyAndReturn
   */
  export type RosterBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * The data used to update RosterBonuses.
     */
    data: XOR<RosterBonusUpdateManyMutationInput, RosterBonusUncheckedUpdateManyInput>
    /**
     * Filter which RosterBonuses to update
     */
    where?: RosterBonusWhereInput
    /**
     * Limit how many RosterBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RosterBonus upsert
   */
  export type RosterBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the RosterBonus to update in case it exists.
     */
    where: RosterBonusWhereUniqueInput
    /**
     * In case the RosterBonus found by the `where` argument doesn't exist, create a new RosterBonus with this data.
     */
    create: XOR<RosterBonusCreateInput, RosterBonusUncheckedCreateInput>
    /**
     * In case the RosterBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RosterBonusUpdateInput, RosterBonusUncheckedUpdateInput>
  }

  /**
   * RosterBonus delete
   */
  export type RosterBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
    /**
     * Filter which RosterBonus to delete.
     */
    where: RosterBonusWhereUniqueInput
  }

  /**
   * RosterBonus deleteMany
   */
  export type RosterBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RosterBonuses to delete
     */
    where?: RosterBonusWhereInput
    /**
     * Limit how many RosterBonuses to delete.
     */
    limit?: number
  }

  /**
   * RosterBonus without action
   */
  export type RosterBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterBonus
     */
    select?: RosterBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterBonus
     */
    omit?: RosterBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterBonusInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutBonus
   */

  export type AggregateWorkoutBonus = {
    _count: WorkoutBonusCountAggregateOutputType | null
    _avg: WorkoutBonusAvgAggregateOutputType | null
    _sum: WorkoutBonusSumAggregateOutputType | null
    _min: WorkoutBonusMinAggregateOutputType | null
    _max: WorkoutBonusMaxAggregateOutputType | null
  }

  export type WorkoutBonusAvgAggregateOutputType = {
    amount: number | null
    minWorkouts: number | null
  }

  export type WorkoutBonusSumAggregateOutputType = {
    amount: number | null
    minWorkouts: number | null
  }

  export type WorkoutBonusMinAggregateOutputType = {
    id: string | null
    clauseId: string | null
    amount: number | null
    minWorkouts: number | null
  }

  export type WorkoutBonusMaxAggregateOutputType = {
    id: string | null
    clauseId: string | null
    amount: number | null
    minWorkouts: number | null
  }

  export type WorkoutBonusCountAggregateOutputType = {
    id: number
    clauseId: number
    amount: number
    minWorkouts: number
    _all: number
  }


  export type WorkoutBonusAvgAggregateInputType = {
    amount?: true
    minWorkouts?: true
  }

  export type WorkoutBonusSumAggregateInputType = {
    amount?: true
    minWorkouts?: true
  }

  export type WorkoutBonusMinAggregateInputType = {
    id?: true
    clauseId?: true
    amount?: true
    minWorkouts?: true
  }

  export type WorkoutBonusMaxAggregateInputType = {
    id?: true
    clauseId?: true
    amount?: true
    minWorkouts?: true
  }

  export type WorkoutBonusCountAggregateInputType = {
    id?: true
    clauseId?: true
    amount?: true
    minWorkouts?: true
    _all?: true
  }

  export type WorkoutBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutBonus to aggregate.
     */
    where?: WorkoutBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutBonuses to fetch.
     */
    orderBy?: WorkoutBonusOrderByWithRelationInput | WorkoutBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutBonuses
    **/
    _count?: true | WorkoutBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutBonusMaxAggregateInputType
  }

  export type GetWorkoutBonusAggregateType<T extends WorkoutBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutBonus[P]>
      : GetScalarType<T[P], AggregateWorkoutBonus[P]>
  }




  export type WorkoutBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutBonusWhereInput
    orderBy?: WorkoutBonusOrderByWithAggregationInput | WorkoutBonusOrderByWithAggregationInput[]
    by: WorkoutBonusScalarFieldEnum[] | WorkoutBonusScalarFieldEnum
    having?: WorkoutBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutBonusCountAggregateInputType | true
    _avg?: WorkoutBonusAvgAggregateInputType
    _sum?: WorkoutBonusSumAggregateInputType
    _min?: WorkoutBonusMinAggregateInputType
    _max?: WorkoutBonusMaxAggregateInputType
  }

  export type WorkoutBonusGroupByOutputType = {
    id: string
    clauseId: string
    amount: number | null
    minWorkouts: number | null
    _count: WorkoutBonusCountAggregateOutputType | null
    _avg: WorkoutBonusAvgAggregateOutputType | null
    _sum: WorkoutBonusSumAggregateOutputType | null
    _min: WorkoutBonusMinAggregateOutputType | null
    _max: WorkoutBonusMaxAggregateOutputType | null
  }

  type GetWorkoutBonusGroupByPayload<T extends WorkoutBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutBonusGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutBonusGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    minWorkouts?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutBonus"]>

  export type WorkoutBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    minWorkouts?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutBonus"]>

  export type WorkoutBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    minWorkouts?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutBonus"]>

  export type WorkoutBonusSelectScalar = {
    id?: boolean
    clauseId?: boolean
    amount?: boolean
    minWorkouts?: boolean
  }

  export type WorkoutBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clauseId" | "amount" | "minWorkouts", ExtArgs["result"]["workoutBonus"]>
  export type WorkoutBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type WorkoutBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type WorkoutBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }

  export type $WorkoutBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutBonus"
    objects: {
      clause: Prisma.$ContractClausePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clauseId: string
      amount: number | null
      minWorkouts: number | null
    }, ExtArgs["result"]["workoutBonus"]>
    composites: {}
  }

  type WorkoutBonusGetPayload<S extends boolean | null | undefined | WorkoutBonusDefaultArgs> = $Result.GetResult<Prisma.$WorkoutBonusPayload, S>

  type WorkoutBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutBonusCountAggregateInputType | true
    }

  export interface WorkoutBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutBonus'], meta: { name: 'WorkoutBonus' } }
    /**
     * Find zero or one WorkoutBonus that matches the filter.
     * @param {WorkoutBonusFindUniqueArgs} args - Arguments to find a WorkoutBonus
     * @example
     * // Get one WorkoutBonus
     * const workoutBonus = await prisma.workoutBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutBonusFindUniqueArgs>(args: SelectSubset<T, WorkoutBonusFindUniqueArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutBonusFindUniqueOrThrowArgs} args - Arguments to find a WorkoutBonus
     * @example
     * // Get one WorkoutBonus
     * const workoutBonus = await prisma.workoutBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusFindFirstArgs} args - Arguments to find a WorkoutBonus
     * @example
     * // Get one WorkoutBonus
     * const workoutBonus = await prisma.workoutBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutBonusFindFirstArgs>(args?: SelectSubset<T, WorkoutBonusFindFirstArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusFindFirstOrThrowArgs} args - Arguments to find a WorkoutBonus
     * @example
     * // Get one WorkoutBonus
     * const workoutBonus = await prisma.workoutBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutBonuses
     * const workoutBonuses = await prisma.workoutBonus.findMany()
     * 
     * // Get first 10 WorkoutBonuses
     * const workoutBonuses = await prisma.workoutBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutBonusWithIdOnly = await prisma.workoutBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutBonusFindManyArgs>(args?: SelectSubset<T, WorkoutBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutBonus.
     * @param {WorkoutBonusCreateArgs} args - Arguments to create a WorkoutBonus.
     * @example
     * // Create one WorkoutBonus
     * const WorkoutBonus = await prisma.workoutBonus.create({
     *   data: {
     *     // ... data to create a WorkoutBonus
     *   }
     * })
     * 
     */
    create<T extends WorkoutBonusCreateArgs>(args: SelectSubset<T, WorkoutBonusCreateArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutBonuses.
     * @param {WorkoutBonusCreateManyArgs} args - Arguments to create many WorkoutBonuses.
     * @example
     * // Create many WorkoutBonuses
     * const workoutBonus = await prisma.workoutBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutBonusCreateManyArgs>(args?: SelectSubset<T, WorkoutBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutBonuses and returns the data saved in the database.
     * @param {WorkoutBonusCreateManyAndReturnArgs} args - Arguments to create many WorkoutBonuses.
     * @example
     * // Create many WorkoutBonuses
     * const workoutBonus = await prisma.workoutBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutBonuses and only return the `id`
     * const workoutBonusWithIdOnly = await prisma.workoutBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutBonus.
     * @param {WorkoutBonusDeleteArgs} args - Arguments to delete one WorkoutBonus.
     * @example
     * // Delete one WorkoutBonus
     * const WorkoutBonus = await prisma.workoutBonus.delete({
     *   where: {
     *     // ... filter to delete one WorkoutBonus
     *   }
     * })
     * 
     */
    delete<T extends WorkoutBonusDeleteArgs>(args: SelectSubset<T, WorkoutBonusDeleteArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutBonus.
     * @param {WorkoutBonusUpdateArgs} args - Arguments to update one WorkoutBonus.
     * @example
     * // Update one WorkoutBonus
     * const workoutBonus = await prisma.workoutBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutBonusUpdateArgs>(args: SelectSubset<T, WorkoutBonusUpdateArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutBonuses.
     * @param {WorkoutBonusDeleteManyArgs} args - Arguments to filter WorkoutBonuses to delete.
     * @example
     * // Delete a few WorkoutBonuses
     * const { count } = await prisma.workoutBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutBonusDeleteManyArgs>(args?: SelectSubset<T, WorkoutBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutBonuses
     * const workoutBonus = await prisma.workoutBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutBonusUpdateManyArgs>(args: SelectSubset<T, WorkoutBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutBonuses and returns the data updated in the database.
     * @param {WorkoutBonusUpdateManyAndReturnArgs} args - Arguments to update many WorkoutBonuses.
     * @example
     * // Update many WorkoutBonuses
     * const workoutBonus = await prisma.workoutBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutBonuses and only return the `id`
     * const workoutBonusWithIdOnly = await prisma.workoutBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutBonus.
     * @param {WorkoutBonusUpsertArgs} args - Arguments to update or create a WorkoutBonus.
     * @example
     * // Update or create a WorkoutBonus
     * const workoutBonus = await prisma.workoutBonus.upsert({
     *   create: {
     *     // ... data to create a WorkoutBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutBonus we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutBonusUpsertArgs>(args: SelectSubset<T, WorkoutBonusUpsertArgs<ExtArgs>>): Prisma__WorkoutBonusClient<$Result.GetResult<Prisma.$WorkoutBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusCountArgs} args - Arguments to filter WorkoutBonuses to count.
     * @example
     * // Count the number of WorkoutBonuses
     * const count = await prisma.workoutBonus.count({
     *   where: {
     *     // ... the filter for the WorkoutBonuses we want to count
     *   }
     * })
    **/
    count<T extends WorkoutBonusCountArgs>(
      args?: Subset<T, WorkoutBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutBonusAggregateArgs>(args: Subset<T, WorkoutBonusAggregateArgs>): Prisma.PrismaPromise<GetWorkoutBonusAggregateType<T>>

    /**
     * Group by WorkoutBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutBonusGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutBonus model
   */
  readonly fields: WorkoutBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clause<T extends ContractClauseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractClauseDefaultArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutBonus model
   */
  interface WorkoutBonusFieldRefs {
    readonly id: FieldRef<"WorkoutBonus", 'String'>
    readonly clauseId: FieldRef<"WorkoutBonus", 'String'>
    readonly amount: FieldRef<"WorkoutBonus", 'Int'>
    readonly minWorkouts: FieldRef<"WorkoutBonus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutBonus findUnique
   */
  export type WorkoutBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutBonus to fetch.
     */
    where: WorkoutBonusWhereUniqueInput
  }

  /**
   * WorkoutBonus findUniqueOrThrow
   */
  export type WorkoutBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutBonus to fetch.
     */
    where: WorkoutBonusWhereUniqueInput
  }

  /**
   * WorkoutBonus findFirst
   */
  export type WorkoutBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutBonus to fetch.
     */
    where?: WorkoutBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutBonuses to fetch.
     */
    orderBy?: WorkoutBonusOrderByWithRelationInput | WorkoutBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutBonuses.
     */
    cursor?: WorkoutBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutBonuses.
     */
    distinct?: WorkoutBonusScalarFieldEnum | WorkoutBonusScalarFieldEnum[]
  }

  /**
   * WorkoutBonus findFirstOrThrow
   */
  export type WorkoutBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutBonus to fetch.
     */
    where?: WorkoutBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutBonuses to fetch.
     */
    orderBy?: WorkoutBonusOrderByWithRelationInput | WorkoutBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutBonuses.
     */
    cursor?: WorkoutBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutBonuses.
     */
    distinct?: WorkoutBonusScalarFieldEnum | WorkoutBonusScalarFieldEnum[]
  }

  /**
   * WorkoutBonus findMany
   */
  export type WorkoutBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutBonuses to fetch.
     */
    where?: WorkoutBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutBonuses to fetch.
     */
    orderBy?: WorkoutBonusOrderByWithRelationInput | WorkoutBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutBonuses.
     */
    cursor?: WorkoutBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutBonuses.
     */
    skip?: number
    distinct?: WorkoutBonusScalarFieldEnum | WorkoutBonusScalarFieldEnum[]
  }

  /**
   * WorkoutBonus create
   */
  export type WorkoutBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutBonus.
     */
    data: XOR<WorkoutBonusCreateInput, WorkoutBonusUncheckedCreateInput>
  }

  /**
   * WorkoutBonus createMany
   */
  export type WorkoutBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutBonuses.
     */
    data: WorkoutBonusCreateManyInput | WorkoutBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutBonus createManyAndReturn
   */
  export type WorkoutBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutBonuses.
     */
    data: WorkoutBonusCreateManyInput | WorkoutBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutBonus update
   */
  export type WorkoutBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutBonus.
     */
    data: XOR<WorkoutBonusUpdateInput, WorkoutBonusUncheckedUpdateInput>
    /**
     * Choose, which WorkoutBonus to update.
     */
    where: WorkoutBonusWhereUniqueInput
  }

  /**
   * WorkoutBonus updateMany
   */
  export type WorkoutBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutBonuses.
     */
    data: XOR<WorkoutBonusUpdateManyMutationInput, WorkoutBonusUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutBonuses to update
     */
    where?: WorkoutBonusWhereInput
    /**
     * Limit how many WorkoutBonuses to update.
     */
    limit?: number
  }

  /**
   * WorkoutBonus updateManyAndReturn
   */
  export type WorkoutBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutBonuses.
     */
    data: XOR<WorkoutBonusUpdateManyMutationInput, WorkoutBonusUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutBonuses to update
     */
    where?: WorkoutBonusWhereInput
    /**
     * Limit how many WorkoutBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutBonus upsert
   */
  export type WorkoutBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutBonus to update in case it exists.
     */
    where: WorkoutBonusWhereUniqueInput
    /**
     * In case the WorkoutBonus found by the `where` argument doesn't exist, create a new WorkoutBonus with this data.
     */
    create: XOR<WorkoutBonusCreateInput, WorkoutBonusUncheckedCreateInput>
    /**
     * In case the WorkoutBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutBonusUpdateInput, WorkoutBonusUncheckedUpdateInput>
  }

  /**
   * WorkoutBonus delete
   */
  export type WorkoutBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
    /**
     * Filter which WorkoutBonus to delete.
     */
    where: WorkoutBonusWhereUniqueInput
  }

  /**
   * WorkoutBonus deleteMany
   */
  export type WorkoutBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutBonuses to delete
     */
    where?: WorkoutBonusWhereInput
    /**
     * Limit how many WorkoutBonuses to delete.
     */
    limit?: number
  }

  /**
   * WorkoutBonus without action
   */
  export type WorkoutBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutBonus
     */
    select?: WorkoutBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutBonus
     */
    omit?: WorkoutBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutBonusInclude<ExtArgs> | null
  }


  /**
   * Model OptionBonus
   */

  export type AggregateOptionBonus = {
    _count: OptionBonusCountAggregateOutputType | null
    _avg: OptionBonusAvgAggregateOutputType | null
    _sum: OptionBonusSumAggregateOutputType | null
    _min: OptionBonusMinAggregateOutputType | null
    _max: OptionBonusMaxAggregateOutputType | null
  }

  export type OptionBonusAvgAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type OptionBonusSumAggregateOutputType = {
    year: number | null
    amount: number | null
  }

  export type OptionBonusMinAggregateOutputType = {
    id: string | null
    clauseId: string | null
    year: number | null
    amount: number | null
    type: $Enums.OptionType | null
  }

  export type OptionBonusMaxAggregateOutputType = {
    id: string | null
    clauseId: string | null
    year: number | null
    amount: number | null
    type: $Enums.OptionType | null
  }

  export type OptionBonusCountAggregateOutputType = {
    id: number
    clauseId: number
    year: number
    amount: number
    type: number
    _all: number
  }


  export type OptionBonusAvgAggregateInputType = {
    year?: true
    amount?: true
  }

  export type OptionBonusSumAggregateInputType = {
    year?: true
    amount?: true
  }

  export type OptionBonusMinAggregateInputType = {
    id?: true
    clauseId?: true
    year?: true
    amount?: true
    type?: true
  }

  export type OptionBonusMaxAggregateInputType = {
    id?: true
    clauseId?: true
    year?: true
    amount?: true
    type?: true
  }

  export type OptionBonusCountAggregateInputType = {
    id?: true
    clauseId?: true
    year?: true
    amount?: true
    type?: true
    _all?: true
  }

  export type OptionBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionBonus to aggregate.
     */
    where?: OptionBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionBonuses to fetch.
     */
    orderBy?: OptionBonusOrderByWithRelationInput | OptionBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptionBonuses
    **/
    _count?: true | OptionBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionBonusMaxAggregateInputType
  }

  export type GetOptionBonusAggregateType<T extends OptionBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateOptionBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptionBonus[P]>
      : GetScalarType<T[P], AggregateOptionBonus[P]>
  }




  export type OptionBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionBonusWhereInput
    orderBy?: OptionBonusOrderByWithAggregationInput | OptionBonusOrderByWithAggregationInput[]
    by: OptionBonusScalarFieldEnum[] | OptionBonusScalarFieldEnum
    having?: OptionBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionBonusCountAggregateInputType | true
    _avg?: OptionBonusAvgAggregateInputType
    _sum?: OptionBonusSumAggregateInputType
    _min?: OptionBonusMinAggregateInputType
    _max?: OptionBonusMaxAggregateInputType
  }

  export type OptionBonusGroupByOutputType = {
    id: string
    clauseId: string
    year: number | null
    amount: number | null
    type: $Enums.OptionType | null
    _count: OptionBonusCountAggregateOutputType | null
    _avg: OptionBonusAvgAggregateOutputType | null
    _sum: OptionBonusSumAggregateOutputType | null
    _min: OptionBonusMinAggregateOutputType | null
    _max: OptionBonusMaxAggregateOutputType | null
  }

  type GetOptionBonusGroupByPayload<T extends OptionBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionBonusGroupByOutputType[P]>
            : GetScalarType<T[P], OptionBonusGroupByOutputType[P]>
        }
      >
    >


  export type OptionBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    year?: boolean
    amount?: boolean
    type?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optionBonus"]>

  export type OptionBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    year?: boolean
    amount?: boolean
    type?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optionBonus"]>

  export type OptionBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clauseId?: boolean
    year?: boolean
    amount?: boolean
    type?: boolean
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optionBonus"]>

  export type OptionBonusSelectScalar = {
    id?: boolean
    clauseId?: boolean
    year?: boolean
    amount?: boolean
    type?: boolean
  }

  export type OptionBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clauseId" | "year" | "amount" | "type", ExtArgs["result"]["optionBonus"]>
  export type OptionBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type OptionBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }
  export type OptionBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clause?: boolean | ContractClauseDefaultArgs<ExtArgs>
  }

  export type $OptionBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptionBonus"
    objects: {
      clause: Prisma.$ContractClausePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clauseId: string
      year: number | null
      amount: number | null
      type: $Enums.OptionType | null
    }, ExtArgs["result"]["optionBonus"]>
    composites: {}
  }

  type OptionBonusGetPayload<S extends boolean | null | undefined | OptionBonusDefaultArgs> = $Result.GetResult<Prisma.$OptionBonusPayload, S>

  type OptionBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptionBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionBonusCountAggregateInputType | true
    }

  export interface OptionBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptionBonus'], meta: { name: 'OptionBonus' } }
    /**
     * Find zero or one OptionBonus that matches the filter.
     * @param {OptionBonusFindUniqueArgs} args - Arguments to find a OptionBonus
     * @example
     * // Get one OptionBonus
     * const optionBonus = await prisma.optionBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionBonusFindUniqueArgs>(args: SelectSubset<T, OptionBonusFindUniqueArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OptionBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptionBonusFindUniqueOrThrowArgs} args - Arguments to find a OptionBonus
     * @example
     * // Get one OptionBonus
     * const optionBonus = await prisma.optionBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, OptionBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptionBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusFindFirstArgs} args - Arguments to find a OptionBonus
     * @example
     * // Get one OptionBonus
     * const optionBonus = await prisma.optionBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionBonusFindFirstArgs>(args?: SelectSubset<T, OptionBonusFindFirstArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptionBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusFindFirstOrThrowArgs} args - Arguments to find a OptionBonus
     * @example
     * // Get one OptionBonus
     * const optionBonus = await prisma.optionBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, OptionBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OptionBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptionBonuses
     * const optionBonuses = await prisma.optionBonus.findMany()
     * 
     * // Get first 10 OptionBonuses
     * const optionBonuses = await prisma.optionBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionBonusWithIdOnly = await prisma.optionBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionBonusFindManyArgs>(args?: SelectSubset<T, OptionBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OptionBonus.
     * @param {OptionBonusCreateArgs} args - Arguments to create a OptionBonus.
     * @example
     * // Create one OptionBonus
     * const OptionBonus = await prisma.optionBonus.create({
     *   data: {
     *     // ... data to create a OptionBonus
     *   }
     * })
     * 
     */
    create<T extends OptionBonusCreateArgs>(args: SelectSubset<T, OptionBonusCreateArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OptionBonuses.
     * @param {OptionBonusCreateManyArgs} args - Arguments to create many OptionBonuses.
     * @example
     * // Create many OptionBonuses
     * const optionBonus = await prisma.optionBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionBonusCreateManyArgs>(args?: SelectSubset<T, OptionBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OptionBonuses and returns the data saved in the database.
     * @param {OptionBonusCreateManyAndReturnArgs} args - Arguments to create many OptionBonuses.
     * @example
     * // Create many OptionBonuses
     * const optionBonus = await prisma.optionBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OptionBonuses and only return the `id`
     * const optionBonusWithIdOnly = await prisma.optionBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptionBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, OptionBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OptionBonus.
     * @param {OptionBonusDeleteArgs} args - Arguments to delete one OptionBonus.
     * @example
     * // Delete one OptionBonus
     * const OptionBonus = await prisma.optionBonus.delete({
     *   where: {
     *     // ... filter to delete one OptionBonus
     *   }
     * })
     * 
     */
    delete<T extends OptionBonusDeleteArgs>(args: SelectSubset<T, OptionBonusDeleteArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OptionBonus.
     * @param {OptionBonusUpdateArgs} args - Arguments to update one OptionBonus.
     * @example
     * // Update one OptionBonus
     * const optionBonus = await prisma.optionBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionBonusUpdateArgs>(args: SelectSubset<T, OptionBonusUpdateArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OptionBonuses.
     * @param {OptionBonusDeleteManyArgs} args - Arguments to filter OptionBonuses to delete.
     * @example
     * // Delete a few OptionBonuses
     * const { count } = await prisma.optionBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionBonusDeleteManyArgs>(args?: SelectSubset<T, OptionBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptionBonuses
     * const optionBonus = await prisma.optionBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionBonusUpdateManyArgs>(args: SelectSubset<T, OptionBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionBonuses and returns the data updated in the database.
     * @param {OptionBonusUpdateManyAndReturnArgs} args - Arguments to update many OptionBonuses.
     * @example
     * // Update many OptionBonuses
     * const optionBonus = await prisma.optionBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OptionBonuses and only return the `id`
     * const optionBonusWithIdOnly = await prisma.optionBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptionBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, OptionBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OptionBonus.
     * @param {OptionBonusUpsertArgs} args - Arguments to update or create a OptionBonus.
     * @example
     * // Update or create a OptionBonus
     * const optionBonus = await prisma.optionBonus.upsert({
     *   create: {
     *     // ... data to create a OptionBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptionBonus we want to update
     *   }
     * })
     */
    upsert<T extends OptionBonusUpsertArgs>(args: SelectSubset<T, OptionBonusUpsertArgs<ExtArgs>>): Prisma__OptionBonusClient<$Result.GetResult<Prisma.$OptionBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OptionBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusCountArgs} args - Arguments to filter OptionBonuses to count.
     * @example
     * // Count the number of OptionBonuses
     * const count = await prisma.optionBonus.count({
     *   where: {
     *     // ... the filter for the OptionBonuses we want to count
     *   }
     * })
    **/
    count<T extends OptionBonusCountArgs>(
      args?: Subset<T, OptionBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptionBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionBonusAggregateArgs>(args: Subset<T, OptionBonusAggregateArgs>): Prisma.PrismaPromise<GetOptionBonusAggregateType<T>>

    /**
     * Group by OptionBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionBonusGroupByArgs['orderBy'] }
        : { orderBy?: OptionBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptionBonus model
   */
  readonly fields: OptionBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptionBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clause<T extends ContractClauseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractClauseDefaultArgs<ExtArgs>>): Prisma__ContractClauseClient<$Result.GetResult<Prisma.$ContractClausePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptionBonus model
   */
  interface OptionBonusFieldRefs {
    readonly id: FieldRef<"OptionBonus", 'String'>
    readonly clauseId: FieldRef<"OptionBonus", 'String'>
    readonly year: FieldRef<"OptionBonus", 'Int'>
    readonly amount: FieldRef<"OptionBonus", 'Int'>
    readonly type: FieldRef<"OptionBonus", 'OptionType'>
  }
    

  // Custom InputTypes
  /**
   * OptionBonus findUnique
   */
  export type OptionBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * Filter, which OptionBonus to fetch.
     */
    where: OptionBonusWhereUniqueInput
  }

  /**
   * OptionBonus findUniqueOrThrow
   */
  export type OptionBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * Filter, which OptionBonus to fetch.
     */
    where: OptionBonusWhereUniqueInput
  }

  /**
   * OptionBonus findFirst
   */
  export type OptionBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * Filter, which OptionBonus to fetch.
     */
    where?: OptionBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionBonuses to fetch.
     */
    orderBy?: OptionBonusOrderByWithRelationInput | OptionBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionBonuses.
     */
    cursor?: OptionBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionBonuses.
     */
    distinct?: OptionBonusScalarFieldEnum | OptionBonusScalarFieldEnum[]
  }

  /**
   * OptionBonus findFirstOrThrow
   */
  export type OptionBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * Filter, which OptionBonus to fetch.
     */
    where?: OptionBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionBonuses to fetch.
     */
    orderBy?: OptionBonusOrderByWithRelationInput | OptionBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionBonuses.
     */
    cursor?: OptionBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionBonuses.
     */
    distinct?: OptionBonusScalarFieldEnum | OptionBonusScalarFieldEnum[]
  }

  /**
   * OptionBonus findMany
   */
  export type OptionBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * Filter, which OptionBonuses to fetch.
     */
    where?: OptionBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionBonuses to fetch.
     */
    orderBy?: OptionBonusOrderByWithRelationInput | OptionBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptionBonuses.
     */
    cursor?: OptionBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionBonuses.
     */
    skip?: number
    distinct?: OptionBonusScalarFieldEnum | OptionBonusScalarFieldEnum[]
  }

  /**
   * OptionBonus create
   */
  export type OptionBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a OptionBonus.
     */
    data: XOR<OptionBonusCreateInput, OptionBonusUncheckedCreateInput>
  }

  /**
   * OptionBonus createMany
   */
  export type OptionBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptionBonuses.
     */
    data: OptionBonusCreateManyInput | OptionBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OptionBonus createManyAndReturn
   */
  export type OptionBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * The data used to create many OptionBonuses.
     */
    data: OptionBonusCreateManyInput | OptionBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptionBonus update
   */
  export type OptionBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a OptionBonus.
     */
    data: XOR<OptionBonusUpdateInput, OptionBonusUncheckedUpdateInput>
    /**
     * Choose, which OptionBonus to update.
     */
    where: OptionBonusWhereUniqueInput
  }

  /**
   * OptionBonus updateMany
   */
  export type OptionBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptionBonuses.
     */
    data: XOR<OptionBonusUpdateManyMutationInput, OptionBonusUncheckedUpdateManyInput>
    /**
     * Filter which OptionBonuses to update
     */
    where?: OptionBonusWhereInput
    /**
     * Limit how many OptionBonuses to update.
     */
    limit?: number
  }

  /**
   * OptionBonus updateManyAndReturn
   */
  export type OptionBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * The data used to update OptionBonuses.
     */
    data: XOR<OptionBonusUpdateManyMutationInput, OptionBonusUncheckedUpdateManyInput>
    /**
     * Filter which OptionBonuses to update
     */
    where?: OptionBonusWhereInput
    /**
     * Limit how many OptionBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptionBonus upsert
   */
  export type OptionBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the OptionBonus to update in case it exists.
     */
    where: OptionBonusWhereUniqueInput
    /**
     * In case the OptionBonus found by the `where` argument doesn't exist, create a new OptionBonus with this data.
     */
    create: XOR<OptionBonusCreateInput, OptionBonusUncheckedCreateInput>
    /**
     * In case the OptionBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionBonusUpdateInput, OptionBonusUncheckedUpdateInput>
  }

  /**
   * OptionBonus delete
   */
  export type OptionBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
    /**
     * Filter which OptionBonus to delete.
     */
    where: OptionBonusWhereUniqueInput
  }

  /**
   * OptionBonus deleteMany
   */
  export type OptionBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionBonuses to delete
     */
    where?: OptionBonusWhereInput
    /**
     * Limit how many OptionBonuses to delete.
     */
    limit?: number
  }

  /**
   * OptionBonus without action
   */
  export type OptionBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionBonus
     */
    select?: OptionBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionBonus
     */
    omit?: OptionBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionBonusInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    reputation: number | null
    yearsOfExperience: number | null
  }

  export type AgentSumAggregateOutputType = {
    reputation: number | null
    yearsOfExperience: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    agencyName: string | null
    reputation: number | null
    yearsOfExperience: number | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    agencyName: string | null
    reputation: number | null
    yearsOfExperience: number | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    agencyName: number
    reputation: number
    yearsOfExperience: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    reputation?: true
    yearsOfExperience?: true
  }

  export type AgentSumAggregateInputType = {
    reputation?: true
    yearsOfExperience?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    agencyName?: true
    reputation?: true
    yearsOfExperience?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    agencyName?: true
    reputation?: true
    yearsOfExperience?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    agencyName?: true
    reputation?: true
    yearsOfExperience?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    agencyName: string | null
    reputation: number | null
    yearsOfExperience: number | null
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    agencyName?: boolean
    reputation?: boolean
    yearsOfExperience?: boolean
    players?: boolean | Agent$playersArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    agencyName?: boolean
    reputation?: boolean
    yearsOfExperience?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    agencyName?: boolean
    reputation?: boolean
    yearsOfExperience?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    agencyName?: boolean
    reputation?: boolean
    yearsOfExperience?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "agencyName" | "reputation" | "yearsOfExperience", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | Agent$playersArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      players: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      agencyName: string | null
      reputation: number | null
      yearsOfExperience: number | null
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends Agent$playersArgs<ExtArgs> = {}>(args?: Subset<T, Agent$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly firstName: FieldRef<"Agent", 'String'>
    readonly lastName: FieldRef<"Agent", 'String'>
    readonly agencyName: FieldRef<"Agent", 'String'>
    readonly reputation: FieldRef<"Agent", 'Int'>
    readonly yearsOfExperience: FieldRef<"Agent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.players
   */
  export type Agent$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    speed: number | null
    acceleration: number | null
    agility: number | null
    changeOfDirection: number | null
    strength: number | null
    impactPower: number | null
    verticalJump: number | null
    stamina: number | null
    toughness: number | null
    awareness: number | null
    discipline: number | null
    injuryRecovery: number | null
    throwPower: number | null
    throwAccuracyShort: number | null
    throwAccuracyMedium: number | null
    throwAccuracyDeep: number | null
    throwOnRun: number | null
    playAction: number | null
    pocketPresence: number | null
    releaseTime: number | null
    decisionMaking: number | null
    scrambling: number | null
    breakSack: number | null
    fieldVision: number | null
    ballSecurity: number | null
    ballCarrierVision: number | null
    breakTackle: number | null
    topBallCarrierSpeed: number | null
    trucking: number | null
    elusiveness: number | null
    stiffArm: number | null
    spinMove: number | null
    jukeMove: number | null
    shortYardage: number | null
    goalLine: number | null
    openFieldRunning: number | null
    catching: number | null
    catchInTraffic: number | null
    spectacularCatch: number | null
    contestedCatches: number | null
    yardsAfterCatch: number | null
    jumpBallTiming: number | null
    routeRunning: number | null
    shortRoute: number | null
    mediumRoute: number | null
    deepRoute: number | null
    separation: number | null
    release: number | null
    runBlocking: number | null
    passBlocking: number | null
    pullBlocking: number | null
    scrambleBlocking: number | null
    playActionBlocking: number | null
    screenBlocking: number | null
    leadBlocking: number | null
    tackling: number | null
    blockShedding: number | null
    blitzing: number | null
    playRecognition: number | null
    openFieldTackling: number | null
    coverageAgainstTEsRBs: number | null
    coverageAgainstSlot: number | null
    deepCoverage: number | null
    runDefense: number | null
    passRush: number | null
    finessePassRush: number | null
    powerPassRush: number | null
    runStopping: number | null
    penetration: number | null
    edgeSetting: number | null
    disengagement: number | null
    offensiveLineRecognition: number | null
    hitPower: number | null
    pressCoverage: number | null
    offBallCoverage: number | null
    manCoverage: number | null
    zoneCoverage: number | null
    ballHawking: number | null
    interceptions: number | null
    passDeflection: number | null
    kickPower: number | null
    kickAccuracy: number | null
    puntPower: number | null
    puntAccuracy: number | null
    onsideKickAbility: number | null
    kickReturnVision: number | null
    puntReturnVision: number | null
  }

  export type RatingSumAggregateOutputType = {
    speed: number | null
    acceleration: number | null
    agility: number | null
    changeOfDirection: number | null
    strength: number | null
    impactPower: number | null
    verticalJump: number | null
    stamina: number | null
    toughness: number | null
    awareness: number | null
    discipline: number | null
    injuryRecovery: number | null
    throwPower: number | null
    throwAccuracyShort: number | null
    throwAccuracyMedium: number | null
    throwAccuracyDeep: number | null
    throwOnRun: number | null
    playAction: number | null
    pocketPresence: number | null
    releaseTime: number | null
    decisionMaking: number | null
    scrambling: number | null
    breakSack: number | null
    fieldVision: number | null
    ballSecurity: number | null
    ballCarrierVision: number | null
    breakTackle: number | null
    topBallCarrierSpeed: number | null
    trucking: number | null
    elusiveness: number | null
    stiffArm: number | null
    spinMove: number | null
    jukeMove: number | null
    shortYardage: number | null
    goalLine: number | null
    openFieldRunning: number | null
    catching: number | null
    catchInTraffic: number | null
    spectacularCatch: number | null
    contestedCatches: number | null
    yardsAfterCatch: number | null
    jumpBallTiming: number | null
    routeRunning: number | null
    shortRoute: number | null
    mediumRoute: number | null
    deepRoute: number | null
    separation: number | null
    release: number | null
    runBlocking: number | null
    passBlocking: number | null
    pullBlocking: number | null
    scrambleBlocking: number | null
    playActionBlocking: number | null
    screenBlocking: number | null
    leadBlocking: number | null
    tackling: number | null
    blockShedding: number | null
    blitzing: number | null
    playRecognition: number | null
    openFieldTackling: number | null
    coverageAgainstTEsRBs: number | null
    coverageAgainstSlot: number | null
    deepCoverage: number | null
    runDefense: number | null
    passRush: number | null
    finessePassRush: number | null
    powerPassRush: number | null
    runStopping: number | null
    penetration: number | null
    edgeSetting: number | null
    disengagement: number | null
    offensiveLineRecognition: number | null
    hitPower: number | null
    pressCoverage: number | null
    offBallCoverage: number | null
    manCoverage: number | null
    zoneCoverage: number | null
    ballHawking: number | null
    interceptions: number | null
    passDeflection: number | null
    kickPower: number | null
    kickAccuracy: number | null
    puntPower: number | null
    puntAccuracy: number | null
    onsideKickAbility: number | null
    kickReturnVision: number | null
    puntReturnVision: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    speed: number | null
    acceleration: number | null
    agility: number | null
    changeOfDirection: number | null
    strength: number | null
    impactPower: number | null
    verticalJump: number | null
    stamina: number | null
    toughness: number | null
    awareness: number | null
    discipline: number | null
    injuryRecovery: number | null
    throwPower: number | null
    throwAccuracyShort: number | null
    throwAccuracyMedium: number | null
    throwAccuracyDeep: number | null
    throwOnRun: number | null
    playAction: number | null
    pocketPresence: number | null
    releaseTime: number | null
    decisionMaking: number | null
    scrambling: number | null
    breakSack: number | null
    fieldVision: number | null
    ballSecurity: number | null
    ballCarrierVision: number | null
    breakTackle: number | null
    topBallCarrierSpeed: number | null
    trucking: number | null
    elusiveness: number | null
    stiffArm: number | null
    spinMove: number | null
    jukeMove: number | null
    shortYardage: number | null
    goalLine: number | null
    openFieldRunning: number | null
    catching: number | null
    catchInTraffic: number | null
    spectacularCatch: number | null
    contestedCatches: number | null
    yardsAfterCatch: number | null
    jumpBallTiming: number | null
    routeRunning: number | null
    shortRoute: number | null
    mediumRoute: number | null
    deepRoute: number | null
    separation: number | null
    release: number | null
    runBlocking: number | null
    passBlocking: number | null
    pullBlocking: number | null
    scrambleBlocking: number | null
    playActionBlocking: number | null
    screenBlocking: number | null
    leadBlocking: number | null
    tackling: number | null
    blockShedding: number | null
    blitzing: number | null
    playRecognition: number | null
    openFieldTackling: number | null
    coverageAgainstTEsRBs: number | null
    coverageAgainstSlot: number | null
    deepCoverage: number | null
    runDefense: number | null
    passRush: number | null
    finessePassRush: number | null
    powerPassRush: number | null
    runStopping: number | null
    penetration: number | null
    edgeSetting: number | null
    disengagement: number | null
    offensiveLineRecognition: number | null
    hitPower: number | null
    pressCoverage: number | null
    offBallCoverage: number | null
    manCoverage: number | null
    zoneCoverage: number | null
    ballHawking: number | null
    interceptions: number | null
    passDeflection: number | null
    kickPower: number | null
    kickAccuracy: number | null
    puntPower: number | null
    puntAccuracy: number | null
    onsideKickAbility: number | null
    kickReturnVision: number | null
    puntReturnVision: number | null
  }

  export type RatingMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    speed: number | null
    acceleration: number | null
    agility: number | null
    changeOfDirection: number | null
    strength: number | null
    impactPower: number | null
    verticalJump: number | null
    stamina: number | null
    toughness: number | null
    awareness: number | null
    discipline: number | null
    injuryRecovery: number | null
    throwPower: number | null
    throwAccuracyShort: number | null
    throwAccuracyMedium: number | null
    throwAccuracyDeep: number | null
    throwOnRun: number | null
    playAction: number | null
    pocketPresence: number | null
    releaseTime: number | null
    decisionMaking: number | null
    scrambling: number | null
    breakSack: number | null
    fieldVision: number | null
    ballSecurity: number | null
    ballCarrierVision: number | null
    breakTackle: number | null
    topBallCarrierSpeed: number | null
    trucking: number | null
    elusiveness: number | null
    stiffArm: number | null
    spinMove: number | null
    jukeMove: number | null
    shortYardage: number | null
    goalLine: number | null
    openFieldRunning: number | null
    catching: number | null
    catchInTraffic: number | null
    spectacularCatch: number | null
    contestedCatches: number | null
    yardsAfterCatch: number | null
    jumpBallTiming: number | null
    routeRunning: number | null
    shortRoute: number | null
    mediumRoute: number | null
    deepRoute: number | null
    separation: number | null
    release: number | null
    runBlocking: number | null
    passBlocking: number | null
    pullBlocking: number | null
    scrambleBlocking: number | null
    playActionBlocking: number | null
    screenBlocking: number | null
    leadBlocking: number | null
    tackling: number | null
    blockShedding: number | null
    blitzing: number | null
    playRecognition: number | null
    openFieldTackling: number | null
    coverageAgainstTEsRBs: number | null
    coverageAgainstSlot: number | null
    deepCoverage: number | null
    runDefense: number | null
    passRush: number | null
    finessePassRush: number | null
    powerPassRush: number | null
    runStopping: number | null
    penetration: number | null
    edgeSetting: number | null
    disengagement: number | null
    offensiveLineRecognition: number | null
    hitPower: number | null
    pressCoverage: number | null
    offBallCoverage: number | null
    manCoverage: number | null
    zoneCoverage: number | null
    ballHawking: number | null
    interceptions: number | null
    passDeflection: number | null
    kickPower: number | null
    kickAccuracy: number | null
    puntPower: number | null
    puntAccuracy: number | null
    onsideKickAbility: number | null
    kickReturnVision: number | null
    puntReturnVision: number | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    playerId: number
    speed: number
    acceleration: number
    agility: number
    changeOfDirection: number
    strength: number
    impactPower: number
    verticalJump: number
    stamina: number
    toughness: number
    awareness: number
    discipline: number
    injuryRecovery: number
    throwPower: number
    throwAccuracyShort: number
    throwAccuracyMedium: number
    throwAccuracyDeep: number
    throwOnRun: number
    playAction: number
    pocketPresence: number
    releaseTime: number
    decisionMaking: number
    scrambling: number
    breakSack: number
    fieldVision: number
    ballSecurity: number
    ballCarrierVision: number
    breakTackle: number
    topBallCarrierSpeed: number
    trucking: number
    elusiveness: number
    stiffArm: number
    spinMove: number
    jukeMove: number
    shortYardage: number
    goalLine: number
    openFieldRunning: number
    catching: number
    catchInTraffic: number
    spectacularCatch: number
    contestedCatches: number
    yardsAfterCatch: number
    jumpBallTiming: number
    routeRunning: number
    shortRoute: number
    mediumRoute: number
    deepRoute: number
    separation: number
    release: number
    runBlocking: number
    passBlocking: number
    pullBlocking: number
    scrambleBlocking: number
    playActionBlocking: number
    screenBlocking: number
    leadBlocking: number
    tackling: number
    blockShedding: number
    blitzing: number
    playRecognition: number
    openFieldTackling: number
    coverageAgainstTEsRBs: number
    coverageAgainstSlot: number
    deepCoverage: number
    runDefense: number
    passRush: number
    finessePassRush: number
    powerPassRush: number
    runStopping: number
    penetration: number
    edgeSetting: number
    disengagement: number
    offensiveLineRecognition: number
    hitPower: number
    pressCoverage: number
    offBallCoverage: number
    manCoverage: number
    zoneCoverage: number
    ballHawking: number
    interceptions: number
    passDeflection: number
    kickPower: number
    kickAccuracy: number
    puntPower: number
    puntAccuracy: number
    onsideKickAbility: number
    kickReturnVision: number
    puntReturnVision: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    speed?: true
    acceleration?: true
    agility?: true
    changeOfDirection?: true
    strength?: true
    impactPower?: true
    verticalJump?: true
    stamina?: true
    toughness?: true
    awareness?: true
    discipline?: true
    injuryRecovery?: true
    throwPower?: true
    throwAccuracyShort?: true
    throwAccuracyMedium?: true
    throwAccuracyDeep?: true
    throwOnRun?: true
    playAction?: true
    pocketPresence?: true
    releaseTime?: true
    decisionMaking?: true
    scrambling?: true
    breakSack?: true
    fieldVision?: true
    ballSecurity?: true
    ballCarrierVision?: true
    breakTackle?: true
    topBallCarrierSpeed?: true
    trucking?: true
    elusiveness?: true
    stiffArm?: true
    spinMove?: true
    jukeMove?: true
    shortYardage?: true
    goalLine?: true
    openFieldRunning?: true
    catching?: true
    catchInTraffic?: true
    spectacularCatch?: true
    contestedCatches?: true
    yardsAfterCatch?: true
    jumpBallTiming?: true
    routeRunning?: true
    shortRoute?: true
    mediumRoute?: true
    deepRoute?: true
    separation?: true
    release?: true
    runBlocking?: true
    passBlocking?: true
    pullBlocking?: true
    scrambleBlocking?: true
    playActionBlocking?: true
    screenBlocking?: true
    leadBlocking?: true
    tackling?: true
    blockShedding?: true
    blitzing?: true
    playRecognition?: true
    openFieldTackling?: true
    coverageAgainstTEsRBs?: true
    coverageAgainstSlot?: true
    deepCoverage?: true
    runDefense?: true
    passRush?: true
    finessePassRush?: true
    powerPassRush?: true
    runStopping?: true
    penetration?: true
    edgeSetting?: true
    disengagement?: true
    offensiveLineRecognition?: true
    hitPower?: true
    pressCoverage?: true
    offBallCoverage?: true
    manCoverage?: true
    zoneCoverage?: true
    ballHawking?: true
    interceptions?: true
    passDeflection?: true
    kickPower?: true
    kickAccuracy?: true
    puntPower?: true
    puntAccuracy?: true
    onsideKickAbility?: true
    kickReturnVision?: true
    puntReturnVision?: true
  }

  export type RatingSumAggregateInputType = {
    speed?: true
    acceleration?: true
    agility?: true
    changeOfDirection?: true
    strength?: true
    impactPower?: true
    verticalJump?: true
    stamina?: true
    toughness?: true
    awareness?: true
    discipline?: true
    injuryRecovery?: true
    throwPower?: true
    throwAccuracyShort?: true
    throwAccuracyMedium?: true
    throwAccuracyDeep?: true
    throwOnRun?: true
    playAction?: true
    pocketPresence?: true
    releaseTime?: true
    decisionMaking?: true
    scrambling?: true
    breakSack?: true
    fieldVision?: true
    ballSecurity?: true
    ballCarrierVision?: true
    breakTackle?: true
    topBallCarrierSpeed?: true
    trucking?: true
    elusiveness?: true
    stiffArm?: true
    spinMove?: true
    jukeMove?: true
    shortYardage?: true
    goalLine?: true
    openFieldRunning?: true
    catching?: true
    catchInTraffic?: true
    spectacularCatch?: true
    contestedCatches?: true
    yardsAfterCatch?: true
    jumpBallTiming?: true
    routeRunning?: true
    shortRoute?: true
    mediumRoute?: true
    deepRoute?: true
    separation?: true
    release?: true
    runBlocking?: true
    passBlocking?: true
    pullBlocking?: true
    scrambleBlocking?: true
    playActionBlocking?: true
    screenBlocking?: true
    leadBlocking?: true
    tackling?: true
    blockShedding?: true
    blitzing?: true
    playRecognition?: true
    openFieldTackling?: true
    coverageAgainstTEsRBs?: true
    coverageAgainstSlot?: true
    deepCoverage?: true
    runDefense?: true
    passRush?: true
    finessePassRush?: true
    powerPassRush?: true
    runStopping?: true
    penetration?: true
    edgeSetting?: true
    disengagement?: true
    offensiveLineRecognition?: true
    hitPower?: true
    pressCoverage?: true
    offBallCoverage?: true
    manCoverage?: true
    zoneCoverage?: true
    ballHawking?: true
    interceptions?: true
    passDeflection?: true
    kickPower?: true
    kickAccuracy?: true
    puntPower?: true
    puntAccuracy?: true
    onsideKickAbility?: true
    kickReturnVision?: true
    puntReturnVision?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    playerId?: true
    speed?: true
    acceleration?: true
    agility?: true
    changeOfDirection?: true
    strength?: true
    impactPower?: true
    verticalJump?: true
    stamina?: true
    toughness?: true
    awareness?: true
    discipline?: true
    injuryRecovery?: true
    throwPower?: true
    throwAccuracyShort?: true
    throwAccuracyMedium?: true
    throwAccuracyDeep?: true
    throwOnRun?: true
    playAction?: true
    pocketPresence?: true
    releaseTime?: true
    decisionMaking?: true
    scrambling?: true
    breakSack?: true
    fieldVision?: true
    ballSecurity?: true
    ballCarrierVision?: true
    breakTackle?: true
    topBallCarrierSpeed?: true
    trucking?: true
    elusiveness?: true
    stiffArm?: true
    spinMove?: true
    jukeMove?: true
    shortYardage?: true
    goalLine?: true
    openFieldRunning?: true
    catching?: true
    catchInTraffic?: true
    spectacularCatch?: true
    contestedCatches?: true
    yardsAfterCatch?: true
    jumpBallTiming?: true
    routeRunning?: true
    shortRoute?: true
    mediumRoute?: true
    deepRoute?: true
    separation?: true
    release?: true
    runBlocking?: true
    passBlocking?: true
    pullBlocking?: true
    scrambleBlocking?: true
    playActionBlocking?: true
    screenBlocking?: true
    leadBlocking?: true
    tackling?: true
    blockShedding?: true
    blitzing?: true
    playRecognition?: true
    openFieldTackling?: true
    coverageAgainstTEsRBs?: true
    coverageAgainstSlot?: true
    deepCoverage?: true
    runDefense?: true
    passRush?: true
    finessePassRush?: true
    powerPassRush?: true
    runStopping?: true
    penetration?: true
    edgeSetting?: true
    disengagement?: true
    offensiveLineRecognition?: true
    hitPower?: true
    pressCoverage?: true
    offBallCoverage?: true
    manCoverage?: true
    zoneCoverage?: true
    ballHawking?: true
    interceptions?: true
    passDeflection?: true
    kickPower?: true
    kickAccuracy?: true
    puntPower?: true
    puntAccuracy?: true
    onsideKickAbility?: true
    kickReturnVision?: true
    puntReturnVision?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    playerId?: true
    speed?: true
    acceleration?: true
    agility?: true
    changeOfDirection?: true
    strength?: true
    impactPower?: true
    verticalJump?: true
    stamina?: true
    toughness?: true
    awareness?: true
    discipline?: true
    injuryRecovery?: true
    throwPower?: true
    throwAccuracyShort?: true
    throwAccuracyMedium?: true
    throwAccuracyDeep?: true
    throwOnRun?: true
    playAction?: true
    pocketPresence?: true
    releaseTime?: true
    decisionMaking?: true
    scrambling?: true
    breakSack?: true
    fieldVision?: true
    ballSecurity?: true
    ballCarrierVision?: true
    breakTackle?: true
    topBallCarrierSpeed?: true
    trucking?: true
    elusiveness?: true
    stiffArm?: true
    spinMove?: true
    jukeMove?: true
    shortYardage?: true
    goalLine?: true
    openFieldRunning?: true
    catching?: true
    catchInTraffic?: true
    spectacularCatch?: true
    contestedCatches?: true
    yardsAfterCatch?: true
    jumpBallTiming?: true
    routeRunning?: true
    shortRoute?: true
    mediumRoute?: true
    deepRoute?: true
    separation?: true
    release?: true
    runBlocking?: true
    passBlocking?: true
    pullBlocking?: true
    scrambleBlocking?: true
    playActionBlocking?: true
    screenBlocking?: true
    leadBlocking?: true
    tackling?: true
    blockShedding?: true
    blitzing?: true
    playRecognition?: true
    openFieldTackling?: true
    coverageAgainstTEsRBs?: true
    coverageAgainstSlot?: true
    deepCoverage?: true
    runDefense?: true
    passRush?: true
    finessePassRush?: true
    powerPassRush?: true
    runStopping?: true
    penetration?: true
    edgeSetting?: true
    disengagement?: true
    offensiveLineRecognition?: true
    hitPower?: true
    pressCoverage?: true
    offBallCoverage?: true
    manCoverage?: true
    zoneCoverage?: true
    ballHawking?: true
    interceptions?: true
    passDeflection?: true
    kickPower?: true
    kickAccuracy?: true
    puntPower?: true
    puntAccuracy?: true
    onsideKickAbility?: true
    kickReturnVision?: true
    puntReturnVision?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    playerId?: true
    speed?: true
    acceleration?: true
    agility?: true
    changeOfDirection?: true
    strength?: true
    impactPower?: true
    verticalJump?: true
    stamina?: true
    toughness?: true
    awareness?: true
    discipline?: true
    injuryRecovery?: true
    throwPower?: true
    throwAccuracyShort?: true
    throwAccuracyMedium?: true
    throwAccuracyDeep?: true
    throwOnRun?: true
    playAction?: true
    pocketPresence?: true
    releaseTime?: true
    decisionMaking?: true
    scrambling?: true
    breakSack?: true
    fieldVision?: true
    ballSecurity?: true
    ballCarrierVision?: true
    breakTackle?: true
    topBallCarrierSpeed?: true
    trucking?: true
    elusiveness?: true
    stiffArm?: true
    spinMove?: true
    jukeMove?: true
    shortYardage?: true
    goalLine?: true
    openFieldRunning?: true
    catching?: true
    catchInTraffic?: true
    spectacularCatch?: true
    contestedCatches?: true
    yardsAfterCatch?: true
    jumpBallTiming?: true
    routeRunning?: true
    shortRoute?: true
    mediumRoute?: true
    deepRoute?: true
    separation?: true
    release?: true
    runBlocking?: true
    passBlocking?: true
    pullBlocking?: true
    scrambleBlocking?: true
    playActionBlocking?: true
    screenBlocking?: true
    leadBlocking?: true
    tackling?: true
    blockShedding?: true
    blitzing?: true
    playRecognition?: true
    openFieldTackling?: true
    coverageAgainstTEsRBs?: true
    coverageAgainstSlot?: true
    deepCoverage?: true
    runDefense?: true
    passRush?: true
    finessePassRush?: true
    powerPassRush?: true
    runStopping?: true
    penetration?: true
    edgeSetting?: true
    disengagement?: true
    offensiveLineRecognition?: true
    hitPower?: true
    pressCoverage?: true
    offBallCoverage?: true
    manCoverage?: true
    zoneCoverage?: true
    ballHawking?: true
    interceptions?: true
    passDeflection?: true
    kickPower?: true
    kickAccuracy?: true
    puntPower?: true
    puntAccuracy?: true
    onsideKickAbility?: true
    kickReturnVision?: true
    puntReturnVision?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: string
    playerId: string | null
    speed: number | null
    acceleration: number | null
    agility: number | null
    changeOfDirection: number | null
    strength: number | null
    impactPower: number | null
    verticalJump: number | null
    stamina: number | null
    toughness: number | null
    awareness: number | null
    discipline: number | null
    injuryRecovery: number | null
    throwPower: number | null
    throwAccuracyShort: number | null
    throwAccuracyMedium: number | null
    throwAccuracyDeep: number | null
    throwOnRun: number | null
    playAction: number | null
    pocketPresence: number | null
    releaseTime: number | null
    decisionMaking: number | null
    scrambling: number | null
    breakSack: number | null
    fieldVision: number | null
    ballSecurity: number | null
    ballCarrierVision: number | null
    breakTackle: number | null
    topBallCarrierSpeed: number | null
    trucking: number | null
    elusiveness: number | null
    stiffArm: number | null
    spinMove: number | null
    jukeMove: number | null
    shortYardage: number | null
    goalLine: number | null
    openFieldRunning: number | null
    catching: number | null
    catchInTraffic: number | null
    spectacularCatch: number | null
    contestedCatches: number | null
    yardsAfterCatch: number | null
    jumpBallTiming: number | null
    routeRunning: number | null
    shortRoute: number | null
    mediumRoute: number | null
    deepRoute: number | null
    separation: number | null
    release: number | null
    runBlocking: number | null
    passBlocking: number | null
    pullBlocking: number | null
    scrambleBlocking: number | null
    playActionBlocking: number | null
    screenBlocking: number | null
    leadBlocking: number | null
    tackling: number | null
    blockShedding: number | null
    blitzing: number | null
    playRecognition: number | null
    openFieldTackling: number | null
    coverageAgainstTEsRBs: number | null
    coverageAgainstSlot: number | null
    deepCoverage: number | null
    runDefense: number | null
    passRush: number | null
    finessePassRush: number | null
    powerPassRush: number | null
    runStopping: number | null
    penetration: number | null
    edgeSetting: number | null
    disengagement: number | null
    offensiveLineRecognition: number | null
    hitPower: number | null
    pressCoverage: number | null
    offBallCoverage: number | null
    manCoverage: number | null
    zoneCoverage: number | null
    ballHawking: number | null
    interceptions: number | null
    passDeflection: number | null
    kickPower: number | null
    kickAccuracy: number | null
    puntPower: number | null
    puntAccuracy: number | null
    onsideKickAbility: number | null
    kickReturnVision: number | null
    puntReturnVision: number | null
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    speed?: boolean
    acceleration?: boolean
    agility?: boolean
    changeOfDirection?: boolean
    strength?: boolean
    impactPower?: boolean
    verticalJump?: boolean
    stamina?: boolean
    toughness?: boolean
    awareness?: boolean
    discipline?: boolean
    injuryRecovery?: boolean
    throwPower?: boolean
    throwAccuracyShort?: boolean
    throwAccuracyMedium?: boolean
    throwAccuracyDeep?: boolean
    throwOnRun?: boolean
    playAction?: boolean
    pocketPresence?: boolean
    releaseTime?: boolean
    decisionMaking?: boolean
    scrambling?: boolean
    breakSack?: boolean
    fieldVision?: boolean
    ballSecurity?: boolean
    ballCarrierVision?: boolean
    breakTackle?: boolean
    topBallCarrierSpeed?: boolean
    trucking?: boolean
    elusiveness?: boolean
    stiffArm?: boolean
    spinMove?: boolean
    jukeMove?: boolean
    shortYardage?: boolean
    goalLine?: boolean
    openFieldRunning?: boolean
    catching?: boolean
    catchInTraffic?: boolean
    spectacularCatch?: boolean
    contestedCatches?: boolean
    yardsAfterCatch?: boolean
    jumpBallTiming?: boolean
    routeRunning?: boolean
    shortRoute?: boolean
    mediumRoute?: boolean
    deepRoute?: boolean
    separation?: boolean
    release?: boolean
    runBlocking?: boolean
    passBlocking?: boolean
    pullBlocking?: boolean
    scrambleBlocking?: boolean
    playActionBlocking?: boolean
    screenBlocking?: boolean
    leadBlocking?: boolean
    tackling?: boolean
    blockShedding?: boolean
    blitzing?: boolean
    playRecognition?: boolean
    openFieldTackling?: boolean
    coverageAgainstTEsRBs?: boolean
    coverageAgainstSlot?: boolean
    deepCoverage?: boolean
    runDefense?: boolean
    passRush?: boolean
    finessePassRush?: boolean
    powerPassRush?: boolean
    runStopping?: boolean
    penetration?: boolean
    edgeSetting?: boolean
    disengagement?: boolean
    offensiveLineRecognition?: boolean
    hitPower?: boolean
    pressCoverage?: boolean
    offBallCoverage?: boolean
    manCoverage?: boolean
    zoneCoverage?: boolean
    ballHawking?: boolean
    interceptions?: boolean
    passDeflection?: boolean
    kickPower?: boolean
    kickAccuracy?: boolean
    puntPower?: boolean
    puntAccuracy?: boolean
    onsideKickAbility?: boolean
    kickReturnVision?: boolean
    puntReturnVision?: boolean
    player?: boolean | Rating$playerArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    speed?: boolean
    acceleration?: boolean
    agility?: boolean
    changeOfDirection?: boolean
    strength?: boolean
    impactPower?: boolean
    verticalJump?: boolean
    stamina?: boolean
    toughness?: boolean
    awareness?: boolean
    discipline?: boolean
    injuryRecovery?: boolean
    throwPower?: boolean
    throwAccuracyShort?: boolean
    throwAccuracyMedium?: boolean
    throwAccuracyDeep?: boolean
    throwOnRun?: boolean
    playAction?: boolean
    pocketPresence?: boolean
    releaseTime?: boolean
    decisionMaking?: boolean
    scrambling?: boolean
    breakSack?: boolean
    fieldVision?: boolean
    ballSecurity?: boolean
    ballCarrierVision?: boolean
    breakTackle?: boolean
    topBallCarrierSpeed?: boolean
    trucking?: boolean
    elusiveness?: boolean
    stiffArm?: boolean
    spinMove?: boolean
    jukeMove?: boolean
    shortYardage?: boolean
    goalLine?: boolean
    openFieldRunning?: boolean
    catching?: boolean
    catchInTraffic?: boolean
    spectacularCatch?: boolean
    contestedCatches?: boolean
    yardsAfterCatch?: boolean
    jumpBallTiming?: boolean
    routeRunning?: boolean
    shortRoute?: boolean
    mediumRoute?: boolean
    deepRoute?: boolean
    separation?: boolean
    release?: boolean
    runBlocking?: boolean
    passBlocking?: boolean
    pullBlocking?: boolean
    scrambleBlocking?: boolean
    playActionBlocking?: boolean
    screenBlocking?: boolean
    leadBlocking?: boolean
    tackling?: boolean
    blockShedding?: boolean
    blitzing?: boolean
    playRecognition?: boolean
    openFieldTackling?: boolean
    coverageAgainstTEsRBs?: boolean
    coverageAgainstSlot?: boolean
    deepCoverage?: boolean
    runDefense?: boolean
    passRush?: boolean
    finessePassRush?: boolean
    powerPassRush?: boolean
    runStopping?: boolean
    penetration?: boolean
    edgeSetting?: boolean
    disengagement?: boolean
    offensiveLineRecognition?: boolean
    hitPower?: boolean
    pressCoverage?: boolean
    offBallCoverage?: boolean
    manCoverage?: boolean
    zoneCoverage?: boolean
    ballHawking?: boolean
    interceptions?: boolean
    passDeflection?: boolean
    kickPower?: boolean
    kickAccuracy?: boolean
    puntPower?: boolean
    puntAccuracy?: boolean
    onsideKickAbility?: boolean
    kickReturnVision?: boolean
    puntReturnVision?: boolean
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    speed?: boolean
    acceleration?: boolean
    agility?: boolean
    changeOfDirection?: boolean
    strength?: boolean
    impactPower?: boolean
    verticalJump?: boolean
    stamina?: boolean
    toughness?: boolean
    awareness?: boolean
    discipline?: boolean
    injuryRecovery?: boolean
    throwPower?: boolean
    throwAccuracyShort?: boolean
    throwAccuracyMedium?: boolean
    throwAccuracyDeep?: boolean
    throwOnRun?: boolean
    playAction?: boolean
    pocketPresence?: boolean
    releaseTime?: boolean
    decisionMaking?: boolean
    scrambling?: boolean
    breakSack?: boolean
    fieldVision?: boolean
    ballSecurity?: boolean
    ballCarrierVision?: boolean
    breakTackle?: boolean
    topBallCarrierSpeed?: boolean
    trucking?: boolean
    elusiveness?: boolean
    stiffArm?: boolean
    spinMove?: boolean
    jukeMove?: boolean
    shortYardage?: boolean
    goalLine?: boolean
    openFieldRunning?: boolean
    catching?: boolean
    catchInTraffic?: boolean
    spectacularCatch?: boolean
    contestedCatches?: boolean
    yardsAfterCatch?: boolean
    jumpBallTiming?: boolean
    routeRunning?: boolean
    shortRoute?: boolean
    mediumRoute?: boolean
    deepRoute?: boolean
    separation?: boolean
    release?: boolean
    runBlocking?: boolean
    passBlocking?: boolean
    pullBlocking?: boolean
    scrambleBlocking?: boolean
    playActionBlocking?: boolean
    screenBlocking?: boolean
    leadBlocking?: boolean
    tackling?: boolean
    blockShedding?: boolean
    blitzing?: boolean
    playRecognition?: boolean
    openFieldTackling?: boolean
    coverageAgainstTEsRBs?: boolean
    coverageAgainstSlot?: boolean
    deepCoverage?: boolean
    runDefense?: boolean
    passRush?: boolean
    finessePassRush?: boolean
    powerPassRush?: boolean
    runStopping?: boolean
    penetration?: boolean
    edgeSetting?: boolean
    disengagement?: boolean
    offensiveLineRecognition?: boolean
    hitPower?: boolean
    pressCoverage?: boolean
    offBallCoverage?: boolean
    manCoverage?: boolean
    zoneCoverage?: boolean
    ballHawking?: boolean
    interceptions?: boolean
    passDeflection?: boolean
    kickPower?: boolean
    kickAccuracy?: boolean
    puntPower?: boolean
    puntAccuracy?: boolean
    onsideKickAbility?: boolean
    kickReturnVision?: boolean
    puntReturnVision?: boolean
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    playerId?: boolean
    speed?: boolean
    acceleration?: boolean
    agility?: boolean
    changeOfDirection?: boolean
    strength?: boolean
    impactPower?: boolean
    verticalJump?: boolean
    stamina?: boolean
    toughness?: boolean
    awareness?: boolean
    discipline?: boolean
    injuryRecovery?: boolean
    throwPower?: boolean
    throwAccuracyShort?: boolean
    throwAccuracyMedium?: boolean
    throwAccuracyDeep?: boolean
    throwOnRun?: boolean
    playAction?: boolean
    pocketPresence?: boolean
    releaseTime?: boolean
    decisionMaking?: boolean
    scrambling?: boolean
    breakSack?: boolean
    fieldVision?: boolean
    ballSecurity?: boolean
    ballCarrierVision?: boolean
    breakTackle?: boolean
    topBallCarrierSpeed?: boolean
    trucking?: boolean
    elusiveness?: boolean
    stiffArm?: boolean
    spinMove?: boolean
    jukeMove?: boolean
    shortYardage?: boolean
    goalLine?: boolean
    openFieldRunning?: boolean
    catching?: boolean
    catchInTraffic?: boolean
    spectacularCatch?: boolean
    contestedCatches?: boolean
    yardsAfterCatch?: boolean
    jumpBallTiming?: boolean
    routeRunning?: boolean
    shortRoute?: boolean
    mediumRoute?: boolean
    deepRoute?: boolean
    separation?: boolean
    release?: boolean
    runBlocking?: boolean
    passBlocking?: boolean
    pullBlocking?: boolean
    scrambleBlocking?: boolean
    playActionBlocking?: boolean
    screenBlocking?: boolean
    leadBlocking?: boolean
    tackling?: boolean
    blockShedding?: boolean
    blitzing?: boolean
    playRecognition?: boolean
    openFieldTackling?: boolean
    coverageAgainstTEsRBs?: boolean
    coverageAgainstSlot?: boolean
    deepCoverage?: boolean
    runDefense?: boolean
    passRush?: boolean
    finessePassRush?: boolean
    powerPassRush?: boolean
    runStopping?: boolean
    penetration?: boolean
    edgeSetting?: boolean
    disengagement?: boolean
    offensiveLineRecognition?: boolean
    hitPower?: boolean
    pressCoverage?: boolean
    offBallCoverage?: boolean
    manCoverage?: boolean
    zoneCoverage?: boolean
    ballHawking?: boolean
    interceptions?: boolean
    passDeflection?: boolean
    kickPower?: boolean
    kickAccuracy?: boolean
    puntPower?: boolean
    puntAccuracy?: boolean
    onsideKickAbility?: boolean
    kickReturnVision?: boolean
    puntReturnVision?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "speed" | "acceleration" | "agility" | "changeOfDirection" | "strength" | "impactPower" | "verticalJump" | "stamina" | "toughness" | "awareness" | "discipline" | "injuryRecovery" | "throwPower" | "throwAccuracyShort" | "throwAccuracyMedium" | "throwAccuracyDeep" | "throwOnRun" | "playAction" | "pocketPresence" | "releaseTime" | "decisionMaking" | "scrambling" | "breakSack" | "fieldVision" | "ballSecurity" | "ballCarrierVision" | "breakTackle" | "topBallCarrierSpeed" | "trucking" | "elusiveness" | "stiffArm" | "spinMove" | "jukeMove" | "shortYardage" | "goalLine" | "openFieldRunning" | "catching" | "catchInTraffic" | "spectacularCatch" | "contestedCatches" | "yardsAfterCatch" | "jumpBallTiming" | "routeRunning" | "shortRoute" | "mediumRoute" | "deepRoute" | "separation" | "release" | "runBlocking" | "passBlocking" | "pullBlocking" | "scrambleBlocking" | "playActionBlocking" | "screenBlocking" | "leadBlocking" | "tackling" | "blockShedding" | "blitzing" | "playRecognition" | "openFieldTackling" | "coverageAgainstTEsRBs" | "coverageAgainstSlot" | "deepCoverage" | "runDefense" | "passRush" | "finessePassRush" | "powerPassRush" | "runStopping" | "penetration" | "edgeSetting" | "disengagement" | "offensiveLineRecognition" | "hitPower" | "pressCoverage" | "offBallCoverage" | "manCoverage" | "zoneCoverage" | "ballHawking" | "interceptions" | "passDeflection" | "kickPower" | "kickAccuracy" | "puntPower" | "puntAccuracy" | "onsideKickAbility" | "kickReturnVision" | "puntReturnVision", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | Rating$playerArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string | null
      speed: number | null
      acceleration: number | null
      agility: number | null
      changeOfDirection: number | null
      strength: number | null
      impactPower: number | null
      verticalJump: number | null
      stamina: number | null
      toughness: number | null
      awareness: number | null
      discipline: number | null
      injuryRecovery: number | null
      throwPower: number | null
      throwAccuracyShort: number | null
      throwAccuracyMedium: number | null
      throwAccuracyDeep: number | null
      throwOnRun: number | null
      playAction: number | null
      pocketPresence: number | null
      releaseTime: number | null
      decisionMaking: number | null
      scrambling: number | null
      breakSack: number | null
      fieldVision: number | null
      ballSecurity: number | null
      ballCarrierVision: number | null
      breakTackle: number | null
      topBallCarrierSpeed: number | null
      trucking: number | null
      elusiveness: number | null
      stiffArm: number | null
      spinMove: number | null
      jukeMove: number | null
      shortYardage: number | null
      goalLine: number | null
      openFieldRunning: number | null
      catching: number | null
      catchInTraffic: number | null
      spectacularCatch: number | null
      contestedCatches: number | null
      yardsAfterCatch: number | null
      jumpBallTiming: number | null
      routeRunning: number | null
      shortRoute: number | null
      mediumRoute: number | null
      deepRoute: number | null
      separation: number | null
      release: number | null
      runBlocking: number | null
      passBlocking: number | null
      pullBlocking: number | null
      scrambleBlocking: number | null
      playActionBlocking: number | null
      screenBlocking: number | null
      leadBlocking: number | null
      tackling: number | null
      blockShedding: number | null
      blitzing: number | null
      playRecognition: number | null
      openFieldTackling: number | null
      coverageAgainstTEsRBs: number | null
      coverageAgainstSlot: number | null
      deepCoverage: number | null
      runDefense: number | null
      passRush: number | null
      finessePassRush: number | null
      powerPassRush: number | null
      runStopping: number | null
      penetration: number | null
      edgeSetting: number | null
      disengagement: number | null
      offensiveLineRecognition: number | null
      hitPower: number | null
      pressCoverage: number | null
      offBallCoverage: number | null
      manCoverage: number | null
      zoneCoverage: number | null
      ballHawking: number | null
      interceptions: number | null
      passDeflection: number | null
      kickPower: number | null
      kickAccuracy: number | null
      puntPower: number | null
      puntAccuracy: number | null
      onsideKickAbility: number | null
      kickReturnVision: number | null
      puntReturnVision: number | null
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends Rating$playerArgs<ExtArgs> = {}>(args?: Subset<T, Rating$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'String'>
    readonly playerId: FieldRef<"Rating", 'String'>
    readonly speed: FieldRef<"Rating", 'Int'>
    readonly acceleration: FieldRef<"Rating", 'Int'>
    readonly agility: FieldRef<"Rating", 'Int'>
    readonly changeOfDirection: FieldRef<"Rating", 'Int'>
    readonly strength: FieldRef<"Rating", 'Int'>
    readonly impactPower: FieldRef<"Rating", 'Int'>
    readonly verticalJump: FieldRef<"Rating", 'Int'>
    readonly stamina: FieldRef<"Rating", 'Int'>
    readonly toughness: FieldRef<"Rating", 'Int'>
    readonly awareness: FieldRef<"Rating", 'Int'>
    readonly discipline: FieldRef<"Rating", 'Int'>
    readonly injuryRecovery: FieldRef<"Rating", 'Int'>
    readonly throwPower: FieldRef<"Rating", 'Int'>
    readonly throwAccuracyShort: FieldRef<"Rating", 'Int'>
    readonly throwAccuracyMedium: FieldRef<"Rating", 'Int'>
    readonly throwAccuracyDeep: FieldRef<"Rating", 'Int'>
    readonly throwOnRun: FieldRef<"Rating", 'Int'>
    readonly playAction: FieldRef<"Rating", 'Int'>
    readonly pocketPresence: FieldRef<"Rating", 'Int'>
    readonly releaseTime: FieldRef<"Rating", 'Int'>
    readonly decisionMaking: FieldRef<"Rating", 'Int'>
    readonly scrambling: FieldRef<"Rating", 'Int'>
    readonly breakSack: FieldRef<"Rating", 'Int'>
    readonly fieldVision: FieldRef<"Rating", 'Int'>
    readonly ballSecurity: FieldRef<"Rating", 'Int'>
    readonly ballCarrierVision: FieldRef<"Rating", 'Int'>
    readonly breakTackle: FieldRef<"Rating", 'Int'>
    readonly topBallCarrierSpeed: FieldRef<"Rating", 'Int'>
    readonly trucking: FieldRef<"Rating", 'Int'>
    readonly elusiveness: FieldRef<"Rating", 'Int'>
    readonly stiffArm: FieldRef<"Rating", 'Int'>
    readonly spinMove: FieldRef<"Rating", 'Int'>
    readonly jukeMove: FieldRef<"Rating", 'Int'>
    readonly shortYardage: FieldRef<"Rating", 'Int'>
    readonly goalLine: FieldRef<"Rating", 'Int'>
    readonly openFieldRunning: FieldRef<"Rating", 'Int'>
    readonly catching: FieldRef<"Rating", 'Int'>
    readonly catchInTraffic: FieldRef<"Rating", 'Int'>
    readonly spectacularCatch: FieldRef<"Rating", 'Int'>
    readonly contestedCatches: FieldRef<"Rating", 'Int'>
    readonly yardsAfterCatch: FieldRef<"Rating", 'Int'>
    readonly jumpBallTiming: FieldRef<"Rating", 'Int'>
    readonly routeRunning: FieldRef<"Rating", 'Int'>
    readonly shortRoute: FieldRef<"Rating", 'Int'>
    readonly mediumRoute: FieldRef<"Rating", 'Int'>
    readonly deepRoute: FieldRef<"Rating", 'Int'>
    readonly separation: FieldRef<"Rating", 'Int'>
    readonly release: FieldRef<"Rating", 'Int'>
    readonly runBlocking: FieldRef<"Rating", 'Int'>
    readonly passBlocking: FieldRef<"Rating", 'Int'>
    readonly pullBlocking: FieldRef<"Rating", 'Int'>
    readonly scrambleBlocking: FieldRef<"Rating", 'Int'>
    readonly playActionBlocking: FieldRef<"Rating", 'Int'>
    readonly screenBlocking: FieldRef<"Rating", 'Int'>
    readonly leadBlocking: FieldRef<"Rating", 'Int'>
    readonly tackling: FieldRef<"Rating", 'Int'>
    readonly blockShedding: FieldRef<"Rating", 'Int'>
    readonly blitzing: FieldRef<"Rating", 'Int'>
    readonly playRecognition: FieldRef<"Rating", 'Int'>
    readonly openFieldTackling: FieldRef<"Rating", 'Int'>
    readonly coverageAgainstTEsRBs: FieldRef<"Rating", 'Int'>
    readonly coverageAgainstSlot: FieldRef<"Rating", 'Int'>
    readonly deepCoverage: FieldRef<"Rating", 'Int'>
    readonly runDefense: FieldRef<"Rating", 'Int'>
    readonly passRush: FieldRef<"Rating", 'Int'>
    readonly finessePassRush: FieldRef<"Rating", 'Int'>
    readonly powerPassRush: FieldRef<"Rating", 'Int'>
    readonly runStopping: FieldRef<"Rating", 'Int'>
    readonly penetration: FieldRef<"Rating", 'Int'>
    readonly edgeSetting: FieldRef<"Rating", 'Int'>
    readonly disengagement: FieldRef<"Rating", 'Int'>
    readonly offensiveLineRecognition: FieldRef<"Rating", 'Int'>
    readonly hitPower: FieldRef<"Rating", 'Int'>
    readonly pressCoverage: FieldRef<"Rating", 'Int'>
    readonly offBallCoverage: FieldRef<"Rating", 'Int'>
    readonly manCoverage: FieldRef<"Rating", 'Int'>
    readonly zoneCoverage: FieldRef<"Rating", 'Int'>
    readonly ballHawking: FieldRef<"Rating", 'Int'>
    readonly interceptions: FieldRef<"Rating", 'Int'>
    readonly passDeflection: FieldRef<"Rating", 'Int'>
    readonly kickPower: FieldRef<"Rating", 'Int'>
    readonly kickAccuracy: FieldRef<"Rating", 'Int'>
    readonly puntPower: FieldRef<"Rating", 'Int'>
    readonly puntAccuracy: FieldRef<"Rating", 'Int'>
    readonly onsideKickAbility: FieldRef<"Rating", 'Int'>
    readonly kickReturnVision: FieldRef<"Rating", 'Int'>
    readonly puntReturnVision: FieldRef<"Rating", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data?: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating.player
   */
  export type Rating$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model Stat
   */

  export type AggregateStat = {
    _count: StatCountAggregateOutputType | null
    _avg: StatAvgAggregateOutputType | null
    _sum: StatSumAggregateOutputType | null
    _min: StatMinAggregateOutputType | null
    _max: StatMaxAggregateOutputType | null
  }

  export type StatAvgAggregateOutputType = {
    season: number | null
    gamesPlayed: number | null
    gamesStarted: number | null
    snaps: number | null
    rushingAttempts: number | null
    rushingYards: number | null
    yardsPerCarry: number | null
    yardsAfterContact: number | null
    yardsPerGame: number | null
    rushingLong: number | null
    rushingTouchdowns: number | null
    fumblesLost: number | null
    receptions: number | null
    receivingYards: number | null
    yardsPerReception: number | null
    yardsAfterCatch: number | null
    yardsPerTarget: number | null
    airYards: number | null
    receivingLong: number | null
    targets: number | null
    receivingTouchdowns: number | null
    drops: number | null
    passingAttempts: number | null
    passingCompletions: number | null
    passingYards: number | null
    yardsPerPass: number | null
    yardsPerCompletion: number | null
    completionPercentage: number | null
    passingTouchdowns: number | null
    interceptions: number | null
    sacksTaken: number | null
    passerRating: number | null
    pancakes: number | null
    sacksAllowed: number | null
    hurriesAllowed: number | null
    tackles: number | null
    tacklesForLoss: number | null
    sacks: number | null
    interceptionsMade: number | null
    forcedFumbles: number | null
    fumbleRecoveries: number | null
    passesDefended: number | null
    defensiveTouchdowns: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    punts: number | null
    puntYards: number | null
    kickReturns: number | null
    kickReturnYards: number | null
    puntReturns: number | null
    puntReturnYards: number | null
    specialTeamsTouchdowns: number | null
    penaltiesCommitted: number | null
    penaltyYards: number | null
  }

  export type StatSumAggregateOutputType = {
    season: number | null
    gamesPlayed: number | null
    gamesStarted: number | null
    snaps: number | null
    rushingAttempts: number | null
    rushingYards: number | null
    yardsPerCarry: number | null
    yardsAfterContact: number | null
    yardsPerGame: number | null
    rushingLong: number | null
    rushingTouchdowns: number | null
    fumblesLost: number | null
    receptions: number | null
    receivingYards: number | null
    yardsPerReception: number | null
    yardsAfterCatch: number | null
    yardsPerTarget: number | null
    airYards: number | null
    receivingLong: number | null
    targets: number | null
    receivingTouchdowns: number | null
    drops: number | null
    passingAttempts: number | null
    passingCompletions: number | null
    passingYards: number | null
    yardsPerPass: number | null
    yardsPerCompletion: number | null
    completionPercentage: number | null
    passingTouchdowns: number | null
    interceptions: number | null
    sacksTaken: number | null
    passerRating: number | null
    pancakes: number | null
    sacksAllowed: number | null
    hurriesAllowed: number | null
    tackles: number | null
    tacklesForLoss: number | null
    sacks: number | null
    interceptionsMade: number | null
    forcedFumbles: number | null
    fumbleRecoveries: number | null
    passesDefended: number | null
    defensiveTouchdowns: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    punts: number | null
    puntYards: number | null
    kickReturns: number | null
    kickReturnYards: number | null
    puntReturns: number | null
    puntReturnYards: number | null
    specialTeamsTouchdowns: number | null
    penaltiesCommitted: number | null
    penaltyYards: number | null
  }

  export type StatMinAggregateOutputType = {
    id: string | null
    season: number | null
    playerId: string | null
    gamesPlayed: number | null
    gamesStarted: number | null
    snaps: number | null
    rushingAttempts: number | null
    rushingYards: number | null
    yardsPerCarry: number | null
    yardsAfterContact: number | null
    yardsPerGame: number | null
    rushingLong: number | null
    rushingTouchdowns: number | null
    fumblesLost: number | null
    receptions: number | null
    receivingYards: number | null
    yardsPerReception: number | null
    yardsAfterCatch: number | null
    yardsPerTarget: number | null
    airYards: number | null
    receivingLong: number | null
    targets: number | null
    receivingTouchdowns: number | null
    drops: number | null
    passingAttempts: number | null
    passingCompletions: number | null
    passingYards: number | null
    yardsPerPass: number | null
    yardsPerCompletion: number | null
    completionPercentage: number | null
    passingTouchdowns: number | null
    interceptions: number | null
    sacksTaken: number | null
    passerRating: number | null
    pancakes: number | null
    sacksAllowed: number | null
    hurriesAllowed: number | null
    tackles: number | null
    tacklesForLoss: number | null
    sacks: number | null
    interceptionsMade: number | null
    forcedFumbles: number | null
    fumbleRecoveries: number | null
    passesDefended: number | null
    defensiveTouchdowns: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    punts: number | null
    puntYards: number | null
    kickReturns: number | null
    kickReturnYards: number | null
    puntReturns: number | null
    puntReturnYards: number | null
    specialTeamsTouchdowns: number | null
    penaltiesCommitted: number | null
    penaltyYards: number | null
  }

  export type StatMaxAggregateOutputType = {
    id: string | null
    season: number | null
    playerId: string | null
    gamesPlayed: number | null
    gamesStarted: number | null
    snaps: number | null
    rushingAttempts: number | null
    rushingYards: number | null
    yardsPerCarry: number | null
    yardsAfterContact: number | null
    yardsPerGame: number | null
    rushingLong: number | null
    rushingTouchdowns: number | null
    fumblesLost: number | null
    receptions: number | null
    receivingYards: number | null
    yardsPerReception: number | null
    yardsAfterCatch: number | null
    yardsPerTarget: number | null
    airYards: number | null
    receivingLong: number | null
    targets: number | null
    receivingTouchdowns: number | null
    drops: number | null
    passingAttempts: number | null
    passingCompletions: number | null
    passingYards: number | null
    yardsPerPass: number | null
    yardsPerCompletion: number | null
    completionPercentage: number | null
    passingTouchdowns: number | null
    interceptions: number | null
    sacksTaken: number | null
    passerRating: number | null
    pancakes: number | null
    sacksAllowed: number | null
    hurriesAllowed: number | null
    tackles: number | null
    tacklesForLoss: number | null
    sacks: number | null
    interceptionsMade: number | null
    forcedFumbles: number | null
    fumbleRecoveries: number | null
    passesDefended: number | null
    defensiveTouchdowns: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    punts: number | null
    puntYards: number | null
    kickReturns: number | null
    kickReturnYards: number | null
    puntReturns: number | null
    puntReturnYards: number | null
    specialTeamsTouchdowns: number | null
    penaltiesCommitted: number | null
    penaltyYards: number | null
  }

  export type StatCountAggregateOutputType = {
    id: number
    season: number
    playerId: number
    gamesPlayed: number
    gamesStarted: number
    snaps: number
    rushingAttempts: number
    rushingYards: number
    yardsPerCarry: number
    yardsAfterContact: number
    yardsPerGame: number
    rushingLong: number
    rushingTouchdowns: number
    fumblesLost: number
    receptions: number
    receivingYards: number
    yardsPerReception: number
    yardsAfterCatch: number
    yardsPerTarget: number
    airYards: number
    receivingLong: number
    targets: number
    receivingTouchdowns: number
    drops: number
    passingAttempts: number
    passingCompletions: number
    passingYards: number
    yardsPerPass: number
    yardsPerCompletion: number
    completionPercentage: number
    passingTouchdowns: number
    interceptions: number
    sacksTaken: number
    passerRating: number
    pancakes: number
    sacksAllowed: number
    hurriesAllowed: number
    tackles: number
    tacklesForLoss: number
    sacks: number
    interceptionsMade: number
    forcedFumbles: number
    fumbleRecoveries: number
    passesDefended: number
    defensiveTouchdowns: number
    fieldGoalsMade: number
    fieldGoalsAttempted: number
    extraPointsMade: number
    extraPointsAttempted: number
    punts: number
    puntYards: number
    kickReturns: number
    kickReturnYards: number
    puntReturns: number
    puntReturnYards: number
    specialTeamsTouchdowns: number
    penaltiesCommitted: number
    penaltyYards: number
    _all: number
  }


  export type StatAvgAggregateInputType = {
    season?: true
    gamesPlayed?: true
    gamesStarted?: true
    snaps?: true
    rushingAttempts?: true
    rushingYards?: true
    yardsPerCarry?: true
    yardsAfterContact?: true
    yardsPerGame?: true
    rushingLong?: true
    rushingTouchdowns?: true
    fumblesLost?: true
    receptions?: true
    receivingYards?: true
    yardsPerReception?: true
    yardsAfterCatch?: true
    yardsPerTarget?: true
    airYards?: true
    receivingLong?: true
    targets?: true
    receivingTouchdowns?: true
    drops?: true
    passingAttempts?: true
    passingCompletions?: true
    passingYards?: true
    yardsPerPass?: true
    yardsPerCompletion?: true
    completionPercentage?: true
    passingTouchdowns?: true
    interceptions?: true
    sacksTaken?: true
    passerRating?: true
    pancakes?: true
    sacksAllowed?: true
    hurriesAllowed?: true
    tackles?: true
    tacklesForLoss?: true
    sacks?: true
    interceptionsMade?: true
    forcedFumbles?: true
    fumbleRecoveries?: true
    passesDefended?: true
    defensiveTouchdowns?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    punts?: true
    puntYards?: true
    kickReturns?: true
    kickReturnYards?: true
    puntReturns?: true
    puntReturnYards?: true
    specialTeamsTouchdowns?: true
    penaltiesCommitted?: true
    penaltyYards?: true
  }

  export type StatSumAggregateInputType = {
    season?: true
    gamesPlayed?: true
    gamesStarted?: true
    snaps?: true
    rushingAttempts?: true
    rushingYards?: true
    yardsPerCarry?: true
    yardsAfterContact?: true
    yardsPerGame?: true
    rushingLong?: true
    rushingTouchdowns?: true
    fumblesLost?: true
    receptions?: true
    receivingYards?: true
    yardsPerReception?: true
    yardsAfterCatch?: true
    yardsPerTarget?: true
    airYards?: true
    receivingLong?: true
    targets?: true
    receivingTouchdowns?: true
    drops?: true
    passingAttempts?: true
    passingCompletions?: true
    passingYards?: true
    yardsPerPass?: true
    yardsPerCompletion?: true
    completionPercentage?: true
    passingTouchdowns?: true
    interceptions?: true
    sacksTaken?: true
    passerRating?: true
    pancakes?: true
    sacksAllowed?: true
    hurriesAllowed?: true
    tackles?: true
    tacklesForLoss?: true
    sacks?: true
    interceptionsMade?: true
    forcedFumbles?: true
    fumbleRecoveries?: true
    passesDefended?: true
    defensiveTouchdowns?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    punts?: true
    puntYards?: true
    kickReturns?: true
    kickReturnYards?: true
    puntReturns?: true
    puntReturnYards?: true
    specialTeamsTouchdowns?: true
    penaltiesCommitted?: true
    penaltyYards?: true
  }

  export type StatMinAggregateInputType = {
    id?: true
    season?: true
    playerId?: true
    gamesPlayed?: true
    gamesStarted?: true
    snaps?: true
    rushingAttempts?: true
    rushingYards?: true
    yardsPerCarry?: true
    yardsAfterContact?: true
    yardsPerGame?: true
    rushingLong?: true
    rushingTouchdowns?: true
    fumblesLost?: true
    receptions?: true
    receivingYards?: true
    yardsPerReception?: true
    yardsAfterCatch?: true
    yardsPerTarget?: true
    airYards?: true
    receivingLong?: true
    targets?: true
    receivingTouchdowns?: true
    drops?: true
    passingAttempts?: true
    passingCompletions?: true
    passingYards?: true
    yardsPerPass?: true
    yardsPerCompletion?: true
    completionPercentage?: true
    passingTouchdowns?: true
    interceptions?: true
    sacksTaken?: true
    passerRating?: true
    pancakes?: true
    sacksAllowed?: true
    hurriesAllowed?: true
    tackles?: true
    tacklesForLoss?: true
    sacks?: true
    interceptionsMade?: true
    forcedFumbles?: true
    fumbleRecoveries?: true
    passesDefended?: true
    defensiveTouchdowns?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    punts?: true
    puntYards?: true
    kickReturns?: true
    kickReturnYards?: true
    puntReturns?: true
    puntReturnYards?: true
    specialTeamsTouchdowns?: true
    penaltiesCommitted?: true
    penaltyYards?: true
  }

  export type StatMaxAggregateInputType = {
    id?: true
    season?: true
    playerId?: true
    gamesPlayed?: true
    gamesStarted?: true
    snaps?: true
    rushingAttempts?: true
    rushingYards?: true
    yardsPerCarry?: true
    yardsAfterContact?: true
    yardsPerGame?: true
    rushingLong?: true
    rushingTouchdowns?: true
    fumblesLost?: true
    receptions?: true
    receivingYards?: true
    yardsPerReception?: true
    yardsAfterCatch?: true
    yardsPerTarget?: true
    airYards?: true
    receivingLong?: true
    targets?: true
    receivingTouchdowns?: true
    drops?: true
    passingAttempts?: true
    passingCompletions?: true
    passingYards?: true
    yardsPerPass?: true
    yardsPerCompletion?: true
    completionPercentage?: true
    passingTouchdowns?: true
    interceptions?: true
    sacksTaken?: true
    passerRating?: true
    pancakes?: true
    sacksAllowed?: true
    hurriesAllowed?: true
    tackles?: true
    tacklesForLoss?: true
    sacks?: true
    interceptionsMade?: true
    forcedFumbles?: true
    fumbleRecoveries?: true
    passesDefended?: true
    defensiveTouchdowns?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    punts?: true
    puntYards?: true
    kickReturns?: true
    kickReturnYards?: true
    puntReturns?: true
    puntReturnYards?: true
    specialTeamsTouchdowns?: true
    penaltiesCommitted?: true
    penaltyYards?: true
  }

  export type StatCountAggregateInputType = {
    id?: true
    season?: true
    playerId?: true
    gamesPlayed?: true
    gamesStarted?: true
    snaps?: true
    rushingAttempts?: true
    rushingYards?: true
    yardsPerCarry?: true
    yardsAfterContact?: true
    yardsPerGame?: true
    rushingLong?: true
    rushingTouchdowns?: true
    fumblesLost?: true
    receptions?: true
    receivingYards?: true
    yardsPerReception?: true
    yardsAfterCatch?: true
    yardsPerTarget?: true
    airYards?: true
    receivingLong?: true
    targets?: true
    receivingTouchdowns?: true
    drops?: true
    passingAttempts?: true
    passingCompletions?: true
    passingYards?: true
    yardsPerPass?: true
    yardsPerCompletion?: true
    completionPercentage?: true
    passingTouchdowns?: true
    interceptions?: true
    sacksTaken?: true
    passerRating?: true
    pancakes?: true
    sacksAllowed?: true
    hurriesAllowed?: true
    tackles?: true
    tacklesForLoss?: true
    sacks?: true
    interceptionsMade?: true
    forcedFumbles?: true
    fumbleRecoveries?: true
    passesDefended?: true
    defensiveTouchdowns?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    punts?: true
    puntYards?: true
    kickReturns?: true
    kickReturnYards?: true
    puntReturns?: true
    puntReturnYards?: true
    specialTeamsTouchdowns?: true
    penaltiesCommitted?: true
    penaltyYards?: true
    _all?: true
  }

  export type StatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stat to aggregate.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stats
    **/
    _count?: true | StatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatMaxAggregateInputType
  }

  export type GetStatAggregateType<T extends StatAggregateArgs> = {
        [P in keyof T & keyof AggregateStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStat[P]>
      : GetScalarType<T[P], AggregateStat[P]>
  }




  export type StatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatWhereInput
    orderBy?: StatOrderByWithAggregationInput | StatOrderByWithAggregationInput[]
    by: StatScalarFieldEnum[] | StatScalarFieldEnum
    having?: StatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatCountAggregateInputType | true
    _avg?: StatAvgAggregateInputType
    _sum?: StatSumAggregateInputType
    _min?: StatMinAggregateInputType
    _max?: StatMaxAggregateInputType
  }

  export type StatGroupByOutputType = {
    id: string
    season: number | null
    playerId: string | null
    gamesPlayed: number | null
    gamesStarted: number | null
    snaps: number | null
    rushingAttempts: number | null
    rushingYards: number | null
    yardsPerCarry: number | null
    yardsAfterContact: number | null
    yardsPerGame: number | null
    rushingLong: number | null
    rushingTouchdowns: number | null
    fumblesLost: number | null
    receptions: number | null
    receivingYards: number | null
    yardsPerReception: number | null
    yardsAfterCatch: number | null
    yardsPerTarget: number | null
    airYards: number | null
    receivingLong: number | null
    targets: number | null
    receivingTouchdowns: number | null
    drops: number | null
    passingAttempts: number | null
    passingCompletions: number | null
    passingYards: number | null
    yardsPerPass: number | null
    yardsPerCompletion: number | null
    completionPercentage: number | null
    passingTouchdowns: number | null
    interceptions: number | null
    sacksTaken: number | null
    passerRating: number | null
    pancakes: number | null
    sacksAllowed: number | null
    hurriesAllowed: number | null
    tackles: number | null
    tacklesForLoss: number | null
    sacks: number | null
    interceptionsMade: number | null
    forcedFumbles: number | null
    fumbleRecoveries: number | null
    passesDefended: number | null
    defensiveTouchdowns: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    punts: number | null
    puntYards: number | null
    kickReturns: number | null
    kickReturnYards: number | null
    puntReturns: number | null
    puntReturnYards: number | null
    specialTeamsTouchdowns: number | null
    penaltiesCommitted: number | null
    penaltyYards: number | null
    _count: StatCountAggregateOutputType | null
    _avg: StatAvgAggregateOutputType | null
    _sum: StatSumAggregateOutputType | null
    _min: StatMinAggregateOutputType | null
    _max: StatMaxAggregateOutputType | null
  }

  type GetStatGroupByPayload<T extends StatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatGroupByOutputType[P]>
            : GetScalarType<T[P], StatGroupByOutputType[P]>
        }
      >
    >


  export type StatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    season?: boolean
    playerId?: boolean
    gamesPlayed?: boolean
    gamesStarted?: boolean
    snaps?: boolean
    rushingAttempts?: boolean
    rushingYards?: boolean
    yardsPerCarry?: boolean
    yardsAfterContact?: boolean
    yardsPerGame?: boolean
    rushingLong?: boolean
    rushingTouchdowns?: boolean
    fumblesLost?: boolean
    receptions?: boolean
    receivingYards?: boolean
    yardsPerReception?: boolean
    yardsAfterCatch?: boolean
    yardsPerTarget?: boolean
    airYards?: boolean
    receivingLong?: boolean
    targets?: boolean
    receivingTouchdowns?: boolean
    drops?: boolean
    passingAttempts?: boolean
    passingCompletions?: boolean
    passingYards?: boolean
    yardsPerPass?: boolean
    yardsPerCompletion?: boolean
    completionPercentage?: boolean
    passingTouchdowns?: boolean
    interceptions?: boolean
    sacksTaken?: boolean
    passerRating?: boolean
    pancakes?: boolean
    sacksAllowed?: boolean
    hurriesAllowed?: boolean
    tackles?: boolean
    tacklesForLoss?: boolean
    sacks?: boolean
    interceptionsMade?: boolean
    forcedFumbles?: boolean
    fumbleRecoveries?: boolean
    passesDefended?: boolean
    defensiveTouchdowns?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    punts?: boolean
    puntYards?: boolean
    kickReturns?: boolean
    kickReturnYards?: boolean
    puntReturns?: boolean
    puntReturnYards?: boolean
    specialTeamsTouchdowns?: boolean
    penaltiesCommitted?: boolean
    penaltyYards?: boolean
    player?: boolean | Stat$playerArgs<ExtArgs>
  }, ExtArgs["result"]["stat"]>

  export type StatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    season?: boolean
    playerId?: boolean
    gamesPlayed?: boolean
    gamesStarted?: boolean
    snaps?: boolean
    rushingAttempts?: boolean
    rushingYards?: boolean
    yardsPerCarry?: boolean
    yardsAfterContact?: boolean
    yardsPerGame?: boolean
    rushingLong?: boolean
    rushingTouchdowns?: boolean
    fumblesLost?: boolean
    receptions?: boolean
    receivingYards?: boolean
    yardsPerReception?: boolean
    yardsAfterCatch?: boolean
    yardsPerTarget?: boolean
    airYards?: boolean
    receivingLong?: boolean
    targets?: boolean
    receivingTouchdowns?: boolean
    drops?: boolean
    passingAttempts?: boolean
    passingCompletions?: boolean
    passingYards?: boolean
    yardsPerPass?: boolean
    yardsPerCompletion?: boolean
    completionPercentage?: boolean
    passingTouchdowns?: boolean
    interceptions?: boolean
    sacksTaken?: boolean
    passerRating?: boolean
    pancakes?: boolean
    sacksAllowed?: boolean
    hurriesAllowed?: boolean
    tackles?: boolean
    tacklesForLoss?: boolean
    sacks?: boolean
    interceptionsMade?: boolean
    forcedFumbles?: boolean
    fumbleRecoveries?: boolean
    passesDefended?: boolean
    defensiveTouchdowns?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    punts?: boolean
    puntYards?: boolean
    kickReturns?: boolean
    kickReturnYards?: boolean
    puntReturns?: boolean
    puntReturnYards?: boolean
    specialTeamsTouchdowns?: boolean
    penaltiesCommitted?: boolean
    penaltyYards?: boolean
  }, ExtArgs["result"]["stat"]>

  export type StatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    season?: boolean
    playerId?: boolean
    gamesPlayed?: boolean
    gamesStarted?: boolean
    snaps?: boolean
    rushingAttempts?: boolean
    rushingYards?: boolean
    yardsPerCarry?: boolean
    yardsAfterContact?: boolean
    yardsPerGame?: boolean
    rushingLong?: boolean
    rushingTouchdowns?: boolean
    fumblesLost?: boolean
    receptions?: boolean
    receivingYards?: boolean
    yardsPerReception?: boolean
    yardsAfterCatch?: boolean
    yardsPerTarget?: boolean
    airYards?: boolean
    receivingLong?: boolean
    targets?: boolean
    receivingTouchdowns?: boolean
    drops?: boolean
    passingAttempts?: boolean
    passingCompletions?: boolean
    passingYards?: boolean
    yardsPerPass?: boolean
    yardsPerCompletion?: boolean
    completionPercentage?: boolean
    passingTouchdowns?: boolean
    interceptions?: boolean
    sacksTaken?: boolean
    passerRating?: boolean
    pancakes?: boolean
    sacksAllowed?: boolean
    hurriesAllowed?: boolean
    tackles?: boolean
    tacklesForLoss?: boolean
    sacks?: boolean
    interceptionsMade?: boolean
    forcedFumbles?: boolean
    fumbleRecoveries?: boolean
    passesDefended?: boolean
    defensiveTouchdowns?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    punts?: boolean
    puntYards?: boolean
    kickReturns?: boolean
    kickReturnYards?: boolean
    puntReturns?: boolean
    puntReturnYards?: boolean
    specialTeamsTouchdowns?: boolean
    penaltiesCommitted?: boolean
    penaltyYards?: boolean
  }, ExtArgs["result"]["stat"]>

  export type StatSelectScalar = {
    id?: boolean
    season?: boolean
    playerId?: boolean
    gamesPlayed?: boolean
    gamesStarted?: boolean
    snaps?: boolean
    rushingAttempts?: boolean
    rushingYards?: boolean
    yardsPerCarry?: boolean
    yardsAfterContact?: boolean
    yardsPerGame?: boolean
    rushingLong?: boolean
    rushingTouchdowns?: boolean
    fumblesLost?: boolean
    receptions?: boolean
    receivingYards?: boolean
    yardsPerReception?: boolean
    yardsAfterCatch?: boolean
    yardsPerTarget?: boolean
    airYards?: boolean
    receivingLong?: boolean
    targets?: boolean
    receivingTouchdowns?: boolean
    drops?: boolean
    passingAttempts?: boolean
    passingCompletions?: boolean
    passingYards?: boolean
    yardsPerPass?: boolean
    yardsPerCompletion?: boolean
    completionPercentage?: boolean
    passingTouchdowns?: boolean
    interceptions?: boolean
    sacksTaken?: boolean
    passerRating?: boolean
    pancakes?: boolean
    sacksAllowed?: boolean
    hurriesAllowed?: boolean
    tackles?: boolean
    tacklesForLoss?: boolean
    sacks?: boolean
    interceptionsMade?: boolean
    forcedFumbles?: boolean
    fumbleRecoveries?: boolean
    passesDefended?: boolean
    defensiveTouchdowns?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    punts?: boolean
    puntYards?: boolean
    kickReturns?: boolean
    kickReturnYards?: boolean
    puntReturns?: boolean
    puntReturnYards?: boolean
    specialTeamsTouchdowns?: boolean
    penaltiesCommitted?: boolean
    penaltyYards?: boolean
  }

  export type StatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "season" | "playerId" | "gamesPlayed" | "gamesStarted" | "snaps" | "rushingAttempts" | "rushingYards" | "yardsPerCarry" | "yardsAfterContact" | "yardsPerGame" | "rushingLong" | "rushingTouchdowns" | "fumblesLost" | "receptions" | "receivingYards" | "yardsPerReception" | "yardsAfterCatch" | "yardsPerTarget" | "airYards" | "receivingLong" | "targets" | "receivingTouchdowns" | "drops" | "passingAttempts" | "passingCompletions" | "passingYards" | "yardsPerPass" | "yardsPerCompletion" | "completionPercentage" | "passingTouchdowns" | "interceptions" | "sacksTaken" | "passerRating" | "pancakes" | "sacksAllowed" | "hurriesAllowed" | "tackles" | "tacklesForLoss" | "sacks" | "interceptionsMade" | "forcedFumbles" | "fumbleRecoveries" | "passesDefended" | "defensiveTouchdowns" | "fieldGoalsMade" | "fieldGoalsAttempted" | "extraPointsMade" | "extraPointsAttempted" | "punts" | "puntYards" | "kickReturns" | "kickReturnYards" | "puntReturns" | "puntReturnYards" | "specialTeamsTouchdowns" | "penaltiesCommitted" | "penaltyYards", ExtArgs["result"]["stat"]>
  export type StatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | Stat$playerArgs<ExtArgs>
  }
  export type StatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stat"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      season: number | null
      playerId: string | null
      gamesPlayed: number | null
      gamesStarted: number | null
      snaps: number | null
      rushingAttempts: number | null
      rushingYards: number | null
      yardsPerCarry: number | null
      yardsAfterContact: number | null
      yardsPerGame: number | null
      rushingLong: number | null
      rushingTouchdowns: number | null
      fumblesLost: number | null
      receptions: number | null
      receivingYards: number | null
      yardsPerReception: number | null
      yardsAfterCatch: number | null
      yardsPerTarget: number | null
      airYards: number | null
      receivingLong: number | null
      targets: number | null
      receivingTouchdowns: number | null
      drops: number | null
      passingAttempts: number | null
      passingCompletions: number | null
      passingYards: number | null
      yardsPerPass: number | null
      yardsPerCompletion: number | null
      completionPercentage: number | null
      passingTouchdowns: number | null
      interceptions: number | null
      sacksTaken: number | null
      passerRating: number | null
      pancakes: number | null
      sacksAllowed: number | null
      hurriesAllowed: number | null
      tackles: number | null
      tacklesForLoss: number | null
      sacks: number | null
      interceptionsMade: number | null
      forcedFumbles: number | null
      fumbleRecoveries: number | null
      passesDefended: number | null
      defensiveTouchdowns: number | null
      fieldGoalsMade: number | null
      fieldGoalsAttempted: number | null
      extraPointsMade: number | null
      extraPointsAttempted: number | null
      punts: number | null
      puntYards: number | null
      kickReturns: number | null
      kickReturnYards: number | null
      puntReturns: number | null
      puntReturnYards: number | null
      specialTeamsTouchdowns: number | null
      penaltiesCommitted: number | null
      penaltyYards: number | null
    }, ExtArgs["result"]["stat"]>
    composites: {}
  }

  type StatGetPayload<S extends boolean | null | undefined | StatDefaultArgs> = $Result.GetResult<Prisma.$StatPayload, S>

  type StatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatCountAggregateInputType | true
    }

  export interface StatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stat'], meta: { name: 'Stat' } }
    /**
     * Find zero or one Stat that matches the filter.
     * @param {StatFindUniqueArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatFindUniqueArgs>(args: SelectSubset<T, StatFindUniqueArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatFindUniqueOrThrowArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatFindUniqueOrThrowArgs>(args: SelectSubset<T, StatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindFirstArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatFindFirstArgs>(args?: SelectSubset<T, StatFindFirstArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindFirstOrThrowArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatFindFirstOrThrowArgs>(args?: SelectSubset<T, StatFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stats
     * const stats = await prisma.stat.findMany()
     * 
     * // Get first 10 Stats
     * const stats = await prisma.stat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statWithIdOnly = await prisma.stat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatFindManyArgs>(args?: SelectSubset<T, StatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stat.
     * @param {StatCreateArgs} args - Arguments to create a Stat.
     * @example
     * // Create one Stat
     * const Stat = await prisma.stat.create({
     *   data: {
     *     // ... data to create a Stat
     *   }
     * })
     * 
     */
    create<T extends StatCreateArgs>(args: SelectSubset<T, StatCreateArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stats.
     * @param {StatCreateManyArgs} args - Arguments to create many Stats.
     * @example
     * // Create many Stats
     * const stat = await prisma.stat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatCreateManyArgs>(args?: SelectSubset<T, StatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stats and returns the data saved in the database.
     * @param {StatCreateManyAndReturnArgs} args - Arguments to create many Stats.
     * @example
     * // Create many Stats
     * const stat = await prisma.stat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stats and only return the `id`
     * const statWithIdOnly = await prisma.stat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatCreateManyAndReturnArgs>(args?: SelectSubset<T, StatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stat.
     * @param {StatDeleteArgs} args - Arguments to delete one Stat.
     * @example
     * // Delete one Stat
     * const Stat = await prisma.stat.delete({
     *   where: {
     *     // ... filter to delete one Stat
     *   }
     * })
     * 
     */
    delete<T extends StatDeleteArgs>(args: SelectSubset<T, StatDeleteArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stat.
     * @param {StatUpdateArgs} args - Arguments to update one Stat.
     * @example
     * // Update one Stat
     * const stat = await prisma.stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatUpdateArgs>(args: SelectSubset<T, StatUpdateArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stats.
     * @param {StatDeleteManyArgs} args - Arguments to filter Stats to delete.
     * @example
     * // Delete a few Stats
     * const { count } = await prisma.stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatDeleteManyArgs>(args?: SelectSubset<T, StatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stats
     * const stat = await prisma.stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatUpdateManyArgs>(args: SelectSubset<T, StatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stats and returns the data updated in the database.
     * @param {StatUpdateManyAndReturnArgs} args - Arguments to update many Stats.
     * @example
     * // Update many Stats
     * const stat = await prisma.stat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stats and only return the `id`
     * const statWithIdOnly = await prisma.stat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatUpdateManyAndReturnArgs>(args: SelectSubset<T, StatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stat.
     * @param {StatUpsertArgs} args - Arguments to update or create a Stat.
     * @example
     * // Update or create a Stat
     * const stat = await prisma.stat.upsert({
     *   create: {
     *     // ... data to create a Stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stat we want to update
     *   }
     * })
     */
    upsert<T extends StatUpsertArgs>(args: SelectSubset<T, StatUpsertArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatCountArgs} args - Arguments to filter Stats to count.
     * @example
     * // Count the number of Stats
     * const count = await prisma.stat.count({
     *   where: {
     *     // ... the filter for the Stats we want to count
     *   }
     * })
    **/
    count<T extends StatCountArgs>(
      args?: Subset<T, StatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatAggregateArgs>(args: Subset<T, StatAggregateArgs>): Prisma.PrismaPromise<GetStatAggregateType<T>>

    /**
     * Group by Stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatGroupByArgs['orderBy'] }
        : { orderBy?: StatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stat model
   */
  readonly fields: StatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends Stat$playerArgs<ExtArgs> = {}>(args?: Subset<T, Stat$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stat model
   */
  interface StatFieldRefs {
    readonly id: FieldRef<"Stat", 'String'>
    readonly season: FieldRef<"Stat", 'Int'>
    readonly playerId: FieldRef<"Stat", 'String'>
    readonly gamesPlayed: FieldRef<"Stat", 'Int'>
    readonly gamesStarted: FieldRef<"Stat", 'Int'>
    readonly snaps: FieldRef<"Stat", 'Int'>
    readonly rushingAttempts: FieldRef<"Stat", 'Int'>
    readonly rushingYards: FieldRef<"Stat", 'Int'>
    readonly yardsPerCarry: FieldRef<"Stat", 'Float'>
    readonly yardsAfterContact: FieldRef<"Stat", 'Int'>
    readonly yardsPerGame: FieldRef<"Stat", 'Float'>
    readonly rushingLong: FieldRef<"Stat", 'Int'>
    readonly rushingTouchdowns: FieldRef<"Stat", 'Int'>
    readonly fumblesLost: FieldRef<"Stat", 'Int'>
    readonly receptions: FieldRef<"Stat", 'Int'>
    readonly receivingYards: FieldRef<"Stat", 'Int'>
    readonly yardsPerReception: FieldRef<"Stat", 'Float'>
    readonly yardsAfterCatch: FieldRef<"Stat", 'Int'>
    readonly yardsPerTarget: FieldRef<"Stat", 'Float'>
    readonly airYards: FieldRef<"Stat", 'Int'>
    readonly receivingLong: FieldRef<"Stat", 'Int'>
    readonly targets: FieldRef<"Stat", 'Int'>
    readonly receivingTouchdowns: FieldRef<"Stat", 'Int'>
    readonly drops: FieldRef<"Stat", 'Int'>
    readonly passingAttempts: FieldRef<"Stat", 'Int'>
    readonly passingCompletions: FieldRef<"Stat", 'Int'>
    readonly passingYards: FieldRef<"Stat", 'Int'>
    readonly yardsPerPass: FieldRef<"Stat", 'Float'>
    readonly yardsPerCompletion: FieldRef<"Stat", 'Float'>
    readonly completionPercentage: FieldRef<"Stat", 'Float'>
    readonly passingTouchdowns: FieldRef<"Stat", 'Int'>
    readonly interceptions: FieldRef<"Stat", 'Int'>
    readonly sacksTaken: FieldRef<"Stat", 'Int'>
    readonly passerRating: FieldRef<"Stat", 'Float'>
    readonly pancakes: FieldRef<"Stat", 'Int'>
    readonly sacksAllowed: FieldRef<"Stat", 'Int'>
    readonly hurriesAllowed: FieldRef<"Stat", 'Int'>
    readonly tackles: FieldRef<"Stat", 'Int'>
    readonly tacklesForLoss: FieldRef<"Stat", 'Int'>
    readonly sacks: FieldRef<"Stat", 'Int'>
    readonly interceptionsMade: FieldRef<"Stat", 'Int'>
    readonly forcedFumbles: FieldRef<"Stat", 'Int'>
    readonly fumbleRecoveries: FieldRef<"Stat", 'Int'>
    readonly passesDefended: FieldRef<"Stat", 'Int'>
    readonly defensiveTouchdowns: FieldRef<"Stat", 'Int'>
    readonly fieldGoalsMade: FieldRef<"Stat", 'Int'>
    readonly fieldGoalsAttempted: FieldRef<"Stat", 'Int'>
    readonly extraPointsMade: FieldRef<"Stat", 'Int'>
    readonly extraPointsAttempted: FieldRef<"Stat", 'Int'>
    readonly punts: FieldRef<"Stat", 'Int'>
    readonly puntYards: FieldRef<"Stat", 'Int'>
    readonly kickReturns: FieldRef<"Stat", 'Int'>
    readonly kickReturnYards: FieldRef<"Stat", 'Int'>
    readonly puntReturns: FieldRef<"Stat", 'Int'>
    readonly puntReturnYards: FieldRef<"Stat", 'Int'>
    readonly specialTeamsTouchdowns: FieldRef<"Stat", 'Int'>
    readonly penaltiesCommitted: FieldRef<"Stat", 'Int'>
    readonly penaltyYards: FieldRef<"Stat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Stat findUnique
   */
  export type StatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat findUniqueOrThrow
   */
  export type StatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat findFirst
   */
  export type StatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stats.
     */
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat findFirstOrThrow
   */
  export type StatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stats.
     */
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat findMany
   */
  export type StatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stats to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat create
   */
  export type StatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The data needed to create a Stat.
     */
    data?: XOR<StatCreateInput, StatUncheckedCreateInput>
  }

  /**
   * Stat createMany
   */
  export type StatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stats.
     */
    data: StatCreateManyInput | StatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stat createManyAndReturn
   */
  export type StatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * The data used to create many Stats.
     */
    data: StatCreateManyInput | StatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stat update
   */
  export type StatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The data needed to update a Stat.
     */
    data: XOR<StatUpdateInput, StatUncheckedUpdateInput>
    /**
     * Choose, which Stat to update.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat updateMany
   */
  export type StatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stats.
     */
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyInput>
    /**
     * Filter which Stats to update
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to update.
     */
    limit?: number
  }

  /**
   * Stat updateManyAndReturn
   */
  export type StatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * The data used to update Stats.
     */
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyInput>
    /**
     * Filter which Stats to update
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to update.
     */
    limit?: number
  }

  /**
   * Stat upsert
   */
  export type StatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The filter to search for the Stat to update in case it exists.
     */
    where: StatWhereUniqueInput
    /**
     * In case the Stat found by the `where` argument doesn't exist, create a new Stat with this data.
     */
    create: XOR<StatCreateInput, StatUncheckedCreateInput>
    /**
     * In case the Stat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatUpdateInput, StatUncheckedUpdateInput>
  }

  /**
   * Stat delete
   */
  export type StatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter which Stat to delete.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat deleteMany
   */
  export type StatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stats to delete
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to delete.
     */
    limit?: number
  }

  /**
   * Stat.player
   */
  export type Stat$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * Stat without action
   */
  export type StatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
  }


  /**
   * Model ContractDesires
   */

  export type AggregateContractDesires = {
    _count: ContractDesiresCountAggregateOutputType | null
    _avg: ContractDesiresAvgAggregateOutputType | null
    _sum: ContractDesiresSumAggregateOutputType | null
    _min: ContractDesiresMinAggregateOutputType | null
    _max: ContractDesiresMaxAggregateOutputType | null
  }

  export type ContractDesiresAvgAggregateOutputType = {
    years: number | null
    averageSalary: number | null
    totalGuaranteed: number | null
    optOutYears: number | null
  }

  export type ContractDesiresSumAggregateOutputType = {
    years: number | null
    averageSalary: number | null
    totalGuaranteed: number | null
    optOutYears: number[]
  }

  export type ContractDesiresMinAggregateOutputType = {
    id: string | null
    years: number | null
    averageSalary: number | null
    totalGuaranteed: number | null
    tradeClause: boolean | null
    injuryGuarantee: boolean | null
    isPlayerOptOut: boolean | null
    isTeamOptOut: boolean | null
    playerId: string | null
  }

  export type ContractDesiresMaxAggregateOutputType = {
    id: string | null
    years: number | null
    averageSalary: number | null
    totalGuaranteed: number | null
    tradeClause: boolean | null
    injuryGuarantee: boolean | null
    isPlayerOptOut: boolean | null
    isTeamOptOut: boolean | null
    playerId: string | null
  }

  export type ContractDesiresCountAggregateOutputType = {
    id: number
    years: number
    averageSalary: number
    totalGuaranteed: number
    bonuses: number
    tradeClause: number
    injuryGuarantee: number
    rosterBonus: number
    workoutBonus: number
    incentives: number
    optOutYears: number
    isPlayerOptOut: number
    isTeamOptOut: number
    playerId: number
    _all: number
  }


  export type ContractDesiresAvgAggregateInputType = {
    years?: true
    averageSalary?: true
    totalGuaranteed?: true
    optOutYears?: true
  }

  export type ContractDesiresSumAggregateInputType = {
    years?: true
    averageSalary?: true
    totalGuaranteed?: true
    optOutYears?: true
  }

  export type ContractDesiresMinAggregateInputType = {
    id?: true
    years?: true
    averageSalary?: true
    totalGuaranteed?: true
    tradeClause?: true
    injuryGuarantee?: true
    isPlayerOptOut?: true
    isTeamOptOut?: true
    playerId?: true
  }

  export type ContractDesiresMaxAggregateInputType = {
    id?: true
    years?: true
    averageSalary?: true
    totalGuaranteed?: true
    tradeClause?: true
    injuryGuarantee?: true
    isPlayerOptOut?: true
    isTeamOptOut?: true
    playerId?: true
  }

  export type ContractDesiresCountAggregateInputType = {
    id?: true
    years?: true
    averageSalary?: true
    totalGuaranteed?: true
    bonuses?: true
    tradeClause?: true
    injuryGuarantee?: true
    rosterBonus?: true
    workoutBonus?: true
    incentives?: true
    optOutYears?: true
    isPlayerOptOut?: true
    isTeamOptOut?: true
    playerId?: true
    _all?: true
  }

  export type ContractDesiresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractDesires to aggregate.
     */
    where?: ContractDesiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDesires to fetch.
     */
    orderBy?: ContractDesiresOrderByWithRelationInput | ContractDesiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractDesiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDesires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDesires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractDesires
    **/
    _count?: true | ContractDesiresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractDesiresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractDesiresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractDesiresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractDesiresMaxAggregateInputType
  }

  export type GetContractDesiresAggregateType<T extends ContractDesiresAggregateArgs> = {
        [P in keyof T & keyof AggregateContractDesires]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractDesires[P]>
      : GetScalarType<T[P], AggregateContractDesires[P]>
  }




  export type ContractDesiresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractDesiresWhereInput
    orderBy?: ContractDesiresOrderByWithAggregationInput | ContractDesiresOrderByWithAggregationInput[]
    by: ContractDesiresScalarFieldEnum[] | ContractDesiresScalarFieldEnum
    having?: ContractDesiresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractDesiresCountAggregateInputType | true
    _avg?: ContractDesiresAvgAggregateInputType
    _sum?: ContractDesiresSumAggregateInputType
    _min?: ContractDesiresMinAggregateInputType
    _max?: ContractDesiresMaxAggregateInputType
  }

  export type ContractDesiresGroupByOutputType = {
    id: string
    years: number | null
    averageSalary: number | null
    totalGuaranteed: number | null
    bonuses: JsonValue | null
    tradeClause: boolean | null
    injuryGuarantee: boolean | null
    rosterBonus: JsonValue | null
    workoutBonus: JsonValue | null
    incentives: JsonValue | null
    optOutYears: number[]
    isPlayerOptOut: boolean | null
    isTeamOptOut: boolean | null
    playerId: string | null
    _count: ContractDesiresCountAggregateOutputType | null
    _avg: ContractDesiresAvgAggregateOutputType | null
    _sum: ContractDesiresSumAggregateOutputType | null
    _min: ContractDesiresMinAggregateOutputType | null
    _max: ContractDesiresMaxAggregateOutputType | null
  }

  type GetContractDesiresGroupByPayload<T extends ContractDesiresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractDesiresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractDesiresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractDesiresGroupByOutputType[P]>
            : GetScalarType<T[P], ContractDesiresGroupByOutputType[P]>
        }
      >
    >


  export type ContractDesiresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    years?: boolean
    averageSalary?: boolean
    totalGuaranteed?: boolean
    bonuses?: boolean
    tradeClause?: boolean
    injuryGuarantee?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentives?: boolean
    optOutYears?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    playerId?: boolean
    player?: boolean | ContractDesires$playerArgs<ExtArgs>
    _count?: boolean | ContractDesiresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractDesires"]>

  export type ContractDesiresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    years?: boolean
    averageSalary?: boolean
    totalGuaranteed?: boolean
    bonuses?: boolean
    tradeClause?: boolean
    injuryGuarantee?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentives?: boolean
    optOutYears?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    playerId?: boolean
  }, ExtArgs["result"]["contractDesires"]>

  export type ContractDesiresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    years?: boolean
    averageSalary?: boolean
    totalGuaranteed?: boolean
    bonuses?: boolean
    tradeClause?: boolean
    injuryGuarantee?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentives?: boolean
    optOutYears?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    playerId?: boolean
  }, ExtArgs["result"]["contractDesires"]>

  export type ContractDesiresSelectScalar = {
    id?: boolean
    years?: boolean
    averageSalary?: boolean
    totalGuaranteed?: boolean
    bonuses?: boolean
    tradeClause?: boolean
    injuryGuarantee?: boolean
    rosterBonus?: boolean
    workoutBonus?: boolean
    incentives?: boolean
    optOutYears?: boolean
    isPlayerOptOut?: boolean
    isTeamOptOut?: boolean
    playerId?: boolean
  }

  export type ContractDesiresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "years" | "averageSalary" | "totalGuaranteed" | "bonuses" | "tradeClause" | "injuryGuarantee" | "rosterBonus" | "workoutBonus" | "incentives" | "optOutYears" | "isPlayerOptOut" | "isTeamOptOut" | "playerId", ExtArgs["result"]["contractDesires"]>
  export type ContractDesiresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | ContractDesires$playerArgs<ExtArgs>
    _count?: boolean | ContractDesiresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractDesiresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContractDesiresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContractDesiresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractDesires"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      years: number | null
      averageSalary: number | null
      totalGuaranteed: number | null
      bonuses: Prisma.JsonValue | null
      tradeClause: boolean | null
      injuryGuarantee: boolean | null
      rosterBonus: Prisma.JsonValue | null
      workoutBonus: Prisma.JsonValue | null
      incentives: Prisma.JsonValue | null
      optOutYears: number[]
      isPlayerOptOut: boolean | null
      isTeamOptOut: boolean | null
      playerId: string | null
    }, ExtArgs["result"]["contractDesires"]>
    composites: {}
  }

  type ContractDesiresGetPayload<S extends boolean | null | undefined | ContractDesiresDefaultArgs> = $Result.GetResult<Prisma.$ContractDesiresPayload, S>

  type ContractDesiresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractDesiresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractDesiresCountAggregateInputType | true
    }

  export interface ContractDesiresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractDesires'], meta: { name: 'ContractDesires' } }
    /**
     * Find zero or one ContractDesires that matches the filter.
     * @param {ContractDesiresFindUniqueArgs} args - Arguments to find a ContractDesires
     * @example
     * // Get one ContractDesires
     * const contractDesires = await prisma.contractDesires.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractDesiresFindUniqueArgs>(args: SelectSubset<T, ContractDesiresFindUniqueArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractDesires that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractDesiresFindUniqueOrThrowArgs} args - Arguments to find a ContractDesires
     * @example
     * // Get one ContractDesires
     * const contractDesires = await prisma.contractDesires.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractDesiresFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractDesiresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractDesires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresFindFirstArgs} args - Arguments to find a ContractDesires
     * @example
     * // Get one ContractDesires
     * const contractDesires = await prisma.contractDesires.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractDesiresFindFirstArgs>(args?: SelectSubset<T, ContractDesiresFindFirstArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractDesires that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresFindFirstOrThrowArgs} args - Arguments to find a ContractDesires
     * @example
     * // Get one ContractDesires
     * const contractDesires = await prisma.contractDesires.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractDesiresFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractDesiresFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractDesires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractDesires
     * const contractDesires = await prisma.contractDesires.findMany()
     * 
     * // Get first 10 ContractDesires
     * const contractDesires = await prisma.contractDesires.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractDesiresWithIdOnly = await prisma.contractDesires.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractDesiresFindManyArgs>(args?: SelectSubset<T, ContractDesiresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractDesires.
     * @param {ContractDesiresCreateArgs} args - Arguments to create a ContractDesires.
     * @example
     * // Create one ContractDesires
     * const ContractDesires = await prisma.contractDesires.create({
     *   data: {
     *     // ... data to create a ContractDesires
     *   }
     * })
     * 
     */
    create<T extends ContractDesiresCreateArgs>(args: SelectSubset<T, ContractDesiresCreateArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractDesires.
     * @param {ContractDesiresCreateManyArgs} args - Arguments to create many ContractDesires.
     * @example
     * // Create many ContractDesires
     * const contractDesires = await prisma.contractDesires.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractDesiresCreateManyArgs>(args?: SelectSubset<T, ContractDesiresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractDesires and returns the data saved in the database.
     * @param {ContractDesiresCreateManyAndReturnArgs} args - Arguments to create many ContractDesires.
     * @example
     * // Create many ContractDesires
     * const contractDesires = await prisma.contractDesires.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractDesires and only return the `id`
     * const contractDesiresWithIdOnly = await prisma.contractDesires.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractDesiresCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractDesiresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractDesires.
     * @param {ContractDesiresDeleteArgs} args - Arguments to delete one ContractDesires.
     * @example
     * // Delete one ContractDesires
     * const ContractDesires = await prisma.contractDesires.delete({
     *   where: {
     *     // ... filter to delete one ContractDesires
     *   }
     * })
     * 
     */
    delete<T extends ContractDesiresDeleteArgs>(args: SelectSubset<T, ContractDesiresDeleteArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractDesires.
     * @param {ContractDesiresUpdateArgs} args - Arguments to update one ContractDesires.
     * @example
     * // Update one ContractDesires
     * const contractDesires = await prisma.contractDesires.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractDesiresUpdateArgs>(args: SelectSubset<T, ContractDesiresUpdateArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractDesires.
     * @param {ContractDesiresDeleteManyArgs} args - Arguments to filter ContractDesires to delete.
     * @example
     * // Delete a few ContractDesires
     * const { count } = await prisma.contractDesires.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDesiresDeleteManyArgs>(args?: SelectSubset<T, ContractDesiresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractDesires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractDesires
     * const contractDesires = await prisma.contractDesires.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractDesiresUpdateManyArgs>(args: SelectSubset<T, ContractDesiresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractDesires and returns the data updated in the database.
     * @param {ContractDesiresUpdateManyAndReturnArgs} args - Arguments to update many ContractDesires.
     * @example
     * // Update many ContractDesires
     * const contractDesires = await prisma.contractDesires.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractDesires and only return the `id`
     * const contractDesiresWithIdOnly = await prisma.contractDesires.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractDesiresUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractDesiresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractDesires.
     * @param {ContractDesiresUpsertArgs} args - Arguments to update or create a ContractDesires.
     * @example
     * // Update or create a ContractDesires
     * const contractDesires = await prisma.contractDesires.upsert({
     *   create: {
     *     // ... data to create a ContractDesires
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractDesires we want to update
     *   }
     * })
     */
    upsert<T extends ContractDesiresUpsertArgs>(args: SelectSubset<T, ContractDesiresUpsertArgs<ExtArgs>>): Prisma__ContractDesiresClient<$Result.GetResult<Prisma.$ContractDesiresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractDesires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresCountArgs} args - Arguments to filter ContractDesires to count.
     * @example
     * // Count the number of ContractDesires
     * const count = await prisma.contractDesires.count({
     *   where: {
     *     // ... the filter for the ContractDesires we want to count
     *   }
     * })
    **/
    count<T extends ContractDesiresCountArgs>(
      args?: Subset<T, ContractDesiresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractDesiresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractDesires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractDesiresAggregateArgs>(args: Subset<T, ContractDesiresAggregateArgs>): Prisma.PrismaPromise<GetContractDesiresAggregateType<T>>

    /**
     * Group by ContractDesires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDesiresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractDesiresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractDesiresGroupByArgs['orderBy'] }
        : { orderBy?: ContractDesiresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractDesiresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractDesiresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractDesires model
   */
  readonly fields: ContractDesiresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractDesires.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractDesiresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends ContractDesires$playerArgs<ExtArgs> = {}>(args?: Subset<T, ContractDesires$playerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractDesires model
   */
  interface ContractDesiresFieldRefs {
    readonly id: FieldRef<"ContractDesires", 'String'>
    readonly years: FieldRef<"ContractDesires", 'Int'>
    readonly averageSalary: FieldRef<"ContractDesires", 'Int'>
    readonly totalGuaranteed: FieldRef<"ContractDesires", 'Int'>
    readonly bonuses: FieldRef<"ContractDesires", 'Json'>
    readonly tradeClause: FieldRef<"ContractDesires", 'Boolean'>
    readonly injuryGuarantee: FieldRef<"ContractDesires", 'Boolean'>
    readonly rosterBonus: FieldRef<"ContractDesires", 'Json'>
    readonly workoutBonus: FieldRef<"ContractDesires", 'Json'>
    readonly incentives: FieldRef<"ContractDesires", 'Json'>
    readonly optOutYears: FieldRef<"ContractDesires", 'Int[]'>
    readonly isPlayerOptOut: FieldRef<"ContractDesires", 'Boolean'>
    readonly isTeamOptOut: FieldRef<"ContractDesires", 'Boolean'>
    readonly playerId: FieldRef<"ContractDesires", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContractDesires findUnique
   */
  export type ContractDesiresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * Filter, which ContractDesires to fetch.
     */
    where: ContractDesiresWhereUniqueInput
  }

  /**
   * ContractDesires findUniqueOrThrow
   */
  export type ContractDesiresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * Filter, which ContractDesires to fetch.
     */
    where: ContractDesiresWhereUniqueInput
  }

  /**
   * ContractDesires findFirst
   */
  export type ContractDesiresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * Filter, which ContractDesires to fetch.
     */
    where?: ContractDesiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDesires to fetch.
     */
    orderBy?: ContractDesiresOrderByWithRelationInput | ContractDesiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractDesires.
     */
    cursor?: ContractDesiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDesires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDesires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractDesires.
     */
    distinct?: ContractDesiresScalarFieldEnum | ContractDesiresScalarFieldEnum[]
  }

  /**
   * ContractDesires findFirstOrThrow
   */
  export type ContractDesiresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * Filter, which ContractDesires to fetch.
     */
    where?: ContractDesiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDesires to fetch.
     */
    orderBy?: ContractDesiresOrderByWithRelationInput | ContractDesiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractDesires.
     */
    cursor?: ContractDesiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDesires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDesires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractDesires.
     */
    distinct?: ContractDesiresScalarFieldEnum | ContractDesiresScalarFieldEnum[]
  }

  /**
   * ContractDesires findMany
   */
  export type ContractDesiresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * Filter, which ContractDesires to fetch.
     */
    where?: ContractDesiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDesires to fetch.
     */
    orderBy?: ContractDesiresOrderByWithRelationInput | ContractDesiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractDesires.
     */
    cursor?: ContractDesiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDesires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDesires.
     */
    skip?: number
    distinct?: ContractDesiresScalarFieldEnum | ContractDesiresScalarFieldEnum[]
  }

  /**
   * ContractDesires create
   */
  export type ContractDesiresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractDesires.
     */
    data?: XOR<ContractDesiresCreateInput, ContractDesiresUncheckedCreateInput>
  }

  /**
   * ContractDesires createMany
   */
  export type ContractDesiresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractDesires.
     */
    data: ContractDesiresCreateManyInput | ContractDesiresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractDesires createManyAndReturn
   */
  export type ContractDesiresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * The data used to create many ContractDesires.
     */
    data: ContractDesiresCreateManyInput | ContractDesiresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractDesires update
   */
  export type ContractDesiresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractDesires.
     */
    data: XOR<ContractDesiresUpdateInput, ContractDesiresUncheckedUpdateInput>
    /**
     * Choose, which ContractDesires to update.
     */
    where: ContractDesiresWhereUniqueInput
  }

  /**
   * ContractDesires updateMany
   */
  export type ContractDesiresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractDesires.
     */
    data: XOR<ContractDesiresUpdateManyMutationInput, ContractDesiresUncheckedUpdateManyInput>
    /**
     * Filter which ContractDesires to update
     */
    where?: ContractDesiresWhereInput
    /**
     * Limit how many ContractDesires to update.
     */
    limit?: number
  }

  /**
   * ContractDesires updateManyAndReturn
   */
  export type ContractDesiresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * The data used to update ContractDesires.
     */
    data: XOR<ContractDesiresUpdateManyMutationInput, ContractDesiresUncheckedUpdateManyInput>
    /**
     * Filter which ContractDesires to update
     */
    where?: ContractDesiresWhereInput
    /**
     * Limit how many ContractDesires to update.
     */
    limit?: number
  }

  /**
   * ContractDesires upsert
   */
  export type ContractDesiresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractDesires to update in case it exists.
     */
    where: ContractDesiresWhereUniqueInput
    /**
     * In case the ContractDesires found by the `where` argument doesn't exist, create a new ContractDesires with this data.
     */
    create: XOR<ContractDesiresCreateInput, ContractDesiresUncheckedCreateInput>
    /**
     * In case the ContractDesires was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractDesiresUpdateInput, ContractDesiresUncheckedUpdateInput>
  }

  /**
   * ContractDesires delete
   */
  export type ContractDesiresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
    /**
     * Filter which ContractDesires to delete.
     */
    where: ContractDesiresWhereUniqueInput
  }

  /**
   * ContractDesires deleteMany
   */
  export type ContractDesiresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractDesires to delete
     */
    where?: ContractDesiresWhereInput
    /**
     * Limit how many ContractDesires to delete.
     */
    limit?: number
  }

  /**
   * ContractDesires.player
   */
  export type ContractDesires$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * ContractDesires without action
   */
  export type ContractDesiresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDesires
     */
    select?: ContractDesiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractDesires
     */
    omit?: ContractDesiresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDesiresInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    age: 'age',
    college: 'college',
    heightInInches: 'heightInInches',
    weightInPounds: 'weightInPounds',
    teamId: 'teamId',
    practiceSquadTeamId: 'practiceSquadTeamId',
    injuredReserveTeamId: 'injuredReserveTeamId',
    suspendedListTeamId: 'suspendedListTeamId',
    currentContractId: 'currentContractId',
    agentId: 'agentId',
    ratingsId: 'ratingsId',
    statsId: 'statsId',
    position: 'position',
    expectedRole: 'expectedRole',
    actualRole: 'actualRole',
    recordsHeld: 'recordsHeld',
    currentInjury: 'currentInjury',
    injuryHistory: 'injuryHistory',
    personalityTraits: 'personalityTraits',
    offFieldConcerns: 'offFieldConcerns',
    pastEvents: 'pastEvents',
    isStarter: 'isStarter',
    isCaptain: 'isCaptain',
    isFreeAgent: 'isFreeAgent',
    isRetired: 'isRetired',
    isSuspended: 'isSuspended',
    isPracticeSquad: 'isPracticeSquad',
    isTradeBlock: 'isTradeBlock',
    offense: 'offense',
    defense: 'defense',
    specialTeams: 'specialTeams',
    draftYear: 'draftYear',
    draftRound: 'draftRound',
    isRecordHolder: 'isRecordHolder',
    contractDesiresId: 'contractDesiresId',
    contractNegotiationStatus: 'contractNegotiationStatus',
    lastContractUpdate: 'lastContractUpdate',
    performanceRating: 'performanceRating',
    impactRating: 'impactRating',
    potential: 'potential',
    experience: 'experience',
    isInjured: 'isInjured',
    injuryProneness: 'injuryProneness',
    expectedReturnFromInjury: 'expectedReturnFromInjury',
    morale: 'morale',
    leadership: 'leadership',
    adaptability: 'adaptability',
    workEthic: 'workEthic',
    consistency: 'consistency',
    clutchFactor: 'clutchFactor',
    footballIQ: 'footballIQ',
    popularity: 'popularity',
    trainingFocus: 'trainingFocus',
    trainingProgress: 'trainingProgress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nickname: 'nickname',
    location: 'location',
    abbreviation: 'abbreviation',
    logoUrl: 'logoUrl',
    division: 'division',
    conference: 'conference',
    overallRating: 'overallRating',
    offensiveScheme: 'offensiveScheme',
    defensiveScheme: 'defensiveScheme',
    teamNeeds: 'teamNeeds',
    wins: 'wins',
    losses: 'losses',
    ties: 'ties',
    currentStreak: 'currentStreak',
    longestWinningStreak: 'longestWinningStreak',
    playoffAppearances: 'playoffAppearances',
    superBowlAppearances: 'superBowlAppearances',
    championships: 'championships',
    capSpace: 'capSpace',
    capLimit: 'capLimit',
    totalPayroll: 'totalPayroll',
    financialHealth: 'financialHealth',
    yearFounded: 'yearFounded',
    allTimeWins: 'allTimeWins',
    allTimeLosses: 'allTimeLosses',
    allTimeTies: 'allTimeTies',
    retiredNumbers: 'retiredNumbers',
    fanBaseSize: 'fanBaseSize',
    prestige: 'prestige',
    rivalTeams: 'rivalTeams'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const PlayerContractScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    teamId: 'teamId',
    signedDate: 'signedDate',
    startSeason: 'startSeason',
    endSeason: 'endSeason',
    totalValue: 'totalValue',
    averagePerYear: 'averagePerYear',
    totalGuaranteed: 'totalGuaranteed',
    isRookieContract: 'isRookieContract',
    isFranchiseTag: 'isFranchiseTag',
    isExtension: 'isExtension',
    isPlayerOptOut: 'isPlayerOptOut',
    isTeamOptOut: 'isTeamOptOut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerContractScalarFieldEnum = (typeof PlayerContractScalarFieldEnum)[keyof typeof PlayerContractScalarFieldEnum]


  export const ContractBonusScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    year: 'year',
    signingBonus: 'signingBonus',
    rosterBonus: 'rosterBonus',
    workoutBonus: 'workoutBonus',
    incentiveBonus: 'incentiveBonus'
  };

  export type ContractBonusScalarFieldEnum = (typeof ContractBonusScalarFieldEnum)[keyof typeof ContractBonusScalarFieldEnum]


  export const SalaryByYearScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    year: 'year',
    amount: 'amount'
  };

  export type SalaryByYearScalarFieldEnum = (typeof SalaryByYearScalarFieldEnum)[keyof typeof SalaryByYearScalarFieldEnum]


  export const CapHitByYearScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    year: 'year',
    amount: 'amount'
  };

  export type CapHitByYearScalarFieldEnum = (typeof CapHitByYearScalarFieldEnum)[keyof typeof CapHitByYearScalarFieldEnum]


  export const DeadCapByYearScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    year: 'year',
    amount: 'amount'
  };

  export type DeadCapByYearScalarFieldEnum = (typeof DeadCapByYearScalarFieldEnum)[keyof typeof DeadCapByYearScalarFieldEnum]


  export const OptOutYearScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    year: 'year'
  };

  export type OptOutYearScalarFieldEnum = (typeof OptOutYearScalarFieldEnum)[keyof typeof OptOutYearScalarFieldEnum]


  export const RestructureEventScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    year: 'year',
    date: 'date',
    amountConvertedToBonus: 'amountConvertedToBonus',
    newCapHit: 'newCapHit',
    newDeadCap: 'newDeadCap'
  };

  export type RestructureEventScalarFieldEnum = (typeof RestructureEventScalarFieldEnum)[keyof typeof RestructureEventScalarFieldEnum]


  export const ContractClauseScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    noTradeClause: 'noTradeClause',
    injuryGuarantee: 'injuryGuarantee',
    restructureEligible: 'restructureEligible',
    earlyTerminationPenalty: 'earlyTerminationPenalty',
    performanceBonusId: 'performanceBonusId',
    rosterBonusId: 'rosterBonusId',
    workoutBonusId: 'workoutBonusId',
    optionBonusId: 'optionBonusId'
  };

  export type ContractClauseScalarFieldEnum = (typeof ContractClauseScalarFieldEnum)[keyof typeof ContractClauseScalarFieldEnum]


  export const PerformanceBonusScalarFieldEnum: {
    id: 'id',
    clauseId: 'clauseId',
    proBowl: 'proBowl',
    allPro: 'allPro',
    mvp: 'mvp',
    superBowlMVP: 'superBowlMVP',
    playoffAppearance: 'playoffAppearance'
  };

  export type PerformanceBonusScalarFieldEnum = (typeof PerformanceBonusScalarFieldEnum)[keyof typeof PerformanceBonusScalarFieldEnum]


  export const StatMilestoneScalarFieldEnum: {
    id: 'id',
    performanceId: 'performanceId',
    yards: 'yards',
    touchdowns: 'touchdowns',
    sacks: 'sacks',
    interceptions: 'interceptions'
  };

  export type StatMilestoneScalarFieldEnum = (typeof StatMilestoneScalarFieldEnum)[keyof typeof StatMilestoneScalarFieldEnum]


  export const RosterBonusScalarFieldEnum: {
    id: 'id',
    clauseId: 'clauseId',
    amount: 'amount',
    perGame: 'perGame'
  };

  export type RosterBonusScalarFieldEnum = (typeof RosterBonusScalarFieldEnum)[keyof typeof RosterBonusScalarFieldEnum]


  export const WorkoutBonusScalarFieldEnum: {
    id: 'id',
    clauseId: 'clauseId',
    amount: 'amount',
    minWorkouts: 'minWorkouts'
  };

  export type WorkoutBonusScalarFieldEnum = (typeof WorkoutBonusScalarFieldEnum)[keyof typeof WorkoutBonusScalarFieldEnum]


  export const OptionBonusScalarFieldEnum: {
    id: 'id',
    clauseId: 'clauseId',
    year: 'year',
    amount: 'amount',
    type: 'type'
  };

  export type OptionBonusScalarFieldEnum = (typeof OptionBonusScalarFieldEnum)[keyof typeof OptionBonusScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    agencyName: 'agencyName',
    reputation: 'reputation',
    yearsOfExperience: 'yearsOfExperience'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    speed: 'speed',
    acceleration: 'acceleration',
    agility: 'agility',
    changeOfDirection: 'changeOfDirection',
    strength: 'strength',
    impactPower: 'impactPower',
    verticalJump: 'verticalJump',
    stamina: 'stamina',
    toughness: 'toughness',
    awareness: 'awareness',
    discipline: 'discipline',
    injuryRecovery: 'injuryRecovery',
    throwPower: 'throwPower',
    throwAccuracyShort: 'throwAccuracyShort',
    throwAccuracyMedium: 'throwAccuracyMedium',
    throwAccuracyDeep: 'throwAccuracyDeep',
    throwOnRun: 'throwOnRun',
    playAction: 'playAction',
    pocketPresence: 'pocketPresence',
    releaseTime: 'releaseTime',
    decisionMaking: 'decisionMaking',
    scrambling: 'scrambling',
    breakSack: 'breakSack',
    fieldVision: 'fieldVision',
    ballSecurity: 'ballSecurity',
    ballCarrierVision: 'ballCarrierVision',
    breakTackle: 'breakTackle',
    topBallCarrierSpeed: 'topBallCarrierSpeed',
    trucking: 'trucking',
    elusiveness: 'elusiveness',
    stiffArm: 'stiffArm',
    spinMove: 'spinMove',
    jukeMove: 'jukeMove',
    shortYardage: 'shortYardage',
    goalLine: 'goalLine',
    openFieldRunning: 'openFieldRunning',
    catching: 'catching',
    catchInTraffic: 'catchInTraffic',
    spectacularCatch: 'spectacularCatch',
    contestedCatches: 'contestedCatches',
    yardsAfterCatch: 'yardsAfterCatch',
    jumpBallTiming: 'jumpBallTiming',
    routeRunning: 'routeRunning',
    shortRoute: 'shortRoute',
    mediumRoute: 'mediumRoute',
    deepRoute: 'deepRoute',
    separation: 'separation',
    release: 'release',
    runBlocking: 'runBlocking',
    passBlocking: 'passBlocking',
    pullBlocking: 'pullBlocking',
    scrambleBlocking: 'scrambleBlocking',
    playActionBlocking: 'playActionBlocking',
    screenBlocking: 'screenBlocking',
    leadBlocking: 'leadBlocking',
    tackling: 'tackling',
    blockShedding: 'blockShedding',
    blitzing: 'blitzing',
    playRecognition: 'playRecognition',
    openFieldTackling: 'openFieldTackling',
    coverageAgainstTEsRBs: 'coverageAgainstTEsRBs',
    coverageAgainstSlot: 'coverageAgainstSlot',
    deepCoverage: 'deepCoverage',
    runDefense: 'runDefense',
    passRush: 'passRush',
    finessePassRush: 'finessePassRush',
    powerPassRush: 'powerPassRush',
    runStopping: 'runStopping',
    penetration: 'penetration',
    edgeSetting: 'edgeSetting',
    disengagement: 'disengagement',
    offensiveLineRecognition: 'offensiveLineRecognition',
    hitPower: 'hitPower',
    pressCoverage: 'pressCoverage',
    offBallCoverage: 'offBallCoverage',
    manCoverage: 'manCoverage',
    zoneCoverage: 'zoneCoverage',
    ballHawking: 'ballHawking',
    interceptions: 'interceptions',
    passDeflection: 'passDeflection',
    kickPower: 'kickPower',
    kickAccuracy: 'kickAccuracy',
    puntPower: 'puntPower',
    puntAccuracy: 'puntAccuracy',
    onsideKickAbility: 'onsideKickAbility',
    kickReturnVision: 'kickReturnVision',
    puntReturnVision: 'puntReturnVision'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const StatScalarFieldEnum: {
    id: 'id',
    season: 'season',
    playerId: 'playerId',
    gamesPlayed: 'gamesPlayed',
    gamesStarted: 'gamesStarted',
    snaps: 'snaps',
    rushingAttempts: 'rushingAttempts',
    rushingYards: 'rushingYards',
    yardsPerCarry: 'yardsPerCarry',
    yardsAfterContact: 'yardsAfterContact',
    yardsPerGame: 'yardsPerGame',
    rushingLong: 'rushingLong',
    rushingTouchdowns: 'rushingTouchdowns',
    fumblesLost: 'fumblesLost',
    receptions: 'receptions',
    receivingYards: 'receivingYards',
    yardsPerReception: 'yardsPerReception',
    yardsAfterCatch: 'yardsAfterCatch',
    yardsPerTarget: 'yardsPerTarget',
    airYards: 'airYards',
    receivingLong: 'receivingLong',
    targets: 'targets',
    receivingTouchdowns: 'receivingTouchdowns',
    drops: 'drops',
    passingAttempts: 'passingAttempts',
    passingCompletions: 'passingCompletions',
    passingYards: 'passingYards',
    yardsPerPass: 'yardsPerPass',
    yardsPerCompletion: 'yardsPerCompletion',
    completionPercentage: 'completionPercentage',
    passingTouchdowns: 'passingTouchdowns',
    interceptions: 'interceptions',
    sacksTaken: 'sacksTaken',
    passerRating: 'passerRating',
    pancakes: 'pancakes',
    sacksAllowed: 'sacksAllowed',
    hurriesAllowed: 'hurriesAllowed',
    tackles: 'tackles',
    tacklesForLoss: 'tacklesForLoss',
    sacks: 'sacks',
    interceptionsMade: 'interceptionsMade',
    forcedFumbles: 'forcedFumbles',
    fumbleRecoveries: 'fumbleRecoveries',
    passesDefended: 'passesDefended',
    defensiveTouchdowns: 'defensiveTouchdowns',
    fieldGoalsMade: 'fieldGoalsMade',
    fieldGoalsAttempted: 'fieldGoalsAttempted',
    extraPointsMade: 'extraPointsMade',
    extraPointsAttempted: 'extraPointsAttempted',
    punts: 'punts',
    puntYards: 'puntYards',
    kickReturns: 'kickReturns',
    kickReturnYards: 'kickReturnYards',
    puntReturns: 'puntReturns',
    puntReturnYards: 'puntReturnYards',
    specialTeamsTouchdowns: 'specialTeamsTouchdowns',
    penaltiesCommitted: 'penaltiesCommitted',
    penaltyYards: 'penaltyYards'
  };

  export type StatScalarFieldEnum = (typeof StatScalarFieldEnum)[keyof typeof StatScalarFieldEnum]


  export const ContractDesiresScalarFieldEnum: {
    id: 'id',
    years: 'years',
    averageSalary: 'averageSalary',
    totalGuaranteed: 'totalGuaranteed',
    bonuses: 'bonuses',
    tradeClause: 'tradeClause',
    injuryGuarantee: 'injuryGuarantee',
    rosterBonus: 'rosterBonus',
    workoutBonus: 'workoutBonus',
    incentives: 'incentives',
    optOutYears: 'optOutYears',
    isPlayerOptOut: 'isPlayerOptOut',
    isTeamOptOut: 'isTeamOptOut',
    playerId: 'playerId'
  };

  export type ContractDesiresScalarFieldEnum = (typeof ContractDesiresScalarFieldEnum)[keyof typeof ContractDesiresScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PlayerPositionEnum'
   */
  export type EnumPlayerPositionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerPositionEnum'>
    


  /**
   * Reference to a field of type 'PlayerPositionEnum[]'
   */
  export type ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerPositionEnum[]'>
    


  /**
   * Reference to a field of type 'PlayerRoleEnum'
   */
  export type EnumPlayerRoleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerRoleEnum'>
    


  /**
   * Reference to a field of type 'PlayerRoleEnum[]'
   */
  export type ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerRoleEnum[]'>
    


  /**
   * Reference to a field of type 'FootballRecordEnum[]'
   */
  export type ListEnumFootballRecordEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FootballRecordEnum[]'>
    


  /**
   * Reference to a field of type 'FootballRecordEnum'
   */
  export type EnumFootballRecordEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FootballRecordEnum'>
    


  /**
   * Reference to a field of type 'InjuryTypeEnum'
   */
  export type EnumInjuryTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryTypeEnum'>
    


  /**
   * Reference to a field of type 'InjuryTypeEnum[]'
   */
  export type ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryTypeEnum[]'>
    


  /**
   * Reference to a field of type 'PlayerPersonalityTraitEnum[]'
   */
  export type ListEnumPlayerPersonalityTraitEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerPersonalityTraitEnum[]'>
    


  /**
   * Reference to a field of type 'PlayerPersonalityTraitEnum'
   */
  export type EnumPlayerPersonalityTraitEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerPersonalityTraitEnum'>
    


  /**
   * Reference to a field of type 'OffFieldConcernTypeEnum[]'
   */
  export type ListEnumOffFieldConcernTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OffFieldConcernTypeEnum[]'>
    


  /**
   * Reference to a field of type 'OffFieldConcernTypeEnum'
   */
  export type EnumOffFieldConcernTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OffFieldConcernTypeEnum'>
    


  /**
   * Reference to a field of type 'PlayerEventEnum[]'
   */
  export type ListEnumPlayerEventEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerEventEnum[]'>
    


  /**
   * Reference to a field of type 'PlayerEventEnum'
   */
  export type EnumPlayerEventEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerEventEnum'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ContractNegotiationStatusEnum'
   */
  export type EnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractNegotiationStatusEnum'>
    


  /**
   * Reference to a field of type 'ContractNegotiationStatusEnum[]'
   */
  export type ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractNegotiationStatusEnum[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DivisionEnum'
   */
  export type EnumDivisionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DivisionEnum'>
    


  /**
   * Reference to a field of type 'DivisionEnum[]'
   */
  export type ListEnumDivisionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DivisionEnum[]'>
    


  /**
   * Reference to a field of type 'ConferenceEnum'
   */
  export type EnumConferenceEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConferenceEnum'>
    


  /**
   * Reference to a field of type 'ConferenceEnum[]'
   */
  export type ListEnumConferenceEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConferenceEnum[]'>
    


  /**
   * Reference to a field of type 'OffensiveSchemeEnum'
   */
  export type EnumOffensiveSchemeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OffensiveSchemeEnum'>
    


  /**
   * Reference to a field of type 'OffensiveSchemeEnum[]'
   */
  export type ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OffensiveSchemeEnum[]'>
    


  /**
   * Reference to a field of type 'DefensiveSchemeEnum'
   */
  export type EnumDefensiveSchemeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefensiveSchemeEnum'>
    


  /**
   * Reference to a field of type 'DefensiveSchemeEnum[]'
   */
  export type ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefensiveSchemeEnum[]'>
    


  /**
   * Reference to a field of type 'FinancialHealthEnum'
   */
  export type EnumFinancialHealthEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialHealthEnum'>
    


  /**
   * Reference to a field of type 'FinancialHealthEnum[]'
   */
  export type ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialHealthEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'OptionType'
   */
  export type EnumOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionType'>
    


  /**
   * Reference to a field of type 'OptionType[]'
   */
  export type ListEnumOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    age?: IntFilter<"Player"> | number
    college?: StringFilter<"Player"> | string
    heightInInches?: IntFilter<"Player"> | number
    weightInPounds?: IntFilter<"Player"> | number
    teamId?: StringNullableFilter<"Player"> | string | null
    practiceSquadTeamId?: StringNullableFilter<"Player"> | string | null
    injuredReserveTeamId?: StringNullableFilter<"Player"> | string | null
    suspendedListTeamId?: StringNullableFilter<"Player"> | string | null
    currentContractId?: StringNullableFilter<"Player"> | string | null
    agentId?: StringNullableFilter<"Player"> | string | null
    ratingsId?: StringNullableFilter<"Player"> | string | null
    statsId?: StringNullableFilter<"Player"> | string | null
    position?: EnumPlayerPositionEnumNullableFilter<"Player"> | $Enums.PlayerPositionEnum | null
    expectedRole?: EnumPlayerRoleEnumNullableFilter<"Player"> | $Enums.PlayerRoleEnum | null
    actualRole?: EnumPlayerRoleEnumNullableFilter<"Player"> | $Enums.PlayerRoleEnum | null
    recordsHeld?: EnumFootballRecordEnumNullableListFilter<"Player">
    currentInjury?: EnumInjuryTypeEnumNullableFilter<"Player"> | $Enums.InjuryTypeEnum | null
    injuryHistory?: EnumInjuryTypeEnumNullableListFilter<"Player">
    personalityTraits?: EnumPlayerPersonalityTraitEnumNullableListFilter<"Player">
    offFieldConcerns?: EnumOffFieldConcernTypeEnumNullableListFilter<"Player">
    pastEvents?: EnumPlayerEventEnumNullableListFilter<"Player">
    isStarter?: BoolFilter<"Player"> | boolean
    isCaptain?: BoolFilter<"Player"> | boolean
    isFreeAgent?: BoolFilter<"Player"> | boolean
    isRetired?: BoolFilter<"Player"> | boolean
    isSuspended?: BoolFilter<"Player"> | boolean
    isPracticeSquad?: BoolFilter<"Player"> | boolean
    isTradeBlock?: BoolFilter<"Player"> | boolean
    offense?: BoolFilter<"Player"> | boolean
    defense?: BoolFilter<"Player"> | boolean
    specialTeams?: BoolFilter<"Player"> | boolean
    draftYear?: IntNullableFilter<"Player"> | number | null
    draftRound?: IntNullableFilter<"Player"> | number | null
    isRecordHolder?: BoolFilter<"Player"> | boolean
    contractDesiresId?: StringNullableFilter<"Player"> | string | null
    contractNegotiationStatus?: EnumContractNegotiationStatusEnumNullableFilter<"Player"> | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: DateTimeNullableFilter<"Player"> | Date | string | null
    performanceRating?: IntNullableFilter<"Player"> | number | null
    impactRating?: IntNullableFilter<"Player"> | number | null
    potential?: IntNullableFilter<"Player"> | number | null
    experience?: IntNullableFilter<"Player"> | number | null
    isInjured?: BoolFilter<"Player"> | boolean
    injuryProneness?: BoolFilter<"Player"> | boolean
    expectedReturnFromInjury?: DateTimeNullableFilter<"Player"> | Date | string | null
    morale?: IntNullableFilter<"Player"> | number | null
    leadership?: IntNullableFilter<"Player"> | number | null
    adaptability?: IntNullableFilter<"Player"> | number | null
    workEthic?: IntNullableFilter<"Player"> | number | null
    consistency?: IntNullableFilter<"Player"> | number | null
    clutchFactor?: IntNullableFilter<"Player"> | number | null
    footballIQ?: IntNullableFilter<"Player"> | number | null
    popularity?: IntNullableFilter<"Player"> | number | null
    trainingFocus?: StringNullableFilter<"Player"> | string | null
    trainingProgress?: IntNullableFilter<"Player"> | number | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    practiceSquadTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    injuredReserveTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    suspendedListTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    currentContract?: XOR<PlayerContractNullableScalarRelationFilter, PlayerContractWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    ratings?: XOR<RatingNullableScalarRelationFilter, RatingWhereInput> | null
    stats?: XOR<StatNullableScalarRelationFilter, StatWhereInput> | null
    contractDesires?: XOR<ContractDesiresNullableScalarRelationFilter, ContractDesiresWhereInput> | null
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    college?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    teamId?: SortOrderInput | SortOrder
    practiceSquadTeamId?: SortOrderInput | SortOrder
    injuredReserveTeamId?: SortOrderInput | SortOrder
    suspendedListTeamId?: SortOrderInput | SortOrder
    currentContractId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    ratingsId?: SortOrderInput | SortOrder
    statsId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    expectedRole?: SortOrderInput | SortOrder
    actualRole?: SortOrderInput | SortOrder
    recordsHeld?: SortOrder
    currentInjury?: SortOrderInput | SortOrder
    injuryHistory?: SortOrder
    personalityTraits?: SortOrder
    offFieldConcerns?: SortOrder
    pastEvents?: SortOrder
    isStarter?: SortOrder
    isCaptain?: SortOrder
    isFreeAgent?: SortOrder
    isRetired?: SortOrder
    isSuspended?: SortOrder
    isPracticeSquad?: SortOrder
    isTradeBlock?: SortOrder
    offense?: SortOrder
    defense?: SortOrder
    specialTeams?: SortOrder
    draftYear?: SortOrderInput | SortOrder
    draftRound?: SortOrderInput | SortOrder
    isRecordHolder?: SortOrder
    contractDesiresId?: SortOrderInput | SortOrder
    contractNegotiationStatus?: SortOrderInput | SortOrder
    lastContractUpdate?: SortOrderInput | SortOrder
    performanceRating?: SortOrderInput | SortOrder
    impactRating?: SortOrderInput | SortOrder
    potential?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    isInjured?: SortOrder
    injuryProneness?: SortOrder
    expectedReturnFromInjury?: SortOrderInput | SortOrder
    morale?: SortOrderInput | SortOrder
    leadership?: SortOrderInput | SortOrder
    adaptability?: SortOrderInput | SortOrder
    workEthic?: SortOrderInput | SortOrder
    consistency?: SortOrderInput | SortOrder
    clutchFactor?: SortOrderInput | SortOrder
    footballIQ?: SortOrderInput | SortOrder
    popularity?: SortOrderInput | SortOrder
    trainingFocus?: SortOrderInput | SortOrder
    trainingProgress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    practiceSquadTeam?: TeamOrderByWithRelationInput
    injuredReserveTeam?: TeamOrderByWithRelationInput
    suspendedListTeam?: TeamOrderByWithRelationInput
    currentContract?: PlayerContractOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    ratings?: RatingOrderByWithRelationInput
    stats?: StatOrderByWithRelationInput
    contractDesires?: ContractDesiresOrderByWithRelationInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    currentContractId?: string
    ratingsId?: string
    statsId?: string
    contractDesiresId?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    age?: IntFilter<"Player"> | number
    college?: StringFilter<"Player"> | string
    heightInInches?: IntFilter<"Player"> | number
    weightInPounds?: IntFilter<"Player"> | number
    teamId?: StringNullableFilter<"Player"> | string | null
    practiceSquadTeamId?: StringNullableFilter<"Player"> | string | null
    injuredReserveTeamId?: StringNullableFilter<"Player"> | string | null
    suspendedListTeamId?: StringNullableFilter<"Player"> | string | null
    agentId?: StringNullableFilter<"Player"> | string | null
    position?: EnumPlayerPositionEnumNullableFilter<"Player"> | $Enums.PlayerPositionEnum | null
    expectedRole?: EnumPlayerRoleEnumNullableFilter<"Player"> | $Enums.PlayerRoleEnum | null
    actualRole?: EnumPlayerRoleEnumNullableFilter<"Player"> | $Enums.PlayerRoleEnum | null
    recordsHeld?: EnumFootballRecordEnumNullableListFilter<"Player">
    currentInjury?: EnumInjuryTypeEnumNullableFilter<"Player"> | $Enums.InjuryTypeEnum | null
    injuryHistory?: EnumInjuryTypeEnumNullableListFilter<"Player">
    personalityTraits?: EnumPlayerPersonalityTraitEnumNullableListFilter<"Player">
    offFieldConcerns?: EnumOffFieldConcernTypeEnumNullableListFilter<"Player">
    pastEvents?: EnumPlayerEventEnumNullableListFilter<"Player">
    isStarter?: BoolFilter<"Player"> | boolean
    isCaptain?: BoolFilter<"Player"> | boolean
    isFreeAgent?: BoolFilter<"Player"> | boolean
    isRetired?: BoolFilter<"Player"> | boolean
    isSuspended?: BoolFilter<"Player"> | boolean
    isPracticeSquad?: BoolFilter<"Player"> | boolean
    isTradeBlock?: BoolFilter<"Player"> | boolean
    offense?: BoolFilter<"Player"> | boolean
    defense?: BoolFilter<"Player"> | boolean
    specialTeams?: BoolFilter<"Player"> | boolean
    draftYear?: IntNullableFilter<"Player"> | number | null
    draftRound?: IntNullableFilter<"Player"> | number | null
    isRecordHolder?: BoolFilter<"Player"> | boolean
    contractNegotiationStatus?: EnumContractNegotiationStatusEnumNullableFilter<"Player"> | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: DateTimeNullableFilter<"Player"> | Date | string | null
    performanceRating?: IntNullableFilter<"Player"> | number | null
    impactRating?: IntNullableFilter<"Player"> | number | null
    potential?: IntNullableFilter<"Player"> | number | null
    experience?: IntNullableFilter<"Player"> | number | null
    isInjured?: BoolFilter<"Player"> | boolean
    injuryProneness?: BoolFilter<"Player"> | boolean
    expectedReturnFromInjury?: DateTimeNullableFilter<"Player"> | Date | string | null
    morale?: IntNullableFilter<"Player"> | number | null
    leadership?: IntNullableFilter<"Player"> | number | null
    adaptability?: IntNullableFilter<"Player"> | number | null
    workEthic?: IntNullableFilter<"Player"> | number | null
    consistency?: IntNullableFilter<"Player"> | number | null
    clutchFactor?: IntNullableFilter<"Player"> | number | null
    footballIQ?: IntNullableFilter<"Player"> | number | null
    popularity?: IntNullableFilter<"Player"> | number | null
    trainingFocus?: StringNullableFilter<"Player"> | string | null
    trainingProgress?: IntNullableFilter<"Player"> | number | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    practiceSquadTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    injuredReserveTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    suspendedListTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    currentContract?: XOR<PlayerContractNullableScalarRelationFilter, PlayerContractWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    ratings?: XOR<RatingNullableScalarRelationFilter, RatingWhereInput> | null
    stats?: XOR<StatNullableScalarRelationFilter, StatWhereInput> | null
    contractDesires?: XOR<ContractDesiresNullableScalarRelationFilter, ContractDesiresWhereInput> | null
  }, "id" | "currentContractId" | "ratingsId" | "statsId" | "contractDesiresId">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    college?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    teamId?: SortOrderInput | SortOrder
    practiceSquadTeamId?: SortOrderInput | SortOrder
    injuredReserveTeamId?: SortOrderInput | SortOrder
    suspendedListTeamId?: SortOrderInput | SortOrder
    currentContractId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    ratingsId?: SortOrderInput | SortOrder
    statsId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    expectedRole?: SortOrderInput | SortOrder
    actualRole?: SortOrderInput | SortOrder
    recordsHeld?: SortOrder
    currentInjury?: SortOrderInput | SortOrder
    injuryHistory?: SortOrder
    personalityTraits?: SortOrder
    offFieldConcerns?: SortOrder
    pastEvents?: SortOrder
    isStarter?: SortOrder
    isCaptain?: SortOrder
    isFreeAgent?: SortOrder
    isRetired?: SortOrder
    isSuspended?: SortOrder
    isPracticeSquad?: SortOrder
    isTradeBlock?: SortOrder
    offense?: SortOrder
    defense?: SortOrder
    specialTeams?: SortOrder
    draftYear?: SortOrderInput | SortOrder
    draftRound?: SortOrderInput | SortOrder
    isRecordHolder?: SortOrder
    contractDesiresId?: SortOrderInput | SortOrder
    contractNegotiationStatus?: SortOrderInput | SortOrder
    lastContractUpdate?: SortOrderInput | SortOrder
    performanceRating?: SortOrderInput | SortOrder
    impactRating?: SortOrderInput | SortOrder
    potential?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    isInjured?: SortOrder
    injuryProneness?: SortOrder
    expectedReturnFromInjury?: SortOrderInput | SortOrder
    morale?: SortOrderInput | SortOrder
    leadership?: SortOrderInput | SortOrder
    adaptability?: SortOrderInput | SortOrder
    workEthic?: SortOrderInput | SortOrder
    consistency?: SortOrderInput | SortOrder
    clutchFactor?: SortOrderInput | SortOrder
    footballIQ?: SortOrderInput | SortOrder
    popularity?: SortOrderInput | SortOrder
    trainingFocus?: SortOrderInput | SortOrder
    trainingProgress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    firstName?: StringWithAggregatesFilter<"Player"> | string
    lastName?: StringWithAggregatesFilter<"Player"> | string
    age?: IntWithAggregatesFilter<"Player"> | number
    college?: StringWithAggregatesFilter<"Player"> | string
    heightInInches?: IntWithAggregatesFilter<"Player"> | number
    weightInPounds?: IntWithAggregatesFilter<"Player"> | number
    teamId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    practiceSquadTeamId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    injuredReserveTeamId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    suspendedListTeamId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    currentContractId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    agentId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    ratingsId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    statsId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    position?: EnumPlayerPositionEnumNullableWithAggregatesFilter<"Player"> | $Enums.PlayerPositionEnum | null
    expectedRole?: EnumPlayerRoleEnumNullableWithAggregatesFilter<"Player"> | $Enums.PlayerRoleEnum | null
    actualRole?: EnumPlayerRoleEnumNullableWithAggregatesFilter<"Player"> | $Enums.PlayerRoleEnum | null
    recordsHeld?: EnumFootballRecordEnumNullableListFilter<"Player">
    currentInjury?: EnumInjuryTypeEnumNullableWithAggregatesFilter<"Player"> | $Enums.InjuryTypeEnum | null
    injuryHistory?: EnumInjuryTypeEnumNullableListFilter<"Player">
    personalityTraits?: EnumPlayerPersonalityTraitEnumNullableListFilter<"Player">
    offFieldConcerns?: EnumOffFieldConcernTypeEnumNullableListFilter<"Player">
    pastEvents?: EnumPlayerEventEnumNullableListFilter<"Player">
    isStarter?: BoolWithAggregatesFilter<"Player"> | boolean
    isCaptain?: BoolWithAggregatesFilter<"Player"> | boolean
    isFreeAgent?: BoolWithAggregatesFilter<"Player"> | boolean
    isRetired?: BoolWithAggregatesFilter<"Player"> | boolean
    isSuspended?: BoolWithAggregatesFilter<"Player"> | boolean
    isPracticeSquad?: BoolWithAggregatesFilter<"Player"> | boolean
    isTradeBlock?: BoolWithAggregatesFilter<"Player"> | boolean
    offense?: BoolWithAggregatesFilter<"Player"> | boolean
    defense?: BoolWithAggregatesFilter<"Player"> | boolean
    specialTeams?: BoolWithAggregatesFilter<"Player"> | boolean
    draftYear?: IntNullableWithAggregatesFilter<"Player"> | number | null
    draftRound?: IntNullableWithAggregatesFilter<"Player"> | number | null
    isRecordHolder?: BoolWithAggregatesFilter<"Player"> | boolean
    contractDesiresId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    contractNegotiationStatus?: EnumContractNegotiationStatusEnumNullableWithAggregatesFilter<"Player"> | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: DateTimeNullableWithAggregatesFilter<"Player"> | Date | string | null
    performanceRating?: IntNullableWithAggregatesFilter<"Player"> | number | null
    impactRating?: IntNullableWithAggregatesFilter<"Player"> | number | null
    potential?: IntNullableWithAggregatesFilter<"Player"> | number | null
    experience?: IntNullableWithAggregatesFilter<"Player"> | number | null
    isInjured?: BoolWithAggregatesFilter<"Player"> | boolean
    injuryProneness?: BoolWithAggregatesFilter<"Player"> | boolean
    expectedReturnFromInjury?: DateTimeNullableWithAggregatesFilter<"Player"> | Date | string | null
    morale?: IntNullableWithAggregatesFilter<"Player"> | number | null
    leadership?: IntNullableWithAggregatesFilter<"Player"> | number | null
    adaptability?: IntNullableWithAggregatesFilter<"Player"> | number | null
    workEthic?: IntNullableWithAggregatesFilter<"Player"> | number | null
    consistency?: IntNullableWithAggregatesFilter<"Player"> | number | null
    clutchFactor?: IntNullableWithAggregatesFilter<"Player"> | number | null
    footballIQ?: IntNullableWithAggregatesFilter<"Player"> | number | null
    popularity?: IntNullableWithAggregatesFilter<"Player"> | number | null
    trainingFocus?: StringNullableWithAggregatesFilter<"Player"> | string | null
    trainingProgress?: IntNullableWithAggregatesFilter<"Player"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    nickname?: StringFilter<"Team"> | string
    location?: StringFilter<"Team"> | string
    abbreviation?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    division?: EnumDivisionEnumFilter<"Team"> | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFilter<"Team"> | $Enums.ConferenceEnum
    overallRating?: IntFilter<"Team"> | number
    offensiveScheme?: EnumOffensiveSchemeEnumFilter<"Team"> | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFilter<"Team"> | $Enums.DefensiveSchemeEnum
    teamNeeds?: EnumPlayerPositionEnumNullableListFilter<"Team">
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    ties?: IntFilter<"Team"> | number
    currentStreak?: IntFilter<"Team"> | number
    longestWinningStreak?: IntFilter<"Team"> | number
    playoffAppearances?: IntFilter<"Team"> | number
    superBowlAppearances?: IntFilter<"Team"> | number
    championships?: IntFilter<"Team"> | number
    capSpace?: IntFilter<"Team"> | number
    capLimit?: IntFilter<"Team"> | number
    totalPayroll?: IntFilter<"Team"> | number
    financialHealth?: EnumFinancialHealthEnumFilter<"Team"> | $Enums.FinancialHealthEnum
    yearFounded?: IntFilter<"Team"> | number
    allTimeWins?: IntFilter<"Team"> | number
    allTimeLosses?: IntFilter<"Team"> | number
    allTimeTies?: IntFilter<"Team"> | number
    retiredNumbers?: IntNullableListFilter<"Team">
    fanBaseSize?: IntFilter<"Team"> | number
    prestige?: IntFilter<"Team"> | number
    rivalTeams?: StringNullableListFilter<"Team">
    players?: PlayerListRelationFilter
    practiceSquad?: PlayerListRelationFilter
    injuredReserve?: PlayerListRelationFilter
    suspendedList?: PlayerListRelationFilter
    playerContracts?: PlayerContractListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    location?: SortOrder
    abbreviation?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    division?: SortOrder
    conference?: SortOrder
    overallRating?: SortOrder
    offensiveScheme?: SortOrder
    defensiveScheme?: SortOrder
    teamNeeds?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    financialHealth?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    retiredNumbers?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
    rivalTeams?: SortOrder
    players?: PlayerOrderByRelationAggregateInput
    practiceSquad?: PlayerOrderByRelationAggregateInput
    injuredReserve?: PlayerOrderByRelationAggregateInput
    suspendedList?: PlayerOrderByRelationAggregateInput
    playerContracts?: PlayerContractOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    nickname?: string
    location?: string
    abbreviation?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    logoUrl?: StringNullableFilter<"Team"> | string | null
    division?: EnumDivisionEnumFilter<"Team"> | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFilter<"Team"> | $Enums.ConferenceEnum
    overallRating?: IntFilter<"Team"> | number
    offensiveScheme?: EnumOffensiveSchemeEnumFilter<"Team"> | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFilter<"Team"> | $Enums.DefensiveSchemeEnum
    teamNeeds?: EnumPlayerPositionEnumNullableListFilter<"Team">
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    ties?: IntFilter<"Team"> | number
    currentStreak?: IntFilter<"Team"> | number
    longestWinningStreak?: IntFilter<"Team"> | number
    playoffAppearances?: IntFilter<"Team"> | number
    superBowlAppearances?: IntFilter<"Team"> | number
    championships?: IntFilter<"Team"> | number
    capSpace?: IntFilter<"Team"> | number
    capLimit?: IntFilter<"Team"> | number
    totalPayroll?: IntFilter<"Team"> | number
    financialHealth?: EnumFinancialHealthEnumFilter<"Team"> | $Enums.FinancialHealthEnum
    yearFounded?: IntFilter<"Team"> | number
    allTimeWins?: IntFilter<"Team"> | number
    allTimeLosses?: IntFilter<"Team"> | number
    allTimeTies?: IntFilter<"Team"> | number
    retiredNumbers?: IntNullableListFilter<"Team">
    fanBaseSize?: IntFilter<"Team"> | number
    prestige?: IntFilter<"Team"> | number
    rivalTeams?: StringNullableListFilter<"Team">
    players?: PlayerListRelationFilter
    practiceSquad?: PlayerListRelationFilter
    injuredReserve?: PlayerListRelationFilter
    suspendedList?: PlayerListRelationFilter
    playerContracts?: PlayerContractListRelationFilter
  }, "id" | "name" | "nickname" | "location" | "abbreviation">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    location?: SortOrder
    abbreviation?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    division?: SortOrder
    conference?: SortOrder
    overallRating?: SortOrder
    offensiveScheme?: SortOrder
    defensiveScheme?: SortOrder
    teamNeeds?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    financialHealth?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    retiredNumbers?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
    rivalTeams?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    nickname?: StringWithAggregatesFilter<"Team"> | string
    location?: StringWithAggregatesFilter<"Team"> | string
    abbreviation?: StringWithAggregatesFilter<"Team"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    division?: EnumDivisionEnumWithAggregatesFilter<"Team"> | $Enums.DivisionEnum
    conference?: EnumConferenceEnumWithAggregatesFilter<"Team"> | $Enums.ConferenceEnum
    overallRating?: IntWithAggregatesFilter<"Team"> | number
    offensiveScheme?: EnumOffensiveSchemeEnumWithAggregatesFilter<"Team"> | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumWithAggregatesFilter<"Team"> | $Enums.DefensiveSchemeEnum
    teamNeeds?: EnumPlayerPositionEnumNullableListFilter<"Team">
    wins?: IntWithAggregatesFilter<"Team"> | number
    losses?: IntWithAggregatesFilter<"Team"> | number
    ties?: IntWithAggregatesFilter<"Team"> | number
    currentStreak?: IntWithAggregatesFilter<"Team"> | number
    longestWinningStreak?: IntWithAggregatesFilter<"Team"> | number
    playoffAppearances?: IntWithAggregatesFilter<"Team"> | number
    superBowlAppearances?: IntWithAggregatesFilter<"Team"> | number
    championships?: IntWithAggregatesFilter<"Team"> | number
    capSpace?: IntWithAggregatesFilter<"Team"> | number
    capLimit?: IntWithAggregatesFilter<"Team"> | number
    totalPayroll?: IntWithAggregatesFilter<"Team"> | number
    financialHealth?: EnumFinancialHealthEnumWithAggregatesFilter<"Team"> | $Enums.FinancialHealthEnum
    yearFounded?: IntWithAggregatesFilter<"Team"> | number
    allTimeWins?: IntWithAggregatesFilter<"Team"> | number
    allTimeLosses?: IntWithAggregatesFilter<"Team"> | number
    allTimeTies?: IntWithAggregatesFilter<"Team"> | number
    retiredNumbers?: IntNullableListFilter<"Team">
    fanBaseSize?: IntWithAggregatesFilter<"Team"> | number
    prestige?: IntWithAggregatesFilter<"Team"> | number
    rivalTeams?: StringNullableListFilter<"Team">
  }

  export type PlayerContractWhereInput = {
    AND?: PlayerContractWhereInput | PlayerContractWhereInput[]
    OR?: PlayerContractWhereInput[]
    NOT?: PlayerContractWhereInput | PlayerContractWhereInput[]
    id?: StringFilter<"PlayerContract"> | string
    playerId?: StringNullableFilter<"PlayerContract"> | string | null
    teamId?: StringNullableFilter<"PlayerContract"> | string | null
    signedDate?: DateTimeNullableFilter<"PlayerContract"> | Date | string | null
    startSeason?: IntNullableFilter<"PlayerContract"> | number | null
    endSeason?: IntNullableFilter<"PlayerContract"> | number | null
    totalValue?: IntNullableFilter<"PlayerContract"> | number | null
    averagePerYear?: IntNullableFilter<"PlayerContract"> | number | null
    totalGuaranteed?: IntNullableFilter<"PlayerContract"> | number | null
    isRookieContract?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isFranchiseTag?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isExtension?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isPlayerOptOut?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isTeamOptOut?: BoolNullableFilter<"PlayerContract"> | boolean | null
    createdAt?: DateTimeFilter<"PlayerContract"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerContract"> | Date | string
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    bonuses?: ContractBonusListRelationFilter
    salaries?: SalaryByYearListRelationFilter
    capHits?: CapHitByYearListRelationFilter
    deadCaps?: DeadCapByYearListRelationFilter
    optOutYears?: OptOutYearListRelationFilter
    restructureEvents?: RestructureEventListRelationFilter
    clauses?: ContractClauseListRelationFilter
  }

  export type PlayerContractOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    signedDate?: SortOrderInput | SortOrder
    startSeason?: SortOrderInput | SortOrder
    endSeason?: SortOrderInput | SortOrder
    totalValue?: SortOrderInput | SortOrder
    averagePerYear?: SortOrderInput | SortOrder
    totalGuaranteed?: SortOrderInput | SortOrder
    isRookieContract?: SortOrderInput | SortOrder
    isFranchiseTag?: SortOrderInput | SortOrder
    isExtension?: SortOrderInput | SortOrder
    isPlayerOptOut?: SortOrderInput | SortOrder
    isTeamOptOut?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    bonuses?: ContractBonusOrderByRelationAggregateInput
    salaries?: SalaryByYearOrderByRelationAggregateInput
    capHits?: CapHitByYearOrderByRelationAggregateInput
    deadCaps?: DeadCapByYearOrderByRelationAggregateInput
    optOutYears?: OptOutYearOrderByRelationAggregateInput
    restructureEvents?: RestructureEventOrderByRelationAggregateInput
    clauses?: ContractClauseOrderByRelationAggregateInput
  }

  export type PlayerContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    teamId?: string
    AND?: PlayerContractWhereInput | PlayerContractWhereInput[]
    OR?: PlayerContractWhereInput[]
    NOT?: PlayerContractWhereInput | PlayerContractWhereInput[]
    signedDate?: DateTimeNullableFilter<"PlayerContract"> | Date | string | null
    startSeason?: IntNullableFilter<"PlayerContract"> | number | null
    endSeason?: IntNullableFilter<"PlayerContract"> | number | null
    totalValue?: IntNullableFilter<"PlayerContract"> | number | null
    averagePerYear?: IntNullableFilter<"PlayerContract"> | number | null
    totalGuaranteed?: IntNullableFilter<"PlayerContract"> | number | null
    isRookieContract?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isFranchiseTag?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isExtension?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isPlayerOptOut?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isTeamOptOut?: BoolNullableFilter<"PlayerContract"> | boolean | null
    createdAt?: DateTimeFilter<"PlayerContract"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerContract"> | Date | string
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    bonuses?: ContractBonusListRelationFilter
    salaries?: SalaryByYearListRelationFilter
    capHits?: CapHitByYearListRelationFilter
    deadCaps?: DeadCapByYearListRelationFilter
    optOutYears?: OptOutYearListRelationFilter
    restructureEvents?: RestructureEventListRelationFilter
    clauses?: ContractClauseListRelationFilter
  }, "id" | "playerId" | "teamId">

  export type PlayerContractOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    signedDate?: SortOrderInput | SortOrder
    startSeason?: SortOrderInput | SortOrder
    endSeason?: SortOrderInput | SortOrder
    totalValue?: SortOrderInput | SortOrder
    averagePerYear?: SortOrderInput | SortOrder
    totalGuaranteed?: SortOrderInput | SortOrder
    isRookieContract?: SortOrderInput | SortOrder
    isFranchiseTag?: SortOrderInput | SortOrder
    isExtension?: SortOrderInput | SortOrder
    isPlayerOptOut?: SortOrderInput | SortOrder
    isTeamOptOut?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerContractCountOrderByAggregateInput
    _avg?: PlayerContractAvgOrderByAggregateInput
    _max?: PlayerContractMaxOrderByAggregateInput
    _min?: PlayerContractMinOrderByAggregateInput
    _sum?: PlayerContractSumOrderByAggregateInput
  }

  export type PlayerContractScalarWhereWithAggregatesInput = {
    AND?: PlayerContractScalarWhereWithAggregatesInput | PlayerContractScalarWhereWithAggregatesInput[]
    OR?: PlayerContractScalarWhereWithAggregatesInput[]
    NOT?: PlayerContractScalarWhereWithAggregatesInput | PlayerContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerContract"> | string
    playerId?: StringNullableWithAggregatesFilter<"PlayerContract"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"PlayerContract"> | string | null
    signedDate?: DateTimeNullableWithAggregatesFilter<"PlayerContract"> | Date | string | null
    startSeason?: IntNullableWithAggregatesFilter<"PlayerContract"> | number | null
    endSeason?: IntNullableWithAggregatesFilter<"PlayerContract"> | number | null
    totalValue?: IntNullableWithAggregatesFilter<"PlayerContract"> | number | null
    averagePerYear?: IntNullableWithAggregatesFilter<"PlayerContract"> | number | null
    totalGuaranteed?: IntNullableWithAggregatesFilter<"PlayerContract"> | number | null
    isRookieContract?: BoolNullableWithAggregatesFilter<"PlayerContract"> | boolean | null
    isFranchiseTag?: BoolNullableWithAggregatesFilter<"PlayerContract"> | boolean | null
    isExtension?: BoolNullableWithAggregatesFilter<"PlayerContract"> | boolean | null
    isPlayerOptOut?: BoolNullableWithAggregatesFilter<"PlayerContract"> | boolean | null
    isTeamOptOut?: BoolNullableWithAggregatesFilter<"PlayerContract"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"PlayerContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerContract"> | Date | string
  }

  export type ContractBonusWhereInput = {
    AND?: ContractBonusWhereInput | ContractBonusWhereInput[]
    OR?: ContractBonusWhereInput[]
    NOT?: ContractBonusWhereInput | ContractBonusWhereInput[]
    id?: StringFilter<"ContractBonus"> | string
    contractId?: StringFilter<"ContractBonus"> | string
    year?: IntFilter<"ContractBonus"> | number
    signingBonus?: IntNullableFilter<"ContractBonus"> | number | null
    rosterBonus?: IntNullableFilter<"ContractBonus"> | number | null
    workoutBonus?: IntNullableFilter<"ContractBonus"> | number | null
    incentiveBonus?: IntNullableFilter<"ContractBonus"> | number | null
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }

  export type ContractBonusOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    signingBonus?: SortOrderInput | SortOrder
    rosterBonus?: SortOrderInput | SortOrder
    workoutBonus?: SortOrderInput | SortOrder
    incentiveBonus?: SortOrderInput | SortOrder
    contract?: PlayerContractOrderByWithRelationInput
  }

  export type ContractBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractBonusWhereInput | ContractBonusWhereInput[]
    OR?: ContractBonusWhereInput[]
    NOT?: ContractBonusWhereInput | ContractBonusWhereInput[]
    contractId?: StringFilter<"ContractBonus"> | string
    year?: IntFilter<"ContractBonus"> | number
    signingBonus?: IntNullableFilter<"ContractBonus"> | number | null
    rosterBonus?: IntNullableFilter<"ContractBonus"> | number | null
    workoutBonus?: IntNullableFilter<"ContractBonus"> | number | null
    incentiveBonus?: IntNullableFilter<"ContractBonus"> | number | null
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }, "id">

  export type ContractBonusOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    signingBonus?: SortOrderInput | SortOrder
    rosterBonus?: SortOrderInput | SortOrder
    workoutBonus?: SortOrderInput | SortOrder
    incentiveBonus?: SortOrderInput | SortOrder
    _count?: ContractBonusCountOrderByAggregateInput
    _avg?: ContractBonusAvgOrderByAggregateInput
    _max?: ContractBonusMaxOrderByAggregateInput
    _min?: ContractBonusMinOrderByAggregateInput
    _sum?: ContractBonusSumOrderByAggregateInput
  }

  export type ContractBonusScalarWhereWithAggregatesInput = {
    AND?: ContractBonusScalarWhereWithAggregatesInput | ContractBonusScalarWhereWithAggregatesInput[]
    OR?: ContractBonusScalarWhereWithAggregatesInput[]
    NOT?: ContractBonusScalarWhereWithAggregatesInput | ContractBonusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractBonus"> | string
    contractId?: StringWithAggregatesFilter<"ContractBonus"> | string
    year?: IntWithAggregatesFilter<"ContractBonus"> | number
    signingBonus?: IntNullableWithAggregatesFilter<"ContractBonus"> | number | null
    rosterBonus?: IntNullableWithAggregatesFilter<"ContractBonus"> | number | null
    workoutBonus?: IntNullableWithAggregatesFilter<"ContractBonus"> | number | null
    incentiveBonus?: IntNullableWithAggregatesFilter<"ContractBonus"> | number | null
  }

  export type SalaryByYearWhereInput = {
    AND?: SalaryByYearWhereInput | SalaryByYearWhereInput[]
    OR?: SalaryByYearWhereInput[]
    NOT?: SalaryByYearWhereInput | SalaryByYearWhereInput[]
    id?: StringFilter<"SalaryByYear"> | string
    contractId?: StringFilter<"SalaryByYear"> | string
    year?: IntFilter<"SalaryByYear"> | number
    amount?: IntFilter<"SalaryByYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }

  export type SalaryByYearOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    contract?: PlayerContractOrderByWithRelationInput
  }

  export type SalaryByYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalaryByYearWhereInput | SalaryByYearWhereInput[]
    OR?: SalaryByYearWhereInput[]
    NOT?: SalaryByYearWhereInput | SalaryByYearWhereInput[]
    contractId?: StringFilter<"SalaryByYear"> | string
    year?: IntFilter<"SalaryByYear"> | number
    amount?: IntFilter<"SalaryByYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }, "id">

  export type SalaryByYearOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    _count?: SalaryByYearCountOrderByAggregateInput
    _avg?: SalaryByYearAvgOrderByAggregateInput
    _max?: SalaryByYearMaxOrderByAggregateInput
    _min?: SalaryByYearMinOrderByAggregateInput
    _sum?: SalaryByYearSumOrderByAggregateInput
  }

  export type SalaryByYearScalarWhereWithAggregatesInput = {
    AND?: SalaryByYearScalarWhereWithAggregatesInput | SalaryByYearScalarWhereWithAggregatesInput[]
    OR?: SalaryByYearScalarWhereWithAggregatesInput[]
    NOT?: SalaryByYearScalarWhereWithAggregatesInput | SalaryByYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalaryByYear"> | string
    contractId?: StringWithAggregatesFilter<"SalaryByYear"> | string
    year?: IntWithAggregatesFilter<"SalaryByYear"> | number
    amount?: IntWithAggregatesFilter<"SalaryByYear"> | number
  }

  export type CapHitByYearWhereInput = {
    AND?: CapHitByYearWhereInput | CapHitByYearWhereInput[]
    OR?: CapHitByYearWhereInput[]
    NOT?: CapHitByYearWhereInput | CapHitByYearWhereInput[]
    id?: StringFilter<"CapHitByYear"> | string
    contractId?: StringFilter<"CapHitByYear"> | string
    year?: IntFilter<"CapHitByYear"> | number
    amount?: IntFilter<"CapHitByYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }

  export type CapHitByYearOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    contract?: PlayerContractOrderByWithRelationInput
  }

  export type CapHitByYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CapHitByYearWhereInput | CapHitByYearWhereInput[]
    OR?: CapHitByYearWhereInput[]
    NOT?: CapHitByYearWhereInput | CapHitByYearWhereInput[]
    contractId?: StringFilter<"CapHitByYear"> | string
    year?: IntFilter<"CapHitByYear"> | number
    amount?: IntFilter<"CapHitByYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }, "id">

  export type CapHitByYearOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    _count?: CapHitByYearCountOrderByAggregateInput
    _avg?: CapHitByYearAvgOrderByAggregateInput
    _max?: CapHitByYearMaxOrderByAggregateInput
    _min?: CapHitByYearMinOrderByAggregateInput
    _sum?: CapHitByYearSumOrderByAggregateInput
  }

  export type CapHitByYearScalarWhereWithAggregatesInput = {
    AND?: CapHitByYearScalarWhereWithAggregatesInput | CapHitByYearScalarWhereWithAggregatesInput[]
    OR?: CapHitByYearScalarWhereWithAggregatesInput[]
    NOT?: CapHitByYearScalarWhereWithAggregatesInput | CapHitByYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CapHitByYear"> | string
    contractId?: StringWithAggregatesFilter<"CapHitByYear"> | string
    year?: IntWithAggregatesFilter<"CapHitByYear"> | number
    amount?: IntWithAggregatesFilter<"CapHitByYear"> | number
  }

  export type DeadCapByYearWhereInput = {
    AND?: DeadCapByYearWhereInput | DeadCapByYearWhereInput[]
    OR?: DeadCapByYearWhereInput[]
    NOT?: DeadCapByYearWhereInput | DeadCapByYearWhereInput[]
    id?: StringFilter<"DeadCapByYear"> | string
    contractId?: StringFilter<"DeadCapByYear"> | string
    year?: IntFilter<"DeadCapByYear"> | number
    amount?: IntFilter<"DeadCapByYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }

  export type DeadCapByYearOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    contract?: PlayerContractOrderByWithRelationInput
  }

  export type DeadCapByYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId?: string
    AND?: DeadCapByYearWhereInput | DeadCapByYearWhereInput[]
    OR?: DeadCapByYearWhereInput[]
    NOT?: DeadCapByYearWhereInput | DeadCapByYearWhereInput[]
    year?: IntFilter<"DeadCapByYear"> | number
    amount?: IntFilter<"DeadCapByYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }, "id" | "contractId">

  export type DeadCapByYearOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    _count?: DeadCapByYearCountOrderByAggregateInput
    _avg?: DeadCapByYearAvgOrderByAggregateInput
    _max?: DeadCapByYearMaxOrderByAggregateInput
    _min?: DeadCapByYearMinOrderByAggregateInput
    _sum?: DeadCapByYearSumOrderByAggregateInput
  }

  export type DeadCapByYearScalarWhereWithAggregatesInput = {
    AND?: DeadCapByYearScalarWhereWithAggregatesInput | DeadCapByYearScalarWhereWithAggregatesInput[]
    OR?: DeadCapByYearScalarWhereWithAggregatesInput[]
    NOT?: DeadCapByYearScalarWhereWithAggregatesInput | DeadCapByYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeadCapByYear"> | string
    contractId?: StringWithAggregatesFilter<"DeadCapByYear"> | string
    year?: IntWithAggregatesFilter<"DeadCapByYear"> | number
    amount?: IntWithAggregatesFilter<"DeadCapByYear"> | number
  }

  export type OptOutYearWhereInput = {
    AND?: OptOutYearWhereInput | OptOutYearWhereInput[]
    OR?: OptOutYearWhereInput[]
    NOT?: OptOutYearWhereInput | OptOutYearWhereInput[]
    id?: StringFilter<"OptOutYear"> | string
    contractId?: StringFilter<"OptOutYear"> | string
    year?: IntFilter<"OptOutYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }

  export type OptOutYearOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    contract?: PlayerContractOrderByWithRelationInput
  }

  export type OptOutYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId?: string
    AND?: OptOutYearWhereInput | OptOutYearWhereInput[]
    OR?: OptOutYearWhereInput[]
    NOT?: OptOutYearWhereInput | OptOutYearWhereInput[]
    year?: IntFilter<"OptOutYear"> | number
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }, "id" | "contractId">

  export type OptOutYearOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    _count?: OptOutYearCountOrderByAggregateInput
    _avg?: OptOutYearAvgOrderByAggregateInput
    _max?: OptOutYearMaxOrderByAggregateInput
    _min?: OptOutYearMinOrderByAggregateInput
    _sum?: OptOutYearSumOrderByAggregateInput
  }

  export type OptOutYearScalarWhereWithAggregatesInput = {
    AND?: OptOutYearScalarWhereWithAggregatesInput | OptOutYearScalarWhereWithAggregatesInput[]
    OR?: OptOutYearScalarWhereWithAggregatesInput[]
    NOT?: OptOutYearScalarWhereWithAggregatesInput | OptOutYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptOutYear"> | string
    contractId?: StringWithAggregatesFilter<"OptOutYear"> | string
    year?: IntWithAggregatesFilter<"OptOutYear"> | number
  }

  export type RestructureEventWhereInput = {
    AND?: RestructureEventWhereInput | RestructureEventWhereInput[]
    OR?: RestructureEventWhereInput[]
    NOT?: RestructureEventWhereInput | RestructureEventWhereInput[]
    id?: StringFilter<"RestructureEvent"> | string
    contractId?: StringFilter<"RestructureEvent"> | string
    year?: IntNullableFilter<"RestructureEvent"> | number | null
    date?: DateTimeNullableFilter<"RestructureEvent"> | Date | string | null
    amountConvertedToBonus?: IntNullableFilter<"RestructureEvent"> | number | null
    newCapHit?: IntNullableFilter<"RestructureEvent"> | number | null
    newDeadCap?: IntNullableFilter<"RestructureEvent"> | number | null
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }

  export type RestructureEventOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    amountConvertedToBonus?: SortOrderInput | SortOrder
    newCapHit?: SortOrderInput | SortOrder
    newDeadCap?: SortOrderInput | SortOrder
    contract?: PlayerContractOrderByWithRelationInput
  }

  export type RestructureEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId?: string
    AND?: RestructureEventWhereInput | RestructureEventWhereInput[]
    OR?: RestructureEventWhereInput[]
    NOT?: RestructureEventWhereInput | RestructureEventWhereInput[]
    year?: IntNullableFilter<"RestructureEvent"> | number | null
    date?: DateTimeNullableFilter<"RestructureEvent"> | Date | string | null
    amountConvertedToBonus?: IntNullableFilter<"RestructureEvent"> | number | null
    newCapHit?: IntNullableFilter<"RestructureEvent"> | number | null
    newDeadCap?: IntNullableFilter<"RestructureEvent"> | number | null
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
  }, "id" | "contractId">

  export type RestructureEventOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    amountConvertedToBonus?: SortOrderInput | SortOrder
    newCapHit?: SortOrderInput | SortOrder
    newDeadCap?: SortOrderInput | SortOrder
    _count?: RestructureEventCountOrderByAggregateInput
    _avg?: RestructureEventAvgOrderByAggregateInput
    _max?: RestructureEventMaxOrderByAggregateInput
    _min?: RestructureEventMinOrderByAggregateInput
    _sum?: RestructureEventSumOrderByAggregateInput
  }

  export type RestructureEventScalarWhereWithAggregatesInput = {
    AND?: RestructureEventScalarWhereWithAggregatesInput | RestructureEventScalarWhereWithAggregatesInput[]
    OR?: RestructureEventScalarWhereWithAggregatesInput[]
    NOT?: RestructureEventScalarWhereWithAggregatesInput | RestructureEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestructureEvent"> | string
    contractId?: StringWithAggregatesFilter<"RestructureEvent"> | string
    year?: IntNullableWithAggregatesFilter<"RestructureEvent"> | number | null
    date?: DateTimeNullableWithAggregatesFilter<"RestructureEvent"> | Date | string | null
    amountConvertedToBonus?: IntNullableWithAggregatesFilter<"RestructureEvent"> | number | null
    newCapHit?: IntNullableWithAggregatesFilter<"RestructureEvent"> | number | null
    newDeadCap?: IntNullableWithAggregatesFilter<"RestructureEvent"> | number | null
  }

  export type ContractClauseWhereInput = {
    AND?: ContractClauseWhereInput | ContractClauseWhereInput[]
    OR?: ContractClauseWhereInput[]
    NOT?: ContractClauseWhereInput | ContractClauseWhereInput[]
    id?: StringFilter<"ContractClause"> | string
    contractId?: StringFilter<"ContractClause"> | string
    noTradeClause?: BoolNullableFilter<"ContractClause"> | boolean | null
    injuryGuarantee?: BoolNullableFilter<"ContractClause"> | boolean | null
    restructureEligible?: BoolNullableFilter<"ContractClause"> | boolean | null
    earlyTerminationPenalty?: FloatNullableFilter<"ContractClause"> | number | null
    performanceBonusId?: StringNullableFilter<"ContractClause"> | string | null
    rosterBonusId?: StringNullableFilter<"ContractClause"> | string | null
    workoutBonusId?: StringNullableFilter<"ContractClause"> | string | null
    optionBonusId?: StringNullableFilter<"ContractClause"> | string | null
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
    performanceBonus?: XOR<PerformanceBonusNullableScalarRelationFilter, PerformanceBonusWhereInput> | null
    rosterBonus?: XOR<RosterBonusNullableScalarRelationFilter, RosterBonusWhereInput> | null
    workoutBonus?: XOR<WorkoutBonusNullableScalarRelationFilter, WorkoutBonusWhereInput> | null
    optionBonus?: XOR<OptionBonusNullableScalarRelationFilter, OptionBonusWhereInput> | null
  }

  export type ContractClauseOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    noTradeClause?: SortOrderInput | SortOrder
    injuryGuarantee?: SortOrderInput | SortOrder
    restructureEligible?: SortOrderInput | SortOrder
    earlyTerminationPenalty?: SortOrderInput | SortOrder
    performanceBonusId?: SortOrderInput | SortOrder
    rosterBonusId?: SortOrderInput | SortOrder
    workoutBonusId?: SortOrderInput | SortOrder
    optionBonusId?: SortOrderInput | SortOrder
    contract?: PlayerContractOrderByWithRelationInput
    performanceBonus?: PerformanceBonusOrderByWithRelationInput
    rosterBonus?: RosterBonusOrderByWithRelationInput
    workoutBonus?: WorkoutBonusOrderByWithRelationInput
    optionBonus?: OptionBonusOrderByWithRelationInput
  }

  export type ContractClauseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId?: string
    performanceBonusId?: string
    rosterBonusId?: string
    workoutBonusId?: string
    optionBonusId?: string
    AND?: ContractClauseWhereInput | ContractClauseWhereInput[]
    OR?: ContractClauseWhereInput[]
    NOT?: ContractClauseWhereInput | ContractClauseWhereInput[]
    noTradeClause?: BoolNullableFilter<"ContractClause"> | boolean | null
    injuryGuarantee?: BoolNullableFilter<"ContractClause"> | boolean | null
    restructureEligible?: BoolNullableFilter<"ContractClause"> | boolean | null
    earlyTerminationPenalty?: FloatNullableFilter<"ContractClause"> | number | null
    contract?: XOR<PlayerContractScalarRelationFilter, PlayerContractWhereInput>
    performanceBonus?: XOR<PerformanceBonusNullableScalarRelationFilter, PerformanceBonusWhereInput> | null
    rosterBonus?: XOR<RosterBonusNullableScalarRelationFilter, RosterBonusWhereInput> | null
    workoutBonus?: XOR<WorkoutBonusNullableScalarRelationFilter, WorkoutBonusWhereInput> | null
    optionBonus?: XOR<OptionBonusNullableScalarRelationFilter, OptionBonusWhereInput> | null
  }, "id" | "contractId" | "performanceBonusId" | "rosterBonusId" | "workoutBonusId" | "optionBonusId">

  export type ContractClauseOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    noTradeClause?: SortOrderInput | SortOrder
    injuryGuarantee?: SortOrderInput | SortOrder
    restructureEligible?: SortOrderInput | SortOrder
    earlyTerminationPenalty?: SortOrderInput | SortOrder
    performanceBonusId?: SortOrderInput | SortOrder
    rosterBonusId?: SortOrderInput | SortOrder
    workoutBonusId?: SortOrderInput | SortOrder
    optionBonusId?: SortOrderInput | SortOrder
    _count?: ContractClauseCountOrderByAggregateInput
    _avg?: ContractClauseAvgOrderByAggregateInput
    _max?: ContractClauseMaxOrderByAggregateInput
    _min?: ContractClauseMinOrderByAggregateInput
    _sum?: ContractClauseSumOrderByAggregateInput
  }

  export type ContractClauseScalarWhereWithAggregatesInput = {
    AND?: ContractClauseScalarWhereWithAggregatesInput | ContractClauseScalarWhereWithAggregatesInput[]
    OR?: ContractClauseScalarWhereWithAggregatesInput[]
    NOT?: ContractClauseScalarWhereWithAggregatesInput | ContractClauseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractClause"> | string
    contractId?: StringWithAggregatesFilter<"ContractClause"> | string
    noTradeClause?: BoolNullableWithAggregatesFilter<"ContractClause"> | boolean | null
    injuryGuarantee?: BoolNullableWithAggregatesFilter<"ContractClause"> | boolean | null
    restructureEligible?: BoolNullableWithAggregatesFilter<"ContractClause"> | boolean | null
    earlyTerminationPenalty?: FloatNullableWithAggregatesFilter<"ContractClause"> | number | null
    performanceBonusId?: StringNullableWithAggregatesFilter<"ContractClause"> | string | null
    rosterBonusId?: StringNullableWithAggregatesFilter<"ContractClause"> | string | null
    workoutBonusId?: StringNullableWithAggregatesFilter<"ContractClause"> | string | null
    optionBonusId?: StringNullableWithAggregatesFilter<"ContractClause"> | string | null
  }

  export type PerformanceBonusWhereInput = {
    AND?: PerformanceBonusWhereInput | PerformanceBonusWhereInput[]
    OR?: PerformanceBonusWhereInput[]
    NOT?: PerformanceBonusWhereInput | PerformanceBonusWhereInput[]
    id?: StringFilter<"PerformanceBonus"> | string
    clauseId?: StringFilter<"PerformanceBonus"> | string
    proBowl?: IntNullableFilter<"PerformanceBonus"> | number | null
    allPro?: IntNullableFilter<"PerformanceBonus"> | number | null
    mvp?: IntNullableFilter<"PerformanceBonus"> | number | null
    superBowlMVP?: IntNullableFilter<"PerformanceBonus"> | number | null
    playoffAppearance?: IntNullableFilter<"PerformanceBonus"> | number | null
    clauses?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
    statMilestones?: XOR<StatMilestoneNullableScalarRelationFilter, StatMilestoneWhereInput> | null
  }

  export type PerformanceBonusOrderByWithRelationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    proBowl?: SortOrderInput | SortOrder
    allPro?: SortOrderInput | SortOrder
    mvp?: SortOrderInput | SortOrder
    superBowlMVP?: SortOrderInput | SortOrder
    playoffAppearance?: SortOrderInput | SortOrder
    clauses?: ContractClauseOrderByWithRelationInput
    statMilestones?: StatMilestoneOrderByWithRelationInput
  }

  export type PerformanceBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clauseId?: string
    AND?: PerformanceBonusWhereInput | PerformanceBonusWhereInput[]
    OR?: PerformanceBonusWhereInput[]
    NOT?: PerformanceBonusWhereInput | PerformanceBonusWhereInput[]
    proBowl?: IntNullableFilter<"PerformanceBonus"> | number | null
    allPro?: IntNullableFilter<"PerformanceBonus"> | number | null
    mvp?: IntNullableFilter<"PerformanceBonus"> | number | null
    superBowlMVP?: IntNullableFilter<"PerformanceBonus"> | number | null
    playoffAppearance?: IntNullableFilter<"PerformanceBonus"> | number | null
    clauses?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
    statMilestones?: XOR<StatMilestoneNullableScalarRelationFilter, StatMilestoneWhereInput> | null
  }, "id" | "clauseId">

  export type PerformanceBonusOrderByWithAggregationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    proBowl?: SortOrderInput | SortOrder
    allPro?: SortOrderInput | SortOrder
    mvp?: SortOrderInput | SortOrder
    superBowlMVP?: SortOrderInput | SortOrder
    playoffAppearance?: SortOrderInput | SortOrder
    _count?: PerformanceBonusCountOrderByAggregateInput
    _avg?: PerformanceBonusAvgOrderByAggregateInput
    _max?: PerformanceBonusMaxOrderByAggregateInput
    _min?: PerformanceBonusMinOrderByAggregateInput
    _sum?: PerformanceBonusSumOrderByAggregateInput
  }

  export type PerformanceBonusScalarWhereWithAggregatesInput = {
    AND?: PerformanceBonusScalarWhereWithAggregatesInput | PerformanceBonusScalarWhereWithAggregatesInput[]
    OR?: PerformanceBonusScalarWhereWithAggregatesInput[]
    NOT?: PerformanceBonusScalarWhereWithAggregatesInput | PerformanceBonusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceBonus"> | string
    clauseId?: StringWithAggregatesFilter<"PerformanceBonus"> | string
    proBowl?: IntNullableWithAggregatesFilter<"PerformanceBonus"> | number | null
    allPro?: IntNullableWithAggregatesFilter<"PerformanceBonus"> | number | null
    mvp?: IntNullableWithAggregatesFilter<"PerformanceBonus"> | number | null
    superBowlMVP?: IntNullableWithAggregatesFilter<"PerformanceBonus"> | number | null
    playoffAppearance?: IntNullableWithAggregatesFilter<"PerformanceBonus"> | number | null
  }

  export type StatMilestoneWhereInput = {
    AND?: StatMilestoneWhereInput | StatMilestoneWhereInput[]
    OR?: StatMilestoneWhereInput[]
    NOT?: StatMilestoneWhereInput | StatMilestoneWhereInput[]
    id?: StringFilter<"StatMilestone"> | string
    performanceId?: StringFilter<"StatMilestone"> | string
    yards?: IntNullableFilter<"StatMilestone"> | number | null
    touchdowns?: IntNullableFilter<"StatMilestone"> | number | null
    sacks?: IntNullableFilter<"StatMilestone"> | number | null
    interceptions?: IntNullableFilter<"StatMilestone"> | number | null
    performanceBonus?: XOR<PerformanceBonusScalarRelationFilter, PerformanceBonusWhereInput>
  }

  export type StatMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    performanceId?: SortOrder
    yards?: SortOrderInput | SortOrder
    touchdowns?: SortOrderInput | SortOrder
    sacks?: SortOrderInput | SortOrder
    interceptions?: SortOrderInput | SortOrder
    performanceBonus?: PerformanceBonusOrderByWithRelationInput
  }

  export type StatMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    performanceId?: string
    AND?: StatMilestoneWhereInput | StatMilestoneWhereInput[]
    OR?: StatMilestoneWhereInput[]
    NOT?: StatMilestoneWhereInput | StatMilestoneWhereInput[]
    yards?: IntNullableFilter<"StatMilestone"> | number | null
    touchdowns?: IntNullableFilter<"StatMilestone"> | number | null
    sacks?: IntNullableFilter<"StatMilestone"> | number | null
    interceptions?: IntNullableFilter<"StatMilestone"> | number | null
    performanceBonus?: XOR<PerformanceBonusScalarRelationFilter, PerformanceBonusWhereInput>
  }, "id" | "performanceId">

  export type StatMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    performanceId?: SortOrder
    yards?: SortOrderInput | SortOrder
    touchdowns?: SortOrderInput | SortOrder
    sacks?: SortOrderInput | SortOrder
    interceptions?: SortOrderInput | SortOrder
    _count?: StatMilestoneCountOrderByAggregateInput
    _avg?: StatMilestoneAvgOrderByAggregateInput
    _max?: StatMilestoneMaxOrderByAggregateInput
    _min?: StatMilestoneMinOrderByAggregateInput
    _sum?: StatMilestoneSumOrderByAggregateInput
  }

  export type StatMilestoneScalarWhereWithAggregatesInput = {
    AND?: StatMilestoneScalarWhereWithAggregatesInput | StatMilestoneScalarWhereWithAggregatesInput[]
    OR?: StatMilestoneScalarWhereWithAggregatesInput[]
    NOT?: StatMilestoneScalarWhereWithAggregatesInput | StatMilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatMilestone"> | string
    performanceId?: StringWithAggregatesFilter<"StatMilestone"> | string
    yards?: IntNullableWithAggregatesFilter<"StatMilestone"> | number | null
    touchdowns?: IntNullableWithAggregatesFilter<"StatMilestone"> | number | null
    sacks?: IntNullableWithAggregatesFilter<"StatMilestone"> | number | null
    interceptions?: IntNullableWithAggregatesFilter<"StatMilestone"> | number | null
  }

  export type RosterBonusWhereInput = {
    AND?: RosterBonusWhereInput | RosterBonusWhereInput[]
    OR?: RosterBonusWhereInput[]
    NOT?: RosterBonusWhereInput | RosterBonusWhereInput[]
    id?: StringFilter<"RosterBonus"> | string
    clauseId?: StringFilter<"RosterBonus"> | string
    amount?: IntNullableFilter<"RosterBonus"> | number | null
    perGame?: BoolNullableFilter<"RosterBonus"> | boolean | null
    clause?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
  }

  export type RosterBonusOrderByWithRelationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrderInput | SortOrder
    perGame?: SortOrderInput | SortOrder
    clause?: ContractClauseOrderByWithRelationInput
  }

  export type RosterBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clauseId?: string
    AND?: RosterBonusWhereInput | RosterBonusWhereInput[]
    OR?: RosterBonusWhereInput[]
    NOT?: RosterBonusWhereInput | RosterBonusWhereInput[]
    amount?: IntNullableFilter<"RosterBonus"> | number | null
    perGame?: BoolNullableFilter<"RosterBonus"> | boolean | null
    clause?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
  }, "id" | "clauseId">

  export type RosterBonusOrderByWithAggregationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrderInput | SortOrder
    perGame?: SortOrderInput | SortOrder
    _count?: RosterBonusCountOrderByAggregateInput
    _avg?: RosterBonusAvgOrderByAggregateInput
    _max?: RosterBonusMaxOrderByAggregateInput
    _min?: RosterBonusMinOrderByAggregateInput
    _sum?: RosterBonusSumOrderByAggregateInput
  }

  export type RosterBonusScalarWhereWithAggregatesInput = {
    AND?: RosterBonusScalarWhereWithAggregatesInput | RosterBonusScalarWhereWithAggregatesInput[]
    OR?: RosterBonusScalarWhereWithAggregatesInput[]
    NOT?: RosterBonusScalarWhereWithAggregatesInput | RosterBonusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RosterBonus"> | string
    clauseId?: StringWithAggregatesFilter<"RosterBonus"> | string
    amount?: IntNullableWithAggregatesFilter<"RosterBonus"> | number | null
    perGame?: BoolNullableWithAggregatesFilter<"RosterBonus"> | boolean | null
  }

  export type WorkoutBonusWhereInput = {
    AND?: WorkoutBonusWhereInput | WorkoutBonusWhereInput[]
    OR?: WorkoutBonusWhereInput[]
    NOT?: WorkoutBonusWhereInput | WorkoutBonusWhereInput[]
    id?: StringFilter<"WorkoutBonus"> | string
    clauseId?: StringFilter<"WorkoutBonus"> | string
    amount?: IntNullableFilter<"WorkoutBonus"> | number | null
    minWorkouts?: IntNullableFilter<"WorkoutBonus"> | number | null
    clause?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
  }

  export type WorkoutBonusOrderByWithRelationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrderInput | SortOrder
    minWorkouts?: SortOrderInput | SortOrder
    clause?: ContractClauseOrderByWithRelationInput
  }

  export type WorkoutBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clauseId?: string
    AND?: WorkoutBonusWhereInput | WorkoutBonusWhereInput[]
    OR?: WorkoutBonusWhereInput[]
    NOT?: WorkoutBonusWhereInput | WorkoutBonusWhereInput[]
    amount?: IntNullableFilter<"WorkoutBonus"> | number | null
    minWorkouts?: IntNullableFilter<"WorkoutBonus"> | number | null
    clause?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
  }, "id" | "clauseId">

  export type WorkoutBonusOrderByWithAggregationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrderInput | SortOrder
    minWorkouts?: SortOrderInput | SortOrder
    _count?: WorkoutBonusCountOrderByAggregateInput
    _avg?: WorkoutBonusAvgOrderByAggregateInput
    _max?: WorkoutBonusMaxOrderByAggregateInput
    _min?: WorkoutBonusMinOrderByAggregateInput
    _sum?: WorkoutBonusSumOrderByAggregateInput
  }

  export type WorkoutBonusScalarWhereWithAggregatesInput = {
    AND?: WorkoutBonusScalarWhereWithAggregatesInput | WorkoutBonusScalarWhereWithAggregatesInput[]
    OR?: WorkoutBonusScalarWhereWithAggregatesInput[]
    NOT?: WorkoutBonusScalarWhereWithAggregatesInput | WorkoutBonusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutBonus"> | string
    clauseId?: StringWithAggregatesFilter<"WorkoutBonus"> | string
    amount?: IntNullableWithAggregatesFilter<"WorkoutBonus"> | number | null
    minWorkouts?: IntNullableWithAggregatesFilter<"WorkoutBonus"> | number | null
  }

  export type OptionBonusWhereInput = {
    AND?: OptionBonusWhereInput | OptionBonusWhereInput[]
    OR?: OptionBonusWhereInput[]
    NOT?: OptionBonusWhereInput | OptionBonusWhereInput[]
    id?: StringFilter<"OptionBonus"> | string
    clauseId?: StringFilter<"OptionBonus"> | string
    year?: IntNullableFilter<"OptionBonus"> | number | null
    amount?: IntNullableFilter<"OptionBonus"> | number | null
    type?: EnumOptionTypeNullableFilter<"OptionBonus"> | $Enums.OptionType | null
    clause?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
  }

  export type OptionBonusOrderByWithRelationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    year?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    clause?: ContractClauseOrderByWithRelationInput
  }

  export type OptionBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clauseId?: string
    AND?: OptionBonusWhereInput | OptionBonusWhereInput[]
    OR?: OptionBonusWhereInput[]
    NOT?: OptionBonusWhereInput | OptionBonusWhereInput[]
    year?: IntNullableFilter<"OptionBonus"> | number | null
    amount?: IntNullableFilter<"OptionBonus"> | number | null
    type?: EnumOptionTypeNullableFilter<"OptionBonus"> | $Enums.OptionType | null
    clause?: XOR<ContractClauseScalarRelationFilter, ContractClauseWhereInput>
  }, "id" | "clauseId">

  export type OptionBonusOrderByWithAggregationInput = {
    id?: SortOrder
    clauseId?: SortOrder
    year?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: OptionBonusCountOrderByAggregateInput
    _avg?: OptionBonusAvgOrderByAggregateInput
    _max?: OptionBonusMaxOrderByAggregateInput
    _min?: OptionBonusMinOrderByAggregateInput
    _sum?: OptionBonusSumOrderByAggregateInput
  }

  export type OptionBonusScalarWhereWithAggregatesInput = {
    AND?: OptionBonusScalarWhereWithAggregatesInput | OptionBonusScalarWhereWithAggregatesInput[]
    OR?: OptionBonusScalarWhereWithAggregatesInput[]
    NOT?: OptionBonusScalarWhereWithAggregatesInput | OptionBonusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptionBonus"> | string
    clauseId?: StringWithAggregatesFilter<"OptionBonus"> | string
    year?: IntNullableWithAggregatesFilter<"OptionBonus"> | number | null
    amount?: IntNullableWithAggregatesFilter<"OptionBonus"> | number | null
    type?: EnumOptionTypeNullableWithAggregatesFilter<"OptionBonus"> | $Enums.OptionType | null
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    firstName?: StringFilter<"Agent"> | string
    lastName?: StringFilter<"Agent"> | string
    agencyName?: StringNullableFilter<"Agent"> | string | null
    reputation?: IntNullableFilter<"Agent"> | number | null
    yearsOfExperience?: IntNullableFilter<"Agent"> | number | null
    players?: PlayerListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    agencyName?: SortOrderInput | SortOrder
    reputation?: SortOrderInput | SortOrder
    yearsOfExperience?: SortOrderInput | SortOrder
    players?: PlayerOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    firstName?: StringFilter<"Agent"> | string
    lastName?: StringFilter<"Agent"> | string
    agencyName?: StringNullableFilter<"Agent"> | string | null
    reputation?: IntNullableFilter<"Agent"> | number | null
    yearsOfExperience?: IntNullableFilter<"Agent"> | number | null
    players?: PlayerListRelationFilter
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    agencyName?: SortOrderInput | SortOrder
    reputation?: SortOrderInput | SortOrder
    yearsOfExperience?: SortOrderInput | SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    firstName?: StringWithAggregatesFilter<"Agent"> | string
    lastName?: StringWithAggregatesFilter<"Agent"> | string
    agencyName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    reputation?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    yearsOfExperience?: IntNullableWithAggregatesFilter<"Agent"> | number | null
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: StringFilter<"Rating"> | string
    playerId?: StringNullableFilter<"Rating"> | string | null
    speed?: IntNullableFilter<"Rating"> | number | null
    acceleration?: IntNullableFilter<"Rating"> | number | null
    agility?: IntNullableFilter<"Rating"> | number | null
    changeOfDirection?: IntNullableFilter<"Rating"> | number | null
    strength?: IntNullableFilter<"Rating"> | number | null
    impactPower?: IntNullableFilter<"Rating"> | number | null
    verticalJump?: IntNullableFilter<"Rating"> | number | null
    stamina?: IntNullableFilter<"Rating"> | number | null
    toughness?: IntNullableFilter<"Rating"> | number | null
    awareness?: IntNullableFilter<"Rating"> | number | null
    discipline?: IntNullableFilter<"Rating"> | number | null
    injuryRecovery?: IntNullableFilter<"Rating"> | number | null
    throwPower?: IntNullableFilter<"Rating"> | number | null
    throwAccuracyShort?: IntNullableFilter<"Rating"> | number | null
    throwAccuracyMedium?: IntNullableFilter<"Rating"> | number | null
    throwAccuracyDeep?: IntNullableFilter<"Rating"> | number | null
    throwOnRun?: IntNullableFilter<"Rating"> | number | null
    playAction?: IntNullableFilter<"Rating"> | number | null
    pocketPresence?: IntNullableFilter<"Rating"> | number | null
    releaseTime?: IntNullableFilter<"Rating"> | number | null
    decisionMaking?: IntNullableFilter<"Rating"> | number | null
    scrambling?: IntNullableFilter<"Rating"> | number | null
    breakSack?: IntNullableFilter<"Rating"> | number | null
    fieldVision?: IntNullableFilter<"Rating"> | number | null
    ballSecurity?: IntNullableFilter<"Rating"> | number | null
    ballCarrierVision?: IntNullableFilter<"Rating"> | number | null
    breakTackle?: IntNullableFilter<"Rating"> | number | null
    topBallCarrierSpeed?: IntNullableFilter<"Rating"> | number | null
    trucking?: IntNullableFilter<"Rating"> | number | null
    elusiveness?: IntNullableFilter<"Rating"> | number | null
    stiffArm?: IntNullableFilter<"Rating"> | number | null
    spinMove?: IntNullableFilter<"Rating"> | number | null
    jukeMove?: IntNullableFilter<"Rating"> | number | null
    shortYardage?: IntNullableFilter<"Rating"> | number | null
    goalLine?: IntNullableFilter<"Rating"> | number | null
    openFieldRunning?: IntNullableFilter<"Rating"> | number | null
    catching?: IntNullableFilter<"Rating"> | number | null
    catchInTraffic?: IntNullableFilter<"Rating"> | number | null
    spectacularCatch?: IntNullableFilter<"Rating"> | number | null
    contestedCatches?: IntNullableFilter<"Rating"> | number | null
    yardsAfterCatch?: IntNullableFilter<"Rating"> | number | null
    jumpBallTiming?: IntNullableFilter<"Rating"> | number | null
    routeRunning?: IntNullableFilter<"Rating"> | number | null
    shortRoute?: IntNullableFilter<"Rating"> | number | null
    mediumRoute?: IntNullableFilter<"Rating"> | number | null
    deepRoute?: IntNullableFilter<"Rating"> | number | null
    separation?: IntNullableFilter<"Rating"> | number | null
    release?: IntNullableFilter<"Rating"> | number | null
    runBlocking?: IntNullableFilter<"Rating"> | number | null
    passBlocking?: IntNullableFilter<"Rating"> | number | null
    pullBlocking?: IntNullableFilter<"Rating"> | number | null
    scrambleBlocking?: IntNullableFilter<"Rating"> | number | null
    playActionBlocking?: IntNullableFilter<"Rating"> | number | null
    screenBlocking?: IntNullableFilter<"Rating"> | number | null
    leadBlocking?: IntNullableFilter<"Rating"> | number | null
    tackling?: IntNullableFilter<"Rating"> | number | null
    blockShedding?: IntNullableFilter<"Rating"> | number | null
    blitzing?: IntNullableFilter<"Rating"> | number | null
    playRecognition?: IntNullableFilter<"Rating"> | number | null
    openFieldTackling?: IntNullableFilter<"Rating"> | number | null
    coverageAgainstTEsRBs?: IntNullableFilter<"Rating"> | number | null
    coverageAgainstSlot?: IntNullableFilter<"Rating"> | number | null
    deepCoverage?: IntNullableFilter<"Rating"> | number | null
    runDefense?: IntNullableFilter<"Rating"> | number | null
    passRush?: IntNullableFilter<"Rating"> | number | null
    finessePassRush?: IntNullableFilter<"Rating"> | number | null
    powerPassRush?: IntNullableFilter<"Rating"> | number | null
    runStopping?: IntNullableFilter<"Rating"> | number | null
    penetration?: IntNullableFilter<"Rating"> | number | null
    edgeSetting?: IntNullableFilter<"Rating"> | number | null
    disengagement?: IntNullableFilter<"Rating"> | number | null
    offensiveLineRecognition?: IntNullableFilter<"Rating"> | number | null
    hitPower?: IntNullableFilter<"Rating"> | number | null
    pressCoverage?: IntNullableFilter<"Rating"> | number | null
    offBallCoverage?: IntNullableFilter<"Rating"> | number | null
    manCoverage?: IntNullableFilter<"Rating"> | number | null
    zoneCoverage?: IntNullableFilter<"Rating"> | number | null
    ballHawking?: IntNullableFilter<"Rating"> | number | null
    interceptions?: IntNullableFilter<"Rating"> | number | null
    passDeflection?: IntNullableFilter<"Rating"> | number | null
    kickPower?: IntNullableFilter<"Rating"> | number | null
    kickAccuracy?: IntNullableFilter<"Rating"> | number | null
    puntPower?: IntNullableFilter<"Rating"> | number | null
    puntAccuracy?: IntNullableFilter<"Rating"> | number | null
    onsideKickAbility?: IntNullableFilter<"Rating"> | number | null
    kickReturnVision?: IntNullableFilter<"Rating"> | number | null
    puntReturnVision?: IntNullableFilter<"Rating"> | number | null
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    acceleration?: SortOrderInput | SortOrder
    agility?: SortOrderInput | SortOrder
    changeOfDirection?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    impactPower?: SortOrderInput | SortOrder
    verticalJump?: SortOrderInput | SortOrder
    stamina?: SortOrderInput | SortOrder
    toughness?: SortOrderInput | SortOrder
    awareness?: SortOrderInput | SortOrder
    discipline?: SortOrderInput | SortOrder
    injuryRecovery?: SortOrderInput | SortOrder
    throwPower?: SortOrderInput | SortOrder
    throwAccuracyShort?: SortOrderInput | SortOrder
    throwAccuracyMedium?: SortOrderInput | SortOrder
    throwAccuracyDeep?: SortOrderInput | SortOrder
    throwOnRun?: SortOrderInput | SortOrder
    playAction?: SortOrderInput | SortOrder
    pocketPresence?: SortOrderInput | SortOrder
    releaseTime?: SortOrderInput | SortOrder
    decisionMaking?: SortOrderInput | SortOrder
    scrambling?: SortOrderInput | SortOrder
    breakSack?: SortOrderInput | SortOrder
    fieldVision?: SortOrderInput | SortOrder
    ballSecurity?: SortOrderInput | SortOrder
    ballCarrierVision?: SortOrderInput | SortOrder
    breakTackle?: SortOrderInput | SortOrder
    topBallCarrierSpeed?: SortOrderInput | SortOrder
    trucking?: SortOrderInput | SortOrder
    elusiveness?: SortOrderInput | SortOrder
    stiffArm?: SortOrderInput | SortOrder
    spinMove?: SortOrderInput | SortOrder
    jukeMove?: SortOrderInput | SortOrder
    shortYardage?: SortOrderInput | SortOrder
    goalLine?: SortOrderInput | SortOrder
    openFieldRunning?: SortOrderInput | SortOrder
    catching?: SortOrderInput | SortOrder
    catchInTraffic?: SortOrderInput | SortOrder
    spectacularCatch?: SortOrderInput | SortOrder
    contestedCatches?: SortOrderInput | SortOrder
    yardsAfterCatch?: SortOrderInput | SortOrder
    jumpBallTiming?: SortOrderInput | SortOrder
    routeRunning?: SortOrderInput | SortOrder
    shortRoute?: SortOrderInput | SortOrder
    mediumRoute?: SortOrderInput | SortOrder
    deepRoute?: SortOrderInput | SortOrder
    separation?: SortOrderInput | SortOrder
    release?: SortOrderInput | SortOrder
    runBlocking?: SortOrderInput | SortOrder
    passBlocking?: SortOrderInput | SortOrder
    pullBlocking?: SortOrderInput | SortOrder
    scrambleBlocking?: SortOrderInput | SortOrder
    playActionBlocking?: SortOrderInput | SortOrder
    screenBlocking?: SortOrderInput | SortOrder
    leadBlocking?: SortOrderInput | SortOrder
    tackling?: SortOrderInput | SortOrder
    blockShedding?: SortOrderInput | SortOrder
    blitzing?: SortOrderInput | SortOrder
    playRecognition?: SortOrderInput | SortOrder
    openFieldTackling?: SortOrderInput | SortOrder
    coverageAgainstTEsRBs?: SortOrderInput | SortOrder
    coverageAgainstSlot?: SortOrderInput | SortOrder
    deepCoverage?: SortOrderInput | SortOrder
    runDefense?: SortOrderInput | SortOrder
    passRush?: SortOrderInput | SortOrder
    finessePassRush?: SortOrderInput | SortOrder
    powerPassRush?: SortOrderInput | SortOrder
    runStopping?: SortOrderInput | SortOrder
    penetration?: SortOrderInput | SortOrder
    edgeSetting?: SortOrderInput | SortOrder
    disengagement?: SortOrderInput | SortOrder
    offensiveLineRecognition?: SortOrderInput | SortOrder
    hitPower?: SortOrderInput | SortOrder
    pressCoverage?: SortOrderInput | SortOrder
    offBallCoverage?: SortOrderInput | SortOrder
    manCoverage?: SortOrderInput | SortOrder
    zoneCoverage?: SortOrderInput | SortOrder
    ballHawking?: SortOrderInput | SortOrder
    interceptions?: SortOrderInput | SortOrder
    passDeflection?: SortOrderInput | SortOrder
    kickPower?: SortOrderInput | SortOrder
    kickAccuracy?: SortOrderInput | SortOrder
    puntPower?: SortOrderInput | SortOrder
    puntAccuracy?: SortOrderInput | SortOrder
    onsideKickAbility?: SortOrderInput | SortOrder
    kickReturnVision?: SortOrderInput | SortOrder
    puntReturnVision?: SortOrderInput | SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    speed?: IntNullableFilter<"Rating"> | number | null
    acceleration?: IntNullableFilter<"Rating"> | number | null
    agility?: IntNullableFilter<"Rating"> | number | null
    changeOfDirection?: IntNullableFilter<"Rating"> | number | null
    strength?: IntNullableFilter<"Rating"> | number | null
    impactPower?: IntNullableFilter<"Rating"> | number | null
    verticalJump?: IntNullableFilter<"Rating"> | number | null
    stamina?: IntNullableFilter<"Rating"> | number | null
    toughness?: IntNullableFilter<"Rating"> | number | null
    awareness?: IntNullableFilter<"Rating"> | number | null
    discipline?: IntNullableFilter<"Rating"> | number | null
    injuryRecovery?: IntNullableFilter<"Rating"> | number | null
    throwPower?: IntNullableFilter<"Rating"> | number | null
    throwAccuracyShort?: IntNullableFilter<"Rating"> | number | null
    throwAccuracyMedium?: IntNullableFilter<"Rating"> | number | null
    throwAccuracyDeep?: IntNullableFilter<"Rating"> | number | null
    throwOnRun?: IntNullableFilter<"Rating"> | number | null
    playAction?: IntNullableFilter<"Rating"> | number | null
    pocketPresence?: IntNullableFilter<"Rating"> | number | null
    releaseTime?: IntNullableFilter<"Rating"> | number | null
    decisionMaking?: IntNullableFilter<"Rating"> | number | null
    scrambling?: IntNullableFilter<"Rating"> | number | null
    breakSack?: IntNullableFilter<"Rating"> | number | null
    fieldVision?: IntNullableFilter<"Rating"> | number | null
    ballSecurity?: IntNullableFilter<"Rating"> | number | null
    ballCarrierVision?: IntNullableFilter<"Rating"> | number | null
    breakTackle?: IntNullableFilter<"Rating"> | number | null
    topBallCarrierSpeed?: IntNullableFilter<"Rating"> | number | null
    trucking?: IntNullableFilter<"Rating"> | number | null
    elusiveness?: IntNullableFilter<"Rating"> | number | null
    stiffArm?: IntNullableFilter<"Rating"> | number | null
    spinMove?: IntNullableFilter<"Rating"> | number | null
    jukeMove?: IntNullableFilter<"Rating"> | number | null
    shortYardage?: IntNullableFilter<"Rating"> | number | null
    goalLine?: IntNullableFilter<"Rating"> | number | null
    openFieldRunning?: IntNullableFilter<"Rating"> | number | null
    catching?: IntNullableFilter<"Rating"> | number | null
    catchInTraffic?: IntNullableFilter<"Rating"> | number | null
    spectacularCatch?: IntNullableFilter<"Rating"> | number | null
    contestedCatches?: IntNullableFilter<"Rating"> | number | null
    yardsAfterCatch?: IntNullableFilter<"Rating"> | number | null
    jumpBallTiming?: IntNullableFilter<"Rating"> | number | null
    routeRunning?: IntNullableFilter<"Rating"> | number | null
    shortRoute?: IntNullableFilter<"Rating"> | number | null
    mediumRoute?: IntNullableFilter<"Rating"> | number | null
    deepRoute?: IntNullableFilter<"Rating"> | number | null
    separation?: IntNullableFilter<"Rating"> | number | null
    release?: IntNullableFilter<"Rating"> | number | null
    runBlocking?: IntNullableFilter<"Rating"> | number | null
    passBlocking?: IntNullableFilter<"Rating"> | number | null
    pullBlocking?: IntNullableFilter<"Rating"> | number | null
    scrambleBlocking?: IntNullableFilter<"Rating"> | number | null
    playActionBlocking?: IntNullableFilter<"Rating"> | number | null
    screenBlocking?: IntNullableFilter<"Rating"> | number | null
    leadBlocking?: IntNullableFilter<"Rating"> | number | null
    tackling?: IntNullableFilter<"Rating"> | number | null
    blockShedding?: IntNullableFilter<"Rating"> | number | null
    blitzing?: IntNullableFilter<"Rating"> | number | null
    playRecognition?: IntNullableFilter<"Rating"> | number | null
    openFieldTackling?: IntNullableFilter<"Rating"> | number | null
    coverageAgainstTEsRBs?: IntNullableFilter<"Rating"> | number | null
    coverageAgainstSlot?: IntNullableFilter<"Rating"> | number | null
    deepCoverage?: IntNullableFilter<"Rating"> | number | null
    runDefense?: IntNullableFilter<"Rating"> | number | null
    passRush?: IntNullableFilter<"Rating"> | number | null
    finessePassRush?: IntNullableFilter<"Rating"> | number | null
    powerPassRush?: IntNullableFilter<"Rating"> | number | null
    runStopping?: IntNullableFilter<"Rating"> | number | null
    penetration?: IntNullableFilter<"Rating"> | number | null
    edgeSetting?: IntNullableFilter<"Rating"> | number | null
    disengagement?: IntNullableFilter<"Rating"> | number | null
    offensiveLineRecognition?: IntNullableFilter<"Rating"> | number | null
    hitPower?: IntNullableFilter<"Rating"> | number | null
    pressCoverage?: IntNullableFilter<"Rating"> | number | null
    offBallCoverage?: IntNullableFilter<"Rating"> | number | null
    manCoverage?: IntNullableFilter<"Rating"> | number | null
    zoneCoverage?: IntNullableFilter<"Rating"> | number | null
    ballHawking?: IntNullableFilter<"Rating"> | number | null
    interceptions?: IntNullableFilter<"Rating"> | number | null
    passDeflection?: IntNullableFilter<"Rating"> | number | null
    kickPower?: IntNullableFilter<"Rating"> | number | null
    kickAccuracy?: IntNullableFilter<"Rating"> | number | null
    puntPower?: IntNullableFilter<"Rating"> | number | null
    puntAccuracy?: IntNullableFilter<"Rating"> | number | null
    onsideKickAbility?: IntNullableFilter<"Rating"> | number | null
    kickReturnVision?: IntNullableFilter<"Rating"> | number | null
    puntReturnVision?: IntNullableFilter<"Rating"> | number | null
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }, "id" | "playerId">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    acceleration?: SortOrderInput | SortOrder
    agility?: SortOrderInput | SortOrder
    changeOfDirection?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    impactPower?: SortOrderInput | SortOrder
    verticalJump?: SortOrderInput | SortOrder
    stamina?: SortOrderInput | SortOrder
    toughness?: SortOrderInput | SortOrder
    awareness?: SortOrderInput | SortOrder
    discipline?: SortOrderInput | SortOrder
    injuryRecovery?: SortOrderInput | SortOrder
    throwPower?: SortOrderInput | SortOrder
    throwAccuracyShort?: SortOrderInput | SortOrder
    throwAccuracyMedium?: SortOrderInput | SortOrder
    throwAccuracyDeep?: SortOrderInput | SortOrder
    throwOnRun?: SortOrderInput | SortOrder
    playAction?: SortOrderInput | SortOrder
    pocketPresence?: SortOrderInput | SortOrder
    releaseTime?: SortOrderInput | SortOrder
    decisionMaking?: SortOrderInput | SortOrder
    scrambling?: SortOrderInput | SortOrder
    breakSack?: SortOrderInput | SortOrder
    fieldVision?: SortOrderInput | SortOrder
    ballSecurity?: SortOrderInput | SortOrder
    ballCarrierVision?: SortOrderInput | SortOrder
    breakTackle?: SortOrderInput | SortOrder
    topBallCarrierSpeed?: SortOrderInput | SortOrder
    trucking?: SortOrderInput | SortOrder
    elusiveness?: SortOrderInput | SortOrder
    stiffArm?: SortOrderInput | SortOrder
    spinMove?: SortOrderInput | SortOrder
    jukeMove?: SortOrderInput | SortOrder
    shortYardage?: SortOrderInput | SortOrder
    goalLine?: SortOrderInput | SortOrder
    openFieldRunning?: SortOrderInput | SortOrder
    catching?: SortOrderInput | SortOrder
    catchInTraffic?: SortOrderInput | SortOrder
    spectacularCatch?: SortOrderInput | SortOrder
    contestedCatches?: SortOrderInput | SortOrder
    yardsAfterCatch?: SortOrderInput | SortOrder
    jumpBallTiming?: SortOrderInput | SortOrder
    routeRunning?: SortOrderInput | SortOrder
    shortRoute?: SortOrderInput | SortOrder
    mediumRoute?: SortOrderInput | SortOrder
    deepRoute?: SortOrderInput | SortOrder
    separation?: SortOrderInput | SortOrder
    release?: SortOrderInput | SortOrder
    runBlocking?: SortOrderInput | SortOrder
    passBlocking?: SortOrderInput | SortOrder
    pullBlocking?: SortOrderInput | SortOrder
    scrambleBlocking?: SortOrderInput | SortOrder
    playActionBlocking?: SortOrderInput | SortOrder
    screenBlocking?: SortOrderInput | SortOrder
    leadBlocking?: SortOrderInput | SortOrder
    tackling?: SortOrderInput | SortOrder
    blockShedding?: SortOrderInput | SortOrder
    blitzing?: SortOrderInput | SortOrder
    playRecognition?: SortOrderInput | SortOrder
    openFieldTackling?: SortOrderInput | SortOrder
    coverageAgainstTEsRBs?: SortOrderInput | SortOrder
    coverageAgainstSlot?: SortOrderInput | SortOrder
    deepCoverage?: SortOrderInput | SortOrder
    runDefense?: SortOrderInput | SortOrder
    passRush?: SortOrderInput | SortOrder
    finessePassRush?: SortOrderInput | SortOrder
    powerPassRush?: SortOrderInput | SortOrder
    runStopping?: SortOrderInput | SortOrder
    penetration?: SortOrderInput | SortOrder
    edgeSetting?: SortOrderInput | SortOrder
    disengagement?: SortOrderInput | SortOrder
    offensiveLineRecognition?: SortOrderInput | SortOrder
    hitPower?: SortOrderInput | SortOrder
    pressCoverage?: SortOrderInput | SortOrder
    offBallCoverage?: SortOrderInput | SortOrder
    manCoverage?: SortOrderInput | SortOrder
    zoneCoverage?: SortOrderInput | SortOrder
    ballHawking?: SortOrderInput | SortOrder
    interceptions?: SortOrderInput | SortOrder
    passDeflection?: SortOrderInput | SortOrder
    kickPower?: SortOrderInput | SortOrder
    kickAccuracy?: SortOrderInput | SortOrder
    puntPower?: SortOrderInput | SortOrder
    puntAccuracy?: SortOrderInput | SortOrder
    onsideKickAbility?: SortOrderInput | SortOrder
    kickReturnVision?: SortOrderInput | SortOrder
    puntReturnVision?: SortOrderInput | SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rating"> | string
    playerId?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    speed?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    acceleration?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    agility?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    changeOfDirection?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    strength?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    impactPower?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    verticalJump?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    stamina?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    toughness?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    awareness?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    discipline?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    injuryRecovery?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    throwPower?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    throwAccuracyShort?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    throwAccuracyMedium?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    throwAccuracyDeep?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    throwOnRun?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    playAction?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    pocketPresence?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    releaseTime?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    decisionMaking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    scrambling?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    breakSack?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    fieldVision?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    ballSecurity?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    ballCarrierVision?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    breakTackle?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    topBallCarrierSpeed?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    trucking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    elusiveness?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    stiffArm?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    spinMove?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    jukeMove?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    shortYardage?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    goalLine?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    openFieldRunning?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    catching?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    catchInTraffic?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    spectacularCatch?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    contestedCatches?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    yardsAfterCatch?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    jumpBallTiming?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    routeRunning?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    shortRoute?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    mediumRoute?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    deepRoute?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    separation?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    release?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    runBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    passBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    pullBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    scrambleBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    playActionBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    screenBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    leadBlocking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    tackling?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    blockShedding?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    blitzing?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    playRecognition?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    openFieldTackling?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    coverageAgainstTEsRBs?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    coverageAgainstSlot?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    deepCoverage?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    runDefense?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    passRush?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    finessePassRush?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    powerPassRush?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    runStopping?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    penetration?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    edgeSetting?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    disengagement?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    offensiveLineRecognition?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    hitPower?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    pressCoverage?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    offBallCoverage?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    manCoverage?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    zoneCoverage?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    ballHawking?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    interceptions?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    passDeflection?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    kickPower?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    kickAccuracy?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    puntPower?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    puntAccuracy?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    onsideKickAbility?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    kickReturnVision?: IntNullableWithAggregatesFilter<"Rating"> | number | null
    puntReturnVision?: IntNullableWithAggregatesFilter<"Rating"> | number | null
  }

  export type StatWhereInput = {
    AND?: StatWhereInput | StatWhereInput[]
    OR?: StatWhereInput[]
    NOT?: StatWhereInput | StatWhereInput[]
    id?: StringFilter<"Stat"> | string
    season?: IntNullableFilter<"Stat"> | number | null
    playerId?: StringNullableFilter<"Stat"> | string | null
    gamesPlayed?: IntNullableFilter<"Stat"> | number | null
    gamesStarted?: IntNullableFilter<"Stat"> | number | null
    snaps?: IntNullableFilter<"Stat"> | number | null
    rushingAttempts?: IntNullableFilter<"Stat"> | number | null
    rushingYards?: IntNullableFilter<"Stat"> | number | null
    yardsPerCarry?: FloatNullableFilter<"Stat"> | number | null
    yardsAfterContact?: IntNullableFilter<"Stat"> | number | null
    yardsPerGame?: FloatNullableFilter<"Stat"> | number | null
    rushingLong?: IntNullableFilter<"Stat"> | number | null
    rushingTouchdowns?: IntNullableFilter<"Stat"> | number | null
    fumblesLost?: IntNullableFilter<"Stat"> | number | null
    receptions?: IntNullableFilter<"Stat"> | number | null
    receivingYards?: IntNullableFilter<"Stat"> | number | null
    yardsPerReception?: FloatNullableFilter<"Stat"> | number | null
    yardsAfterCatch?: IntNullableFilter<"Stat"> | number | null
    yardsPerTarget?: FloatNullableFilter<"Stat"> | number | null
    airYards?: IntNullableFilter<"Stat"> | number | null
    receivingLong?: IntNullableFilter<"Stat"> | number | null
    targets?: IntNullableFilter<"Stat"> | number | null
    receivingTouchdowns?: IntNullableFilter<"Stat"> | number | null
    drops?: IntNullableFilter<"Stat"> | number | null
    passingAttempts?: IntNullableFilter<"Stat"> | number | null
    passingCompletions?: IntNullableFilter<"Stat"> | number | null
    passingYards?: IntNullableFilter<"Stat"> | number | null
    yardsPerPass?: FloatNullableFilter<"Stat"> | number | null
    yardsPerCompletion?: FloatNullableFilter<"Stat"> | number | null
    completionPercentage?: FloatNullableFilter<"Stat"> | number | null
    passingTouchdowns?: IntNullableFilter<"Stat"> | number | null
    interceptions?: IntNullableFilter<"Stat"> | number | null
    sacksTaken?: IntNullableFilter<"Stat"> | number | null
    passerRating?: FloatNullableFilter<"Stat"> | number | null
    pancakes?: IntNullableFilter<"Stat"> | number | null
    sacksAllowed?: IntNullableFilter<"Stat"> | number | null
    hurriesAllowed?: IntNullableFilter<"Stat"> | number | null
    tackles?: IntNullableFilter<"Stat"> | number | null
    tacklesForLoss?: IntNullableFilter<"Stat"> | number | null
    sacks?: IntNullableFilter<"Stat"> | number | null
    interceptionsMade?: IntNullableFilter<"Stat"> | number | null
    forcedFumbles?: IntNullableFilter<"Stat"> | number | null
    fumbleRecoveries?: IntNullableFilter<"Stat"> | number | null
    passesDefended?: IntNullableFilter<"Stat"> | number | null
    defensiveTouchdowns?: IntNullableFilter<"Stat"> | number | null
    fieldGoalsMade?: IntNullableFilter<"Stat"> | number | null
    fieldGoalsAttempted?: IntNullableFilter<"Stat"> | number | null
    extraPointsMade?: IntNullableFilter<"Stat"> | number | null
    extraPointsAttempted?: IntNullableFilter<"Stat"> | number | null
    punts?: IntNullableFilter<"Stat"> | number | null
    puntYards?: IntNullableFilter<"Stat"> | number | null
    kickReturns?: IntNullableFilter<"Stat"> | number | null
    kickReturnYards?: IntNullableFilter<"Stat"> | number | null
    puntReturns?: IntNullableFilter<"Stat"> | number | null
    puntReturnYards?: IntNullableFilter<"Stat"> | number | null
    specialTeamsTouchdowns?: IntNullableFilter<"Stat"> | number | null
    penaltiesCommitted?: IntNullableFilter<"Stat"> | number | null
    penaltyYards?: IntNullableFilter<"Stat"> | number | null
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }

  export type StatOrderByWithRelationInput = {
    id?: SortOrder
    season?: SortOrderInput | SortOrder
    playerId?: SortOrderInput | SortOrder
    gamesPlayed?: SortOrderInput | SortOrder
    gamesStarted?: SortOrderInput | SortOrder
    snaps?: SortOrderInput | SortOrder
    rushingAttempts?: SortOrderInput | SortOrder
    rushingYards?: SortOrderInput | SortOrder
    yardsPerCarry?: SortOrderInput | SortOrder
    yardsAfterContact?: SortOrderInput | SortOrder
    yardsPerGame?: SortOrderInput | SortOrder
    rushingLong?: SortOrderInput | SortOrder
    rushingTouchdowns?: SortOrderInput | SortOrder
    fumblesLost?: SortOrderInput | SortOrder
    receptions?: SortOrderInput | SortOrder
    receivingYards?: SortOrderInput | SortOrder
    yardsPerReception?: SortOrderInput | SortOrder
    yardsAfterCatch?: SortOrderInput | SortOrder
    yardsPerTarget?: SortOrderInput | SortOrder
    airYards?: SortOrderInput | SortOrder
    receivingLong?: SortOrderInput | SortOrder
    targets?: SortOrderInput | SortOrder
    receivingTouchdowns?: SortOrderInput | SortOrder
    drops?: SortOrderInput | SortOrder
    passingAttempts?: SortOrderInput | SortOrder
    passingCompletions?: SortOrderInput | SortOrder
    passingYards?: SortOrderInput | SortOrder
    yardsPerPass?: SortOrderInput | SortOrder
    yardsPerCompletion?: SortOrderInput | SortOrder
    completionPercentage?: SortOrderInput | SortOrder
    passingTouchdowns?: SortOrderInput | SortOrder
    interceptions?: SortOrderInput | SortOrder
    sacksTaken?: SortOrderInput | SortOrder
    passerRating?: SortOrderInput | SortOrder
    pancakes?: SortOrderInput | SortOrder
    sacksAllowed?: SortOrderInput | SortOrder
    hurriesAllowed?: SortOrderInput | SortOrder
    tackles?: SortOrderInput | SortOrder
    tacklesForLoss?: SortOrderInput | SortOrder
    sacks?: SortOrderInput | SortOrder
    interceptionsMade?: SortOrderInput | SortOrder
    forcedFumbles?: SortOrderInput | SortOrder
    fumbleRecoveries?: SortOrderInput | SortOrder
    passesDefended?: SortOrderInput | SortOrder
    defensiveTouchdowns?: SortOrderInput | SortOrder
    fieldGoalsMade?: SortOrderInput | SortOrder
    fieldGoalsAttempted?: SortOrderInput | SortOrder
    extraPointsMade?: SortOrderInput | SortOrder
    extraPointsAttempted?: SortOrderInput | SortOrder
    punts?: SortOrderInput | SortOrder
    puntYards?: SortOrderInput | SortOrder
    kickReturns?: SortOrderInput | SortOrder
    kickReturnYards?: SortOrderInput | SortOrder
    puntReturns?: SortOrderInput | SortOrder
    puntReturnYards?: SortOrderInput | SortOrder
    specialTeamsTouchdowns?: SortOrderInput | SortOrder
    penaltiesCommitted?: SortOrderInput | SortOrder
    penaltyYards?: SortOrderInput | SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type StatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    playerId_season?: StatPlayerIdSeasonCompoundUniqueInput
    AND?: StatWhereInput | StatWhereInput[]
    OR?: StatWhereInput[]
    NOT?: StatWhereInput | StatWhereInput[]
    season?: IntNullableFilter<"Stat"> | number | null
    gamesPlayed?: IntNullableFilter<"Stat"> | number | null
    gamesStarted?: IntNullableFilter<"Stat"> | number | null
    snaps?: IntNullableFilter<"Stat"> | number | null
    rushingAttempts?: IntNullableFilter<"Stat"> | number | null
    rushingYards?: IntNullableFilter<"Stat"> | number | null
    yardsPerCarry?: FloatNullableFilter<"Stat"> | number | null
    yardsAfterContact?: IntNullableFilter<"Stat"> | number | null
    yardsPerGame?: FloatNullableFilter<"Stat"> | number | null
    rushingLong?: IntNullableFilter<"Stat"> | number | null
    rushingTouchdowns?: IntNullableFilter<"Stat"> | number | null
    fumblesLost?: IntNullableFilter<"Stat"> | number | null
    receptions?: IntNullableFilter<"Stat"> | number | null
    receivingYards?: IntNullableFilter<"Stat"> | number | null
    yardsPerReception?: FloatNullableFilter<"Stat"> | number | null
    yardsAfterCatch?: IntNullableFilter<"Stat"> | number | null
    yardsPerTarget?: FloatNullableFilter<"Stat"> | number | null
    airYards?: IntNullableFilter<"Stat"> | number | null
    receivingLong?: IntNullableFilter<"Stat"> | number | null
    targets?: IntNullableFilter<"Stat"> | number | null
    receivingTouchdowns?: IntNullableFilter<"Stat"> | number | null
    drops?: IntNullableFilter<"Stat"> | number | null
    passingAttempts?: IntNullableFilter<"Stat"> | number | null
    passingCompletions?: IntNullableFilter<"Stat"> | number | null
    passingYards?: IntNullableFilter<"Stat"> | number | null
    yardsPerPass?: FloatNullableFilter<"Stat"> | number | null
    yardsPerCompletion?: FloatNullableFilter<"Stat"> | number | null
    completionPercentage?: FloatNullableFilter<"Stat"> | number | null
    passingTouchdowns?: IntNullableFilter<"Stat"> | number | null
    interceptions?: IntNullableFilter<"Stat"> | number | null
    sacksTaken?: IntNullableFilter<"Stat"> | number | null
    passerRating?: FloatNullableFilter<"Stat"> | number | null
    pancakes?: IntNullableFilter<"Stat"> | number | null
    sacksAllowed?: IntNullableFilter<"Stat"> | number | null
    hurriesAllowed?: IntNullableFilter<"Stat"> | number | null
    tackles?: IntNullableFilter<"Stat"> | number | null
    tacklesForLoss?: IntNullableFilter<"Stat"> | number | null
    sacks?: IntNullableFilter<"Stat"> | number | null
    interceptionsMade?: IntNullableFilter<"Stat"> | number | null
    forcedFumbles?: IntNullableFilter<"Stat"> | number | null
    fumbleRecoveries?: IntNullableFilter<"Stat"> | number | null
    passesDefended?: IntNullableFilter<"Stat"> | number | null
    defensiveTouchdowns?: IntNullableFilter<"Stat"> | number | null
    fieldGoalsMade?: IntNullableFilter<"Stat"> | number | null
    fieldGoalsAttempted?: IntNullableFilter<"Stat"> | number | null
    extraPointsMade?: IntNullableFilter<"Stat"> | number | null
    extraPointsAttempted?: IntNullableFilter<"Stat"> | number | null
    punts?: IntNullableFilter<"Stat"> | number | null
    puntYards?: IntNullableFilter<"Stat"> | number | null
    kickReturns?: IntNullableFilter<"Stat"> | number | null
    kickReturnYards?: IntNullableFilter<"Stat"> | number | null
    puntReturns?: IntNullableFilter<"Stat"> | number | null
    puntReturnYards?: IntNullableFilter<"Stat"> | number | null
    specialTeamsTouchdowns?: IntNullableFilter<"Stat"> | number | null
    penaltiesCommitted?: IntNullableFilter<"Stat"> | number | null
    penaltyYards?: IntNullableFilter<"Stat"> | number | null
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }, "id" | "playerId" | "playerId_season">

  export type StatOrderByWithAggregationInput = {
    id?: SortOrder
    season?: SortOrderInput | SortOrder
    playerId?: SortOrderInput | SortOrder
    gamesPlayed?: SortOrderInput | SortOrder
    gamesStarted?: SortOrderInput | SortOrder
    snaps?: SortOrderInput | SortOrder
    rushingAttempts?: SortOrderInput | SortOrder
    rushingYards?: SortOrderInput | SortOrder
    yardsPerCarry?: SortOrderInput | SortOrder
    yardsAfterContact?: SortOrderInput | SortOrder
    yardsPerGame?: SortOrderInput | SortOrder
    rushingLong?: SortOrderInput | SortOrder
    rushingTouchdowns?: SortOrderInput | SortOrder
    fumblesLost?: SortOrderInput | SortOrder
    receptions?: SortOrderInput | SortOrder
    receivingYards?: SortOrderInput | SortOrder
    yardsPerReception?: SortOrderInput | SortOrder
    yardsAfterCatch?: SortOrderInput | SortOrder
    yardsPerTarget?: SortOrderInput | SortOrder
    airYards?: SortOrderInput | SortOrder
    receivingLong?: SortOrderInput | SortOrder
    targets?: SortOrderInput | SortOrder
    receivingTouchdowns?: SortOrderInput | SortOrder
    drops?: SortOrderInput | SortOrder
    passingAttempts?: SortOrderInput | SortOrder
    passingCompletions?: SortOrderInput | SortOrder
    passingYards?: SortOrderInput | SortOrder
    yardsPerPass?: SortOrderInput | SortOrder
    yardsPerCompletion?: SortOrderInput | SortOrder
    completionPercentage?: SortOrderInput | SortOrder
    passingTouchdowns?: SortOrderInput | SortOrder
    interceptions?: SortOrderInput | SortOrder
    sacksTaken?: SortOrderInput | SortOrder
    passerRating?: SortOrderInput | SortOrder
    pancakes?: SortOrderInput | SortOrder
    sacksAllowed?: SortOrderInput | SortOrder
    hurriesAllowed?: SortOrderInput | SortOrder
    tackles?: SortOrderInput | SortOrder
    tacklesForLoss?: SortOrderInput | SortOrder
    sacks?: SortOrderInput | SortOrder
    interceptionsMade?: SortOrderInput | SortOrder
    forcedFumbles?: SortOrderInput | SortOrder
    fumbleRecoveries?: SortOrderInput | SortOrder
    passesDefended?: SortOrderInput | SortOrder
    defensiveTouchdowns?: SortOrderInput | SortOrder
    fieldGoalsMade?: SortOrderInput | SortOrder
    fieldGoalsAttempted?: SortOrderInput | SortOrder
    extraPointsMade?: SortOrderInput | SortOrder
    extraPointsAttempted?: SortOrderInput | SortOrder
    punts?: SortOrderInput | SortOrder
    puntYards?: SortOrderInput | SortOrder
    kickReturns?: SortOrderInput | SortOrder
    kickReturnYards?: SortOrderInput | SortOrder
    puntReturns?: SortOrderInput | SortOrder
    puntReturnYards?: SortOrderInput | SortOrder
    specialTeamsTouchdowns?: SortOrderInput | SortOrder
    penaltiesCommitted?: SortOrderInput | SortOrder
    penaltyYards?: SortOrderInput | SortOrder
    _count?: StatCountOrderByAggregateInput
    _avg?: StatAvgOrderByAggregateInput
    _max?: StatMaxOrderByAggregateInput
    _min?: StatMinOrderByAggregateInput
    _sum?: StatSumOrderByAggregateInput
  }

  export type StatScalarWhereWithAggregatesInput = {
    AND?: StatScalarWhereWithAggregatesInput | StatScalarWhereWithAggregatesInput[]
    OR?: StatScalarWhereWithAggregatesInput[]
    NOT?: StatScalarWhereWithAggregatesInput | StatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stat"> | string
    season?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    playerId?: StringNullableWithAggregatesFilter<"Stat"> | string | null
    gamesPlayed?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    gamesStarted?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    snaps?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    rushingAttempts?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    rushingYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    yardsPerCarry?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    yardsAfterContact?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    yardsPerGame?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    rushingLong?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    rushingTouchdowns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    fumblesLost?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    receptions?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    receivingYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    yardsPerReception?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    yardsAfterCatch?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    yardsPerTarget?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    airYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    receivingLong?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    targets?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    receivingTouchdowns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    drops?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    passingAttempts?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    passingCompletions?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    passingYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    yardsPerPass?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    yardsPerCompletion?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    completionPercentage?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    passingTouchdowns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    interceptions?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    sacksTaken?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    passerRating?: FloatNullableWithAggregatesFilter<"Stat"> | number | null
    pancakes?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    sacksAllowed?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    hurriesAllowed?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    tackles?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    tacklesForLoss?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    sacks?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    interceptionsMade?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    forcedFumbles?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    fumbleRecoveries?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    passesDefended?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    defensiveTouchdowns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    fieldGoalsMade?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    fieldGoalsAttempted?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    extraPointsMade?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    extraPointsAttempted?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    punts?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    puntYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    kickReturns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    kickReturnYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    puntReturns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    puntReturnYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    specialTeamsTouchdowns?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    penaltiesCommitted?: IntNullableWithAggregatesFilter<"Stat"> | number | null
    penaltyYards?: IntNullableWithAggregatesFilter<"Stat"> | number | null
  }

  export type ContractDesiresWhereInput = {
    AND?: ContractDesiresWhereInput | ContractDesiresWhereInput[]
    OR?: ContractDesiresWhereInput[]
    NOT?: ContractDesiresWhereInput | ContractDesiresWhereInput[]
    id?: StringFilter<"ContractDesires"> | string
    years?: IntNullableFilter<"ContractDesires"> | number | null
    averageSalary?: IntNullableFilter<"ContractDesires"> | number | null
    totalGuaranteed?: IntNullableFilter<"ContractDesires"> | number | null
    bonuses?: JsonNullableFilter<"ContractDesires">
    tradeClause?: BoolNullableFilter<"ContractDesires"> | boolean | null
    injuryGuarantee?: BoolNullableFilter<"ContractDesires"> | boolean | null
    rosterBonus?: JsonNullableFilter<"ContractDesires">
    workoutBonus?: JsonNullableFilter<"ContractDesires">
    incentives?: JsonNullableFilter<"ContractDesires">
    optOutYears?: IntNullableListFilter<"ContractDesires">
    isPlayerOptOut?: BoolNullableFilter<"ContractDesires"> | boolean | null
    isTeamOptOut?: BoolNullableFilter<"ContractDesires"> | boolean | null
    playerId?: StringNullableFilter<"ContractDesires"> | string | null
    player?: PlayerListRelationFilter
  }

  export type ContractDesiresOrderByWithRelationInput = {
    id?: SortOrder
    years?: SortOrderInput | SortOrder
    averageSalary?: SortOrderInput | SortOrder
    totalGuaranteed?: SortOrderInput | SortOrder
    bonuses?: SortOrderInput | SortOrder
    tradeClause?: SortOrderInput | SortOrder
    injuryGuarantee?: SortOrderInput | SortOrder
    rosterBonus?: SortOrderInput | SortOrder
    workoutBonus?: SortOrderInput | SortOrder
    incentives?: SortOrderInput | SortOrder
    optOutYears?: SortOrder
    isPlayerOptOut?: SortOrderInput | SortOrder
    isTeamOptOut?: SortOrderInput | SortOrder
    playerId?: SortOrderInput | SortOrder
    player?: PlayerOrderByRelationAggregateInput
  }

  export type ContractDesiresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: ContractDesiresWhereInput | ContractDesiresWhereInput[]
    OR?: ContractDesiresWhereInput[]
    NOT?: ContractDesiresWhereInput | ContractDesiresWhereInput[]
    years?: IntNullableFilter<"ContractDesires"> | number | null
    averageSalary?: IntNullableFilter<"ContractDesires"> | number | null
    totalGuaranteed?: IntNullableFilter<"ContractDesires"> | number | null
    bonuses?: JsonNullableFilter<"ContractDesires">
    tradeClause?: BoolNullableFilter<"ContractDesires"> | boolean | null
    injuryGuarantee?: BoolNullableFilter<"ContractDesires"> | boolean | null
    rosterBonus?: JsonNullableFilter<"ContractDesires">
    workoutBonus?: JsonNullableFilter<"ContractDesires">
    incentives?: JsonNullableFilter<"ContractDesires">
    optOutYears?: IntNullableListFilter<"ContractDesires">
    isPlayerOptOut?: BoolNullableFilter<"ContractDesires"> | boolean | null
    isTeamOptOut?: BoolNullableFilter<"ContractDesires"> | boolean | null
    player?: PlayerListRelationFilter
  }, "id" | "playerId">

  export type ContractDesiresOrderByWithAggregationInput = {
    id?: SortOrder
    years?: SortOrderInput | SortOrder
    averageSalary?: SortOrderInput | SortOrder
    totalGuaranteed?: SortOrderInput | SortOrder
    bonuses?: SortOrderInput | SortOrder
    tradeClause?: SortOrderInput | SortOrder
    injuryGuarantee?: SortOrderInput | SortOrder
    rosterBonus?: SortOrderInput | SortOrder
    workoutBonus?: SortOrderInput | SortOrder
    incentives?: SortOrderInput | SortOrder
    optOutYears?: SortOrder
    isPlayerOptOut?: SortOrderInput | SortOrder
    isTeamOptOut?: SortOrderInput | SortOrder
    playerId?: SortOrderInput | SortOrder
    _count?: ContractDesiresCountOrderByAggregateInput
    _avg?: ContractDesiresAvgOrderByAggregateInput
    _max?: ContractDesiresMaxOrderByAggregateInput
    _min?: ContractDesiresMinOrderByAggregateInput
    _sum?: ContractDesiresSumOrderByAggregateInput
  }

  export type ContractDesiresScalarWhereWithAggregatesInput = {
    AND?: ContractDesiresScalarWhereWithAggregatesInput | ContractDesiresScalarWhereWithAggregatesInput[]
    OR?: ContractDesiresScalarWhereWithAggregatesInput[]
    NOT?: ContractDesiresScalarWhereWithAggregatesInput | ContractDesiresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractDesires"> | string
    years?: IntNullableWithAggregatesFilter<"ContractDesires"> | number | null
    averageSalary?: IntNullableWithAggregatesFilter<"ContractDesires"> | number | null
    totalGuaranteed?: IntNullableWithAggregatesFilter<"ContractDesires"> | number | null
    bonuses?: JsonNullableWithAggregatesFilter<"ContractDesires">
    tradeClause?: BoolNullableWithAggregatesFilter<"ContractDesires"> | boolean | null
    injuryGuarantee?: BoolNullableWithAggregatesFilter<"ContractDesires"> | boolean | null
    rosterBonus?: JsonNullableWithAggregatesFilter<"ContractDesires">
    workoutBonus?: JsonNullableWithAggregatesFilter<"ContractDesires">
    incentives?: JsonNullableWithAggregatesFilter<"ContractDesires">
    optOutYears?: IntNullableListFilter<"ContractDesires">
    isPlayerOptOut?: BoolNullableWithAggregatesFilter<"ContractDesires"> | boolean | null
    isTeamOptOut?: BoolNullableWithAggregatesFilter<"ContractDesires"> | boolean | null
    playerId?: StringNullableWithAggregatesFilter<"ContractDesires"> | string | null
  }

  export type PlayerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerUncheckedCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerUncheckedCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerUncheckedCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUncheckedUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUncheckedUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUncheckedUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
  }

  export type PlayerContractCreateInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateManyInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractBonusCreateInput = {
    id?: string
    year: number
    signingBonus?: number | null
    rosterBonus?: number | null
    workoutBonus?: number | null
    incentiveBonus?: number | null
    contract: PlayerContractCreateNestedOneWithoutBonusesInput
  }

  export type ContractBonusUncheckedCreateInput = {
    id?: string
    contractId: string
    year: number
    signingBonus?: number | null
    rosterBonus?: number | null
    workoutBonus?: number | null
    incentiveBonus?: number | null
  }

  export type ContractBonusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
    contract?: PlayerContractUpdateOneRequiredWithoutBonusesNestedInput
  }

  export type ContractBonusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractBonusCreateManyInput = {
    id?: string
    contractId: string
    year: number
    signingBonus?: number | null
    rosterBonus?: number | null
    workoutBonus?: number | null
    incentiveBonus?: number | null
  }

  export type ContractBonusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractBonusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalaryByYearCreateInput = {
    id?: string
    year: number
    amount: number
    contract: PlayerContractCreateNestedOneWithoutSalariesInput
  }

  export type SalaryByYearUncheckedCreateInput = {
    id?: string
    contractId: string
    year: number
    amount: number
  }

  export type SalaryByYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    contract?: PlayerContractUpdateOneRequiredWithoutSalariesNestedInput
  }

  export type SalaryByYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryByYearCreateManyInput = {
    id?: string
    contractId: string
    year: number
    amount: number
  }

  export type SalaryByYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryByYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type CapHitByYearCreateInput = {
    id?: string
    year: number
    amount: number
    contract: PlayerContractCreateNestedOneWithoutCapHitsInput
  }

  export type CapHitByYearUncheckedCreateInput = {
    id?: string
    contractId: string
    year: number
    amount: number
  }

  export type CapHitByYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    contract?: PlayerContractUpdateOneRequiredWithoutCapHitsNestedInput
  }

  export type CapHitByYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type CapHitByYearCreateManyInput = {
    id?: string
    contractId: string
    year: number
    amount: number
  }

  export type CapHitByYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type CapHitByYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type DeadCapByYearCreateInput = {
    id?: string
    year: number
    amount: number
    contract: PlayerContractCreateNestedOneWithoutDeadCapsInput
  }

  export type DeadCapByYearUncheckedCreateInput = {
    id?: string
    contractId: string
    year: number
    amount: number
  }

  export type DeadCapByYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    contract?: PlayerContractUpdateOneRequiredWithoutDeadCapsNestedInput
  }

  export type DeadCapByYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type DeadCapByYearCreateManyInput = {
    id?: string
    contractId: string
    year: number
    amount: number
  }

  export type DeadCapByYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type DeadCapByYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OptOutYearCreateInput = {
    id?: string
    year: number
    contract: PlayerContractCreateNestedOneWithoutOptOutYearsInput
  }

  export type OptOutYearUncheckedCreateInput = {
    id?: string
    contractId: string
    year: number
  }

  export type OptOutYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    contract?: PlayerContractUpdateOneRequiredWithoutOptOutYearsNestedInput
  }

  export type OptOutYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type OptOutYearCreateManyInput = {
    id?: string
    contractId: string
    year: number
  }

  export type OptOutYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type OptOutYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type RestructureEventCreateInput = {
    id?: string
    year?: number | null
    date?: Date | string | null
    amountConvertedToBonus?: number | null
    newCapHit?: number | null
    newDeadCap?: number | null
    contract: PlayerContractCreateNestedOneWithoutRestructureEventsInput
  }

  export type RestructureEventUncheckedCreateInput = {
    id?: string
    contractId: string
    year?: number | null
    date?: Date | string | null
    amountConvertedToBonus?: number | null
    newCapHit?: number | null
    newDeadCap?: number | null
  }

  export type RestructureEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
    contract?: PlayerContractUpdateOneRequiredWithoutRestructureEventsNestedInput
  }

  export type RestructureEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RestructureEventCreateManyInput = {
    id?: string
    contractId: string
    year?: number | null
    date?: Date | string | null
    amountConvertedToBonus?: number | null
    newCapHit?: number | null
    newDeadCap?: number | null
  }

  export type RestructureEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RestructureEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractClauseCreateInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    contract: PlayerContractCreateNestedOneWithoutClausesInput
    performanceBonus?: PerformanceBonusCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUncheckedCreateInput = {
    id?: string
    contractId: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    performanceBonus?: PerformanceBonusUncheckedCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusUncheckedCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusUncheckedCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusUncheckedCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: PlayerContractUpdateOneRequiredWithoutClausesNestedInput
    performanceBonus?: PerformanceBonusUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    performanceBonus?: PerformanceBonusUncheckedUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUncheckedUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUncheckedUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUncheckedUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseCreateManyInput = {
    id?: string
    contractId: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
  }

  export type ContractClauseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractClauseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceBonusCreateInput = {
    id?: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
    clauses: ContractClauseCreateNestedOneWithoutPerformanceBonusInput
    statMilestones?: StatMilestoneCreateNestedOneWithoutPerformanceBonusInput
  }

  export type PerformanceBonusUncheckedCreateInput = {
    id?: string
    clauseId: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
    statMilestones?: StatMilestoneUncheckedCreateNestedOneWithoutPerformanceBonusInput
  }

  export type PerformanceBonusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    clauses?: ContractClauseUpdateOneRequiredWithoutPerformanceBonusNestedInput
    statMilestones?: StatMilestoneUpdateOneWithoutPerformanceBonusNestedInput
  }

  export type PerformanceBonusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    statMilestones?: StatMilestoneUncheckedUpdateOneWithoutPerformanceBonusNestedInput
  }

  export type PerformanceBonusCreateManyInput = {
    id?: string
    clauseId: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
  }

  export type PerformanceBonusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PerformanceBonusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatMilestoneCreateInput = {
    id?: string
    yards?: number | null
    touchdowns?: number | null
    sacks?: number | null
    interceptions?: number | null
    performanceBonus: PerformanceBonusCreateNestedOneWithoutStatMilestonesInput
  }

  export type StatMilestoneUncheckedCreateInput = {
    id?: string
    performanceId: string
    yards?: number | null
    touchdowns?: number | null
    sacks?: number | null
    interceptions?: number | null
  }

  export type StatMilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yards?: NullableIntFieldUpdateOperationsInput | number | null
    touchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    performanceBonus?: PerformanceBonusUpdateOneRequiredWithoutStatMilestonesNestedInput
  }

  export type StatMilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    performanceId?: StringFieldUpdateOperationsInput | string
    yards?: NullableIntFieldUpdateOperationsInput | number | null
    touchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatMilestoneCreateManyInput = {
    id?: string
    performanceId: string
    yards?: number | null
    touchdowns?: number | null
    sacks?: number | null
    interceptions?: number | null
  }

  export type StatMilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    yards?: NullableIntFieldUpdateOperationsInput | number | null
    touchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatMilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    performanceId?: StringFieldUpdateOperationsInput | string
    yards?: NullableIntFieldUpdateOperationsInput | number | null
    touchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RosterBonusCreateInput = {
    id?: string
    amount?: number | null
    perGame?: boolean | null
    clause: ContractClauseCreateNestedOneWithoutRosterBonusInput
  }

  export type RosterBonusUncheckedCreateInput = {
    id?: string
    clauseId: string
    amount?: number | null
    perGame?: boolean | null
  }

  export type RosterBonusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    perGame?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clause?: ContractClauseUpdateOneRequiredWithoutRosterBonusNestedInput
  }

  export type RosterBonusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    perGame?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RosterBonusCreateManyInput = {
    id?: string
    clauseId: string
    amount?: number | null
    perGame?: boolean | null
  }

  export type RosterBonusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    perGame?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RosterBonusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    perGame?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WorkoutBonusCreateInput = {
    id?: string
    amount?: number | null
    minWorkouts?: number | null
    clause: ContractClauseCreateNestedOneWithoutWorkoutBonusInput
  }

  export type WorkoutBonusUncheckedCreateInput = {
    id?: string
    clauseId: string
    amount?: number | null
    minWorkouts?: number | null
  }

  export type WorkoutBonusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    minWorkouts?: NullableIntFieldUpdateOperationsInput | number | null
    clause?: ContractClauseUpdateOneRequiredWithoutWorkoutBonusNestedInput
  }

  export type WorkoutBonusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    minWorkouts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutBonusCreateManyInput = {
    id?: string
    clauseId: string
    amount?: number | null
    minWorkouts?: number | null
  }

  export type WorkoutBonusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    minWorkouts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutBonusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    minWorkouts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionBonusCreateInput = {
    id?: string
    year?: number | null
    amount?: number | null
    type?: $Enums.OptionType | null
    clause: ContractClauseCreateNestedOneWithoutOptionBonusInput
  }

  export type OptionBonusUncheckedCreateInput = {
    id?: string
    clauseId: string
    year?: number | null
    amount?: number | null
    type?: $Enums.OptionType | null
  }

  export type OptionBonusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType | null
    clause?: ContractClauseUpdateOneRequiredWithoutOptionBonusNestedInput
  }

  export type OptionBonusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType | null
  }

  export type OptionBonusCreateManyInput = {
    id?: string
    clauseId: string
    year?: number | null
    amount?: number | null
    type?: $Enums.OptionType | null
  }

  export type OptionBonusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType | null
  }

  export type OptionBonusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType | null
  }

  export type AgentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    agencyName?: string | null
    reputation?: number | null
    yearsOfExperience?: number | null
    players?: PlayerCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    agencyName?: string | null
    reputation?: number | null
    yearsOfExperience?: number | null
    players?: PlayerUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    agencyName?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableIntFieldUpdateOperationsInput | number | null
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null
    players?: PlayerUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    agencyName?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableIntFieldUpdateOperationsInput | number | null
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null
    players?: PlayerUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    agencyName?: string | null
    reputation?: number | null
    yearsOfExperience?: number | null
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    agencyName?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableIntFieldUpdateOperationsInput | number | null
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    agencyName?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableIntFieldUpdateOperationsInput | number | null
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RatingCreateInput = {
    id?: string
    playerId?: string | null
    speed?: number | null
    acceleration?: number | null
    agility?: number | null
    changeOfDirection?: number | null
    strength?: number | null
    impactPower?: number | null
    verticalJump?: number | null
    stamina?: number | null
    toughness?: number | null
    awareness?: number | null
    discipline?: number | null
    injuryRecovery?: number | null
    throwPower?: number | null
    throwAccuracyShort?: number | null
    throwAccuracyMedium?: number | null
    throwAccuracyDeep?: number | null
    throwOnRun?: number | null
    playAction?: number | null
    pocketPresence?: number | null
    releaseTime?: number | null
    decisionMaking?: number | null
    scrambling?: number | null
    breakSack?: number | null
    fieldVision?: number | null
    ballSecurity?: number | null
    ballCarrierVision?: number | null
    breakTackle?: number | null
    topBallCarrierSpeed?: number | null
    trucking?: number | null
    elusiveness?: number | null
    stiffArm?: number | null
    spinMove?: number | null
    jukeMove?: number | null
    shortYardage?: number | null
    goalLine?: number | null
    openFieldRunning?: number | null
    catching?: number | null
    catchInTraffic?: number | null
    spectacularCatch?: number | null
    contestedCatches?: number | null
    yardsAfterCatch?: number | null
    jumpBallTiming?: number | null
    routeRunning?: number | null
    shortRoute?: number | null
    mediumRoute?: number | null
    deepRoute?: number | null
    separation?: number | null
    release?: number | null
    runBlocking?: number | null
    passBlocking?: number | null
    pullBlocking?: number | null
    scrambleBlocking?: number | null
    playActionBlocking?: number | null
    screenBlocking?: number | null
    leadBlocking?: number | null
    tackling?: number | null
    blockShedding?: number | null
    blitzing?: number | null
    playRecognition?: number | null
    openFieldTackling?: number | null
    coverageAgainstTEsRBs?: number | null
    coverageAgainstSlot?: number | null
    deepCoverage?: number | null
    runDefense?: number | null
    passRush?: number | null
    finessePassRush?: number | null
    powerPassRush?: number | null
    runStopping?: number | null
    penetration?: number | null
    edgeSetting?: number | null
    disengagement?: number | null
    offensiveLineRecognition?: number | null
    hitPower?: number | null
    pressCoverage?: number | null
    offBallCoverage?: number | null
    manCoverage?: number | null
    zoneCoverage?: number | null
    ballHawking?: number | null
    interceptions?: number | null
    passDeflection?: number | null
    kickPower?: number | null
    kickAccuracy?: number | null
    puntPower?: number | null
    puntAccuracy?: number | null
    onsideKickAbility?: number | null
    kickReturnVision?: number | null
    puntReturnVision?: number | null
    player?: PlayerCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: string
    playerId?: string | null
    speed?: number | null
    acceleration?: number | null
    agility?: number | null
    changeOfDirection?: number | null
    strength?: number | null
    impactPower?: number | null
    verticalJump?: number | null
    stamina?: number | null
    toughness?: number | null
    awareness?: number | null
    discipline?: number | null
    injuryRecovery?: number | null
    throwPower?: number | null
    throwAccuracyShort?: number | null
    throwAccuracyMedium?: number | null
    throwAccuracyDeep?: number | null
    throwOnRun?: number | null
    playAction?: number | null
    pocketPresence?: number | null
    releaseTime?: number | null
    decisionMaking?: number | null
    scrambling?: number | null
    breakSack?: number | null
    fieldVision?: number | null
    ballSecurity?: number | null
    ballCarrierVision?: number | null
    breakTackle?: number | null
    topBallCarrierSpeed?: number | null
    trucking?: number | null
    elusiveness?: number | null
    stiffArm?: number | null
    spinMove?: number | null
    jukeMove?: number | null
    shortYardage?: number | null
    goalLine?: number | null
    openFieldRunning?: number | null
    catching?: number | null
    catchInTraffic?: number | null
    spectacularCatch?: number | null
    contestedCatches?: number | null
    yardsAfterCatch?: number | null
    jumpBallTiming?: number | null
    routeRunning?: number | null
    shortRoute?: number | null
    mediumRoute?: number | null
    deepRoute?: number | null
    separation?: number | null
    release?: number | null
    runBlocking?: number | null
    passBlocking?: number | null
    pullBlocking?: number | null
    scrambleBlocking?: number | null
    playActionBlocking?: number | null
    screenBlocking?: number | null
    leadBlocking?: number | null
    tackling?: number | null
    blockShedding?: number | null
    blitzing?: number | null
    playRecognition?: number | null
    openFieldTackling?: number | null
    coverageAgainstTEsRBs?: number | null
    coverageAgainstSlot?: number | null
    deepCoverage?: number | null
    runDefense?: number | null
    passRush?: number | null
    finessePassRush?: number | null
    powerPassRush?: number | null
    runStopping?: number | null
    penetration?: number | null
    edgeSetting?: number | null
    disengagement?: number | null
    offensiveLineRecognition?: number | null
    hitPower?: number | null
    pressCoverage?: number | null
    offBallCoverage?: number | null
    manCoverage?: number | null
    zoneCoverage?: number | null
    ballHawking?: number | null
    interceptions?: number | null
    passDeflection?: number | null
    kickPower?: number | null
    kickAccuracy?: number | null
    puntPower?: number | null
    puntAccuracy?: number | null
    onsideKickAbility?: number | null
    kickReturnVision?: number | null
    puntReturnVision?: number | null
    player?: PlayerUncheckedCreateNestedOneWithoutRatingsInput
  }

  export type RatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableIntFieldUpdateOperationsInput | number | null
    agility?: NullableIntFieldUpdateOperationsInput | number | null
    changeOfDirection?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: NullableIntFieldUpdateOperationsInput | number | null
    impactPower?: NullableIntFieldUpdateOperationsInput | number | null
    verticalJump?: NullableIntFieldUpdateOperationsInput | number | null
    stamina?: NullableIntFieldUpdateOperationsInput | number | null
    toughness?: NullableIntFieldUpdateOperationsInput | number | null
    awareness?: NullableIntFieldUpdateOperationsInput | number | null
    discipline?: NullableIntFieldUpdateOperationsInput | number | null
    injuryRecovery?: NullableIntFieldUpdateOperationsInput | number | null
    throwPower?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyShort?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyMedium?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyDeep?: NullableIntFieldUpdateOperationsInput | number | null
    throwOnRun?: NullableIntFieldUpdateOperationsInput | number | null
    playAction?: NullableIntFieldUpdateOperationsInput | number | null
    pocketPresence?: NullableIntFieldUpdateOperationsInput | number | null
    releaseTime?: NullableIntFieldUpdateOperationsInput | number | null
    decisionMaking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambling?: NullableIntFieldUpdateOperationsInput | number | null
    breakSack?: NullableIntFieldUpdateOperationsInput | number | null
    fieldVision?: NullableIntFieldUpdateOperationsInput | number | null
    ballSecurity?: NullableIntFieldUpdateOperationsInput | number | null
    ballCarrierVision?: NullableIntFieldUpdateOperationsInput | number | null
    breakTackle?: NullableIntFieldUpdateOperationsInput | number | null
    topBallCarrierSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    trucking?: NullableIntFieldUpdateOperationsInput | number | null
    elusiveness?: NullableIntFieldUpdateOperationsInput | number | null
    stiffArm?: NullableIntFieldUpdateOperationsInput | number | null
    spinMove?: NullableIntFieldUpdateOperationsInput | number | null
    jukeMove?: NullableIntFieldUpdateOperationsInput | number | null
    shortYardage?: NullableIntFieldUpdateOperationsInput | number | null
    goalLine?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldRunning?: NullableIntFieldUpdateOperationsInput | number | null
    catching?: NullableIntFieldUpdateOperationsInput | number | null
    catchInTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    spectacularCatch?: NullableIntFieldUpdateOperationsInput | number | null
    contestedCatches?: NullableIntFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    jumpBallTiming?: NullableIntFieldUpdateOperationsInput | number | null
    routeRunning?: NullableIntFieldUpdateOperationsInput | number | null
    shortRoute?: NullableIntFieldUpdateOperationsInput | number | null
    mediumRoute?: NullableIntFieldUpdateOperationsInput | number | null
    deepRoute?: NullableIntFieldUpdateOperationsInput | number | null
    separation?: NullableIntFieldUpdateOperationsInput | number | null
    release?: NullableIntFieldUpdateOperationsInput | number | null
    runBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    passBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    pullBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambleBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    playActionBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    screenBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    leadBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    tackling?: NullableIntFieldUpdateOperationsInput | number | null
    blockShedding?: NullableIntFieldUpdateOperationsInput | number | null
    blitzing?: NullableIntFieldUpdateOperationsInput | number | null
    playRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldTackling?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstTEsRBs?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstSlot?: NullableIntFieldUpdateOperationsInput | number | null
    deepCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    runDefense?: NullableIntFieldUpdateOperationsInput | number | null
    passRush?: NullableIntFieldUpdateOperationsInput | number | null
    finessePassRush?: NullableIntFieldUpdateOperationsInput | number | null
    powerPassRush?: NullableIntFieldUpdateOperationsInput | number | null
    runStopping?: NullableIntFieldUpdateOperationsInput | number | null
    penetration?: NullableIntFieldUpdateOperationsInput | number | null
    edgeSetting?: NullableIntFieldUpdateOperationsInput | number | null
    disengagement?: NullableIntFieldUpdateOperationsInput | number | null
    offensiveLineRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    hitPower?: NullableIntFieldUpdateOperationsInput | number | null
    pressCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    offBallCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    manCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    zoneCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    ballHawking?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    passDeflection?: NullableIntFieldUpdateOperationsInput | number | null
    kickPower?: NullableIntFieldUpdateOperationsInput | number | null
    kickAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    puntPower?: NullableIntFieldUpdateOperationsInput | number | null
    puntAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    onsideKickAbility?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUpdateOneWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableIntFieldUpdateOperationsInput | number | null
    agility?: NullableIntFieldUpdateOperationsInput | number | null
    changeOfDirection?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: NullableIntFieldUpdateOperationsInput | number | null
    impactPower?: NullableIntFieldUpdateOperationsInput | number | null
    verticalJump?: NullableIntFieldUpdateOperationsInput | number | null
    stamina?: NullableIntFieldUpdateOperationsInput | number | null
    toughness?: NullableIntFieldUpdateOperationsInput | number | null
    awareness?: NullableIntFieldUpdateOperationsInput | number | null
    discipline?: NullableIntFieldUpdateOperationsInput | number | null
    injuryRecovery?: NullableIntFieldUpdateOperationsInput | number | null
    throwPower?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyShort?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyMedium?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyDeep?: NullableIntFieldUpdateOperationsInput | number | null
    throwOnRun?: NullableIntFieldUpdateOperationsInput | number | null
    playAction?: NullableIntFieldUpdateOperationsInput | number | null
    pocketPresence?: NullableIntFieldUpdateOperationsInput | number | null
    releaseTime?: NullableIntFieldUpdateOperationsInput | number | null
    decisionMaking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambling?: NullableIntFieldUpdateOperationsInput | number | null
    breakSack?: NullableIntFieldUpdateOperationsInput | number | null
    fieldVision?: NullableIntFieldUpdateOperationsInput | number | null
    ballSecurity?: NullableIntFieldUpdateOperationsInput | number | null
    ballCarrierVision?: NullableIntFieldUpdateOperationsInput | number | null
    breakTackle?: NullableIntFieldUpdateOperationsInput | number | null
    topBallCarrierSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    trucking?: NullableIntFieldUpdateOperationsInput | number | null
    elusiveness?: NullableIntFieldUpdateOperationsInput | number | null
    stiffArm?: NullableIntFieldUpdateOperationsInput | number | null
    spinMove?: NullableIntFieldUpdateOperationsInput | number | null
    jukeMove?: NullableIntFieldUpdateOperationsInput | number | null
    shortYardage?: NullableIntFieldUpdateOperationsInput | number | null
    goalLine?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldRunning?: NullableIntFieldUpdateOperationsInput | number | null
    catching?: NullableIntFieldUpdateOperationsInput | number | null
    catchInTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    spectacularCatch?: NullableIntFieldUpdateOperationsInput | number | null
    contestedCatches?: NullableIntFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    jumpBallTiming?: NullableIntFieldUpdateOperationsInput | number | null
    routeRunning?: NullableIntFieldUpdateOperationsInput | number | null
    shortRoute?: NullableIntFieldUpdateOperationsInput | number | null
    mediumRoute?: NullableIntFieldUpdateOperationsInput | number | null
    deepRoute?: NullableIntFieldUpdateOperationsInput | number | null
    separation?: NullableIntFieldUpdateOperationsInput | number | null
    release?: NullableIntFieldUpdateOperationsInput | number | null
    runBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    passBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    pullBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambleBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    playActionBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    screenBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    leadBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    tackling?: NullableIntFieldUpdateOperationsInput | number | null
    blockShedding?: NullableIntFieldUpdateOperationsInput | number | null
    blitzing?: NullableIntFieldUpdateOperationsInput | number | null
    playRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldTackling?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstTEsRBs?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstSlot?: NullableIntFieldUpdateOperationsInput | number | null
    deepCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    runDefense?: NullableIntFieldUpdateOperationsInput | number | null
    passRush?: NullableIntFieldUpdateOperationsInput | number | null
    finessePassRush?: NullableIntFieldUpdateOperationsInput | number | null
    powerPassRush?: NullableIntFieldUpdateOperationsInput | number | null
    runStopping?: NullableIntFieldUpdateOperationsInput | number | null
    penetration?: NullableIntFieldUpdateOperationsInput | number | null
    edgeSetting?: NullableIntFieldUpdateOperationsInput | number | null
    disengagement?: NullableIntFieldUpdateOperationsInput | number | null
    offensiveLineRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    hitPower?: NullableIntFieldUpdateOperationsInput | number | null
    pressCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    offBallCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    manCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    zoneCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    ballHawking?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    passDeflection?: NullableIntFieldUpdateOperationsInput | number | null
    kickPower?: NullableIntFieldUpdateOperationsInput | number | null
    kickAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    puntPower?: NullableIntFieldUpdateOperationsInput | number | null
    puntAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    onsideKickAbility?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUncheckedUpdateOneWithoutRatingsNestedInput
  }

  export type RatingCreateManyInput = {
    id?: string
    playerId?: string | null
    speed?: number | null
    acceleration?: number | null
    agility?: number | null
    changeOfDirection?: number | null
    strength?: number | null
    impactPower?: number | null
    verticalJump?: number | null
    stamina?: number | null
    toughness?: number | null
    awareness?: number | null
    discipline?: number | null
    injuryRecovery?: number | null
    throwPower?: number | null
    throwAccuracyShort?: number | null
    throwAccuracyMedium?: number | null
    throwAccuracyDeep?: number | null
    throwOnRun?: number | null
    playAction?: number | null
    pocketPresence?: number | null
    releaseTime?: number | null
    decisionMaking?: number | null
    scrambling?: number | null
    breakSack?: number | null
    fieldVision?: number | null
    ballSecurity?: number | null
    ballCarrierVision?: number | null
    breakTackle?: number | null
    topBallCarrierSpeed?: number | null
    trucking?: number | null
    elusiveness?: number | null
    stiffArm?: number | null
    spinMove?: number | null
    jukeMove?: number | null
    shortYardage?: number | null
    goalLine?: number | null
    openFieldRunning?: number | null
    catching?: number | null
    catchInTraffic?: number | null
    spectacularCatch?: number | null
    contestedCatches?: number | null
    yardsAfterCatch?: number | null
    jumpBallTiming?: number | null
    routeRunning?: number | null
    shortRoute?: number | null
    mediumRoute?: number | null
    deepRoute?: number | null
    separation?: number | null
    release?: number | null
    runBlocking?: number | null
    passBlocking?: number | null
    pullBlocking?: number | null
    scrambleBlocking?: number | null
    playActionBlocking?: number | null
    screenBlocking?: number | null
    leadBlocking?: number | null
    tackling?: number | null
    blockShedding?: number | null
    blitzing?: number | null
    playRecognition?: number | null
    openFieldTackling?: number | null
    coverageAgainstTEsRBs?: number | null
    coverageAgainstSlot?: number | null
    deepCoverage?: number | null
    runDefense?: number | null
    passRush?: number | null
    finessePassRush?: number | null
    powerPassRush?: number | null
    runStopping?: number | null
    penetration?: number | null
    edgeSetting?: number | null
    disengagement?: number | null
    offensiveLineRecognition?: number | null
    hitPower?: number | null
    pressCoverage?: number | null
    offBallCoverage?: number | null
    manCoverage?: number | null
    zoneCoverage?: number | null
    ballHawking?: number | null
    interceptions?: number | null
    passDeflection?: number | null
    kickPower?: number | null
    kickAccuracy?: number | null
    puntPower?: number | null
    puntAccuracy?: number | null
    onsideKickAbility?: number | null
    kickReturnVision?: number | null
    puntReturnVision?: number | null
  }

  export type RatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableIntFieldUpdateOperationsInput | number | null
    agility?: NullableIntFieldUpdateOperationsInput | number | null
    changeOfDirection?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: NullableIntFieldUpdateOperationsInput | number | null
    impactPower?: NullableIntFieldUpdateOperationsInput | number | null
    verticalJump?: NullableIntFieldUpdateOperationsInput | number | null
    stamina?: NullableIntFieldUpdateOperationsInput | number | null
    toughness?: NullableIntFieldUpdateOperationsInput | number | null
    awareness?: NullableIntFieldUpdateOperationsInput | number | null
    discipline?: NullableIntFieldUpdateOperationsInput | number | null
    injuryRecovery?: NullableIntFieldUpdateOperationsInput | number | null
    throwPower?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyShort?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyMedium?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyDeep?: NullableIntFieldUpdateOperationsInput | number | null
    throwOnRun?: NullableIntFieldUpdateOperationsInput | number | null
    playAction?: NullableIntFieldUpdateOperationsInput | number | null
    pocketPresence?: NullableIntFieldUpdateOperationsInput | number | null
    releaseTime?: NullableIntFieldUpdateOperationsInput | number | null
    decisionMaking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambling?: NullableIntFieldUpdateOperationsInput | number | null
    breakSack?: NullableIntFieldUpdateOperationsInput | number | null
    fieldVision?: NullableIntFieldUpdateOperationsInput | number | null
    ballSecurity?: NullableIntFieldUpdateOperationsInput | number | null
    ballCarrierVision?: NullableIntFieldUpdateOperationsInput | number | null
    breakTackle?: NullableIntFieldUpdateOperationsInput | number | null
    topBallCarrierSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    trucking?: NullableIntFieldUpdateOperationsInput | number | null
    elusiveness?: NullableIntFieldUpdateOperationsInput | number | null
    stiffArm?: NullableIntFieldUpdateOperationsInput | number | null
    spinMove?: NullableIntFieldUpdateOperationsInput | number | null
    jukeMove?: NullableIntFieldUpdateOperationsInput | number | null
    shortYardage?: NullableIntFieldUpdateOperationsInput | number | null
    goalLine?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldRunning?: NullableIntFieldUpdateOperationsInput | number | null
    catching?: NullableIntFieldUpdateOperationsInput | number | null
    catchInTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    spectacularCatch?: NullableIntFieldUpdateOperationsInput | number | null
    contestedCatches?: NullableIntFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    jumpBallTiming?: NullableIntFieldUpdateOperationsInput | number | null
    routeRunning?: NullableIntFieldUpdateOperationsInput | number | null
    shortRoute?: NullableIntFieldUpdateOperationsInput | number | null
    mediumRoute?: NullableIntFieldUpdateOperationsInput | number | null
    deepRoute?: NullableIntFieldUpdateOperationsInput | number | null
    separation?: NullableIntFieldUpdateOperationsInput | number | null
    release?: NullableIntFieldUpdateOperationsInput | number | null
    runBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    passBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    pullBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambleBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    playActionBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    screenBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    leadBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    tackling?: NullableIntFieldUpdateOperationsInput | number | null
    blockShedding?: NullableIntFieldUpdateOperationsInput | number | null
    blitzing?: NullableIntFieldUpdateOperationsInput | number | null
    playRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldTackling?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstTEsRBs?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstSlot?: NullableIntFieldUpdateOperationsInput | number | null
    deepCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    runDefense?: NullableIntFieldUpdateOperationsInput | number | null
    passRush?: NullableIntFieldUpdateOperationsInput | number | null
    finessePassRush?: NullableIntFieldUpdateOperationsInput | number | null
    powerPassRush?: NullableIntFieldUpdateOperationsInput | number | null
    runStopping?: NullableIntFieldUpdateOperationsInput | number | null
    penetration?: NullableIntFieldUpdateOperationsInput | number | null
    edgeSetting?: NullableIntFieldUpdateOperationsInput | number | null
    disengagement?: NullableIntFieldUpdateOperationsInput | number | null
    offensiveLineRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    hitPower?: NullableIntFieldUpdateOperationsInput | number | null
    pressCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    offBallCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    manCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    zoneCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    ballHawking?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    passDeflection?: NullableIntFieldUpdateOperationsInput | number | null
    kickPower?: NullableIntFieldUpdateOperationsInput | number | null
    kickAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    puntPower?: NullableIntFieldUpdateOperationsInput | number | null
    puntAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    onsideKickAbility?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableIntFieldUpdateOperationsInput | number | null
    agility?: NullableIntFieldUpdateOperationsInput | number | null
    changeOfDirection?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: NullableIntFieldUpdateOperationsInput | number | null
    impactPower?: NullableIntFieldUpdateOperationsInput | number | null
    verticalJump?: NullableIntFieldUpdateOperationsInput | number | null
    stamina?: NullableIntFieldUpdateOperationsInput | number | null
    toughness?: NullableIntFieldUpdateOperationsInput | number | null
    awareness?: NullableIntFieldUpdateOperationsInput | number | null
    discipline?: NullableIntFieldUpdateOperationsInput | number | null
    injuryRecovery?: NullableIntFieldUpdateOperationsInput | number | null
    throwPower?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyShort?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyMedium?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyDeep?: NullableIntFieldUpdateOperationsInput | number | null
    throwOnRun?: NullableIntFieldUpdateOperationsInput | number | null
    playAction?: NullableIntFieldUpdateOperationsInput | number | null
    pocketPresence?: NullableIntFieldUpdateOperationsInput | number | null
    releaseTime?: NullableIntFieldUpdateOperationsInput | number | null
    decisionMaking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambling?: NullableIntFieldUpdateOperationsInput | number | null
    breakSack?: NullableIntFieldUpdateOperationsInput | number | null
    fieldVision?: NullableIntFieldUpdateOperationsInput | number | null
    ballSecurity?: NullableIntFieldUpdateOperationsInput | number | null
    ballCarrierVision?: NullableIntFieldUpdateOperationsInput | number | null
    breakTackle?: NullableIntFieldUpdateOperationsInput | number | null
    topBallCarrierSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    trucking?: NullableIntFieldUpdateOperationsInput | number | null
    elusiveness?: NullableIntFieldUpdateOperationsInput | number | null
    stiffArm?: NullableIntFieldUpdateOperationsInput | number | null
    spinMove?: NullableIntFieldUpdateOperationsInput | number | null
    jukeMove?: NullableIntFieldUpdateOperationsInput | number | null
    shortYardage?: NullableIntFieldUpdateOperationsInput | number | null
    goalLine?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldRunning?: NullableIntFieldUpdateOperationsInput | number | null
    catching?: NullableIntFieldUpdateOperationsInput | number | null
    catchInTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    spectacularCatch?: NullableIntFieldUpdateOperationsInput | number | null
    contestedCatches?: NullableIntFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    jumpBallTiming?: NullableIntFieldUpdateOperationsInput | number | null
    routeRunning?: NullableIntFieldUpdateOperationsInput | number | null
    shortRoute?: NullableIntFieldUpdateOperationsInput | number | null
    mediumRoute?: NullableIntFieldUpdateOperationsInput | number | null
    deepRoute?: NullableIntFieldUpdateOperationsInput | number | null
    separation?: NullableIntFieldUpdateOperationsInput | number | null
    release?: NullableIntFieldUpdateOperationsInput | number | null
    runBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    passBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    pullBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambleBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    playActionBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    screenBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    leadBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    tackling?: NullableIntFieldUpdateOperationsInput | number | null
    blockShedding?: NullableIntFieldUpdateOperationsInput | number | null
    blitzing?: NullableIntFieldUpdateOperationsInput | number | null
    playRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldTackling?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstTEsRBs?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstSlot?: NullableIntFieldUpdateOperationsInput | number | null
    deepCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    runDefense?: NullableIntFieldUpdateOperationsInput | number | null
    passRush?: NullableIntFieldUpdateOperationsInput | number | null
    finessePassRush?: NullableIntFieldUpdateOperationsInput | number | null
    powerPassRush?: NullableIntFieldUpdateOperationsInput | number | null
    runStopping?: NullableIntFieldUpdateOperationsInput | number | null
    penetration?: NullableIntFieldUpdateOperationsInput | number | null
    edgeSetting?: NullableIntFieldUpdateOperationsInput | number | null
    disengagement?: NullableIntFieldUpdateOperationsInput | number | null
    offensiveLineRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    hitPower?: NullableIntFieldUpdateOperationsInput | number | null
    pressCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    offBallCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    manCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    zoneCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    ballHawking?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    passDeflection?: NullableIntFieldUpdateOperationsInput | number | null
    kickPower?: NullableIntFieldUpdateOperationsInput | number | null
    kickAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    puntPower?: NullableIntFieldUpdateOperationsInput | number | null
    puntAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    onsideKickAbility?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatCreateInput = {
    id?: string
    season?: number | null
    playerId?: string | null
    gamesPlayed?: number | null
    gamesStarted?: number | null
    snaps?: number | null
    rushingAttempts?: number | null
    rushingYards?: number | null
    yardsPerCarry?: number | null
    yardsAfterContact?: number | null
    yardsPerGame?: number | null
    rushingLong?: number | null
    rushingTouchdowns?: number | null
    fumblesLost?: number | null
    receptions?: number | null
    receivingYards?: number | null
    yardsPerReception?: number | null
    yardsAfterCatch?: number | null
    yardsPerTarget?: number | null
    airYards?: number | null
    receivingLong?: number | null
    targets?: number | null
    receivingTouchdowns?: number | null
    drops?: number | null
    passingAttempts?: number | null
    passingCompletions?: number | null
    passingYards?: number | null
    yardsPerPass?: number | null
    yardsPerCompletion?: number | null
    completionPercentage?: number | null
    passingTouchdowns?: number | null
    interceptions?: number | null
    sacksTaken?: number | null
    passerRating?: number | null
    pancakes?: number | null
    sacksAllowed?: number | null
    hurriesAllowed?: number | null
    tackles?: number | null
    tacklesForLoss?: number | null
    sacks?: number | null
    interceptionsMade?: number | null
    forcedFumbles?: number | null
    fumbleRecoveries?: number | null
    passesDefended?: number | null
    defensiveTouchdowns?: number | null
    fieldGoalsMade?: number | null
    fieldGoalsAttempted?: number | null
    extraPointsMade?: number | null
    extraPointsAttempted?: number | null
    punts?: number | null
    puntYards?: number | null
    kickReturns?: number | null
    kickReturnYards?: number | null
    puntReturns?: number | null
    puntReturnYards?: number | null
    specialTeamsTouchdowns?: number | null
    penaltiesCommitted?: number | null
    penaltyYards?: number | null
    player?: PlayerCreateNestedOneWithoutStatsInput
  }

  export type StatUncheckedCreateInput = {
    id?: string
    season?: number | null
    playerId?: string | null
    gamesPlayed?: number | null
    gamesStarted?: number | null
    snaps?: number | null
    rushingAttempts?: number | null
    rushingYards?: number | null
    yardsPerCarry?: number | null
    yardsAfterContact?: number | null
    yardsPerGame?: number | null
    rushingLong?: number | null
    rushingTouchdowns?: number | null
    fumblesLost?: number | null
    receptions?: number | null
    receivingYards?: number | null
    yardsPerReception?: number | null
    yardsAfterCatch?: number | null
    yardsPerTarget?: number | null
    airYards?: number | null
    receivingLong?: number | null
    targets?: number | null
    receivingTouchdowns?: number | null
    drops?: number | null
    passingAttempts?: number | null
    passingCompletions?: number | null
    passingYards?: number | null
    yardsPerPass?: number | null
    yardsPerCompletion?: number | null
    completionPercentage?: number | null
    passingTouchdowns?: number | null
    interceptions?: number | null
    sacksTaken?: number | null
    passerRating?: number | null
    pancakes?: number | null
    sacksAllowed?: number | null
    hurriesAllowed?: number | null
    tackles?: number | null
    tacklesForLoss?: number | null
    sacks?: number | null
    interceptionsMade?: number | null
    forcedFumbles?: number | null
    fumbleRecoveries?: number | null
    passesDefended?: number | null
    defensiveTouchdowns?: number | null
    fieldGoalsMade?: number | null
    fieldGoalsAttempted?: number | null
    extraPointsMade?: number | null
    extraPointsAttempted?: number | null
    punts?: number | null
    puntYards?: number | null
    kickReturns?: number | null
    kickReturnYards?: number | null
    puntReturns?: number | null
    puntReturnYards?: number | null
    specialTeamsTouchdowns?: number | null
    penaltiesCommitted?: number | null
    penaltyYards?: number | null
    player?: PlayerUncheckedCreateNestedOneWithoutStatsInput
  }

  export type StatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: NullableIntFieldUpdateOperationsInput | number | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    gamesStarted?: NullableIntFieldUpdateOperationsInput | number | null
    snaps?: NullableIntFieldUpdateOperationsInput | number | null
    rushingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    rushingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerCarry?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterContact?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerGame?: NullableFloatFieldUpdateOperationsInput | number | null
    rushingLong?: NullableIntFieldUpdateOperationsInput | number | null
    rushingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fumblesLost?: NullableIntFieldUpdateOperationsInput | number | null
    receptions?: NullableIntFieldUpdateOperationsInput | number | null
    receivingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerReception?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    airYards?: NullableIntFieldUpdateOperationsInput | number | null
    receivingLong?: NullableIntFieldUpdateOperationsInput | number | null
    targets?: NullableIntFieldUpdateOperationsInput | number | null
    receivingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    drops?: NullableIntFieldUpdateOperationsInput | number | null
    passingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    passingCompletions?: NullableIntFieldUpdateOperationsInput | number | null
    passingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerPass?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsPerCompletion?: NullableFloatFieldUpdateOperationsInput | number | null
    completionPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    sacksTaken?: NullableIntFieldUpdateOperationsInput | number | null
    passerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    pancakes?: NullableIntFieldUpdateOperationsInput | number | null
    sacksAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    hurriesAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    tackles?: NullableIntFieldUpdateOperationsInput | number | null
    tacklesForLoss?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptionsMade?: NullableIntFieldUpdateOperationsInput | number | null
    forcedFumbles?: NullableIntFieldUpdateOperationsInput | number | null
    fumbleRecoveries?: NullableIntFieldUpdateOperationsInput | number | null
    passesDefended?: NullableIntFieldUpdateOperationsInput | number | null
    defensiveTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsMade?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsMade?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    punts?: NullableIntFieldUpdateOperationsInput | number | null
    puntYards?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturns?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturns?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    specialTeamsTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    penaltiesCommitted?: NullableIntFieldUpdateOperationsInput | number | null
    penaltyYards?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUpdateOneWithoutStatsNestedInput
  }

  export type StatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: NullableIntFieldUpdateOperationsInput | number | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    gamesStarted?: NullableIntFieldUpdateOperationsInput | number | null
    snaps?: NullableIntFieldUpdateOperationsInput | number | null
    rushingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    rushingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerCarry?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterContact?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerGame?: NullableFloatFieldUpdateOperationsInput | number | null
    rushingLong?: NullableIntFieldUpdateOperationsInput | number | null
    rushingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fumblesLost?: NullableIntFieldUpdateOperationsInput | number | null
    receptions?: NullableIntFieldUpdateOperationsInput | number | null
    receivingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerReception?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    airYards?: NullableIntFieldUpdateOperationsInput | number | null
    receivingLong?: NullableIntFieldUpdateOperationsInput | number | null
    targets?: NullableIntFieldUpdateOperationsInput | number | null
    receivingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    drops?: NullableIntFieldUpdateOperationsInput | number | null
    passingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    passingCompletions?: NullableIntFieldUpdateOperationsInput | number | null
    passingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerPass?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsPerCompletion?: NullableFloatFieldUpdateOperationsInput | number | null
    completionPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    sacksTaken?: NullableIntFieldUpdateOperationsInput | number | null
    passerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    pancakes?: NullableIntFieldUpdateOperationsInput | number | null
    sacksAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    hurriesAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    tackles?: NullableIntFieldUpdateOperationsInput | number | null
    tacklesForLoss?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptionsMade?: NullableIntFieldUpdateOperationsInput | number | null
    forcedFumbles?: NullableIntFieldUpdateOperationsInput | number | null
    fumbleRecoveries?: NullableIntFieldUpdateOperationsInput | number | null
    passesDefended?: NullableIntFieldUpdateOperationsInput | number | null
    defensiveTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsMade?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsMade?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    punts?: NullableIntFieldUpdateOperationsInput | number | null
    puntYards?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturns?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturns?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    specialTeamsTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    penaltiesCommitted?: NullableIntFieldUpdateOperationsInput | number | null
    penaltyYards?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUncheckedUpdateOneWithoutStatsNestedInput
  }

  export type StatCreateManyInput = {
    id?: string
    season?: number | null
    playerId?: string | null
    gamesPlayed?: number | null
    gamesStarted?: number | null
    snaps?: number | null
    rushingAttempts?: number | null
    rushingYards?: number | null
    yardsPerCarry?: number | null
    yardsAfterContact?: number | null
    yardsPerGame?: number | null
    rushingLong?: number | null
    rushingTouchdowns?: number | null
    fumblesLost?: number | null
    receptions?: number | null
    receivingYards?: number | null
    yardsPerReception?: number | null
    yardsAfterCatch?: number | null
    yardsPerTarget?: number | null
    airYards?: number | null
    receivingLong?: number | null
    targets?: number | null
    receivingTouchdowns?: number | null
    drops?: number | null
    passingAttempts?: number | null
    passingCompletions?: number | null
    passingYards?: number | null
    yardsPerPass?: number | null
    yardsPerCompletion?: number | null
    completionPercentage?: number | null
    passingTouchdowns?: number | null
    interceptions?: number | null
    sacksTaken?: number | null
    passerRating?: number | null
    pancakes?: number | null
    sacksAllowed?: number | null
    hurriesAllowed?: number | null
    tackles?: number | null
    tacklesForLoss?: number | null
    sacks?: number | null
    interceptionsMade?: number | null
    forcedFumbles?: number | null
    fumbleRecoveries?: number | null
    passesDefended?: number | null
    defensiveTouchdowns?: number | null
    fieldGoalsMade?: number | null
    fieldGoalsAttempted?: number | null
    extraPointsMade?: number | null
    extraPointsAttempted?: number | null
    punts?: number | null
    puntYards?: number | null
    kickReturns?: number | null
    kickReturnYards?: number | null
    puntReturns?: number | null
    puntReturnYards?: number | null
    specialTeamsTouchdowns?: number | null
    penaltiesCommitted?: number | null
    penaltyYards?: number | null
  }

  export type StatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: NullableIntFieldUpdateOperationsInput | number | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    gamesStarted?: NullableIntFieldUpdateOperationsInput | number | null
    snaps?: NullableIntFieldUpdateOperationsInput | number | null
    rushingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    rushingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerCarry?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterContact?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerGame?: NullableFloatFieldUpdateOperationsInput | number | null
    rushingLong?: NullableIntFieldUpdateOperationsInput | number | null
    rushingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fumblesLost?: NullableIntFieldUpdateOperationsInput | number | null
    receptions?: NullableIntFieldUpdateOperationsInput | number | null
    receivingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerReception?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    airYards?: NullableIntFieldUpdateOperationsInput | number | null
    receivingLong?: NullableIntFieldUpdateOperationsInput | number | null
    targets?: NullableIntFieldUpdateOperationsInput | number | null
    receivingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    drops?: NullableIntFieldUpdateOperationsInput | number | null
    passingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    passingCompletions?: NullableIntFieldUpdateOperationsInput | number | null
    passingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerPass?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsPerCompletion?: NullableFloatFieldUpdateOperationsInput | number | null
    completionPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    sacksTaken?: NullableIntFieldUpdateOperationsInput | number | null
    passerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    pancakes?: NullableIntFieldUpdateOperationsInput | number | null
    sacksAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    hurriesAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    tackles?: NullableIntFieldUpdateOperationsInput | number | null
    tacklesForLoss?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptionsMade?: NullableIntFieldUpdateOperationsInput | number | null
    forcedFumbles?: NullableIntFieldUpdateOperationsInput | number | null
    fumbleRecoveries?: NullableIntFieldUpdateOperationsInput | number | null
    passesDefended?: NullableIntFieldUpdateOperationsInput | number | null
    defensiveTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsMade?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsMade?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    punts?: NullableIntFieldUpdateOperationsInput | number | null
    puntYards?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturns?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturns?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    specialTeamsTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    penaltiesCommitted?: NullableIntFieldUpdateOperationsInput | number | null
    penaltyYards?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: NullableIntFieldUpdateOperationsInput | number | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    gamesStarted?: NullableIntFieldUpdateOperationsInput | number | null
    snaps?: NullableIntFieldUpdateOperationsInput | number | null
    rushingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    rushingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerCarry?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterContact?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerGame?: NullableFloatFieldUpdateOperationsInput | number | null
    rushingLong?: NullableIntFieldUpdateOperationsInput | number | null
    rushingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fumblesLost?: NullableIntFieldUpdateOperationsInput | number | null
    receptions?: NullableIntFieldUpdateOperationsInput | number | null
    receivingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerReception?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    airYards?: NullableIntFieldUpdateOperationsInput | number | null
    receivingLong?: NullableIntFieldUpdateOperationsInput | number | null
    targets?: NullableIntFieldUpdateOperationsInput | number | null
    receivingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    drops?: NullableIntFieldUpdateOperationsInput | number | null
    passingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    passingCompletions?: NullableIntFieldUpdateOperationsInput | number | null
    passingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerPass?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsPerCompletion?: NullableFloatFieldUpdateOperationsInput | number | null
    completionPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    sacksTaken?: NullableIntFieldUpdateOperationsInput | number | null
    passerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    pancakes?: NullableIntFieldUpdateOperationsInput | number | null
    sacksAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    hurriesAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    tackles?: NullableIntFieldUpdateOperationsInput | number | null
    tacklesForLoss?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptionsMade?: NullableIntFieldUpdateOperationsInput | number | null
    forcedFumbles?: NullableIntFieldUpdateOperationsInput | number | null
    fumbleRecoveries?: NullableIntFieldUpdateOperationsInput | number | null
    passesDefended?: NullableIntFieldUpdateOperationsInput | number | null
    defensiveTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsMade?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsMade?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    punts?: NullableIntFieldUpdateOperationsInput | number | null
    puntYards?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturns?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturns?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    specialTeamsTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    penaltiesCommitted?: NullableIntFieldUpdateOperationsInput | number | null
    penaltyYards?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractDesiresCreateInput = {
    id?: string
    years?: number | null
    averageSalary?: number | null
    totalGuaranteed?: number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresCreateoptOutYearsInput | number[]
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    playerId?: string | null
    player?: PlayerCreateNestedManyWithoutContractDesiresInput
  }

  export type ContractDesiresUncheckedCreateInput = {
    id?: string
    years?: number | null
    averageSalary?: number | null
    totalGuaranteed?: number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresCreateoptOutYearsInput | number[]
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    playerId?: string | null
    player?: PlayerUncheckedCreateNestedManyWithoutContractDesiresInput
  }

  export type ContractDesiresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    years?: NullableIntFieldUpdateOperationsInput | number | null
    averageSalary?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresUpdateoptOutYearsInput | number[]
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    player?: PlayerUpdateManyWithoutContractDesiresNestedInput
  }

  export type ContractDesiresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    years?: NullableIntFieldUpdateOperationsInput | number | null
    averageSalary?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresUpdateoptOutYearsInput | number[]
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    player?: PlayerUncheckedUpdateManyWithoutContractDesiresNestedInput
  }

  export type ContractDesiresCreateManyInput = {
    id?: string
    years?: number | null
    averageSalary?: number | null
    totalGuaranteed?: number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresCreateoptOutYearsInput | number[]
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    playerId?: string | null
  }

  export type ContractDesiresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    years?: NullableIntFieldUpdateOperationsInput | number | null
    averageSalary?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresUpdateoptOutYearsInput | number[]
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractDesiresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    years?: NullableIntFieldUpdateOperationsInput | number | null
    averageSalary?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresUpdateoptOutYearsInput | number[]
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPlayerPositionEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerPositionEnum | EnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel> | $Enums.PlayerPositionEnum | null
  }

  export type EnumPlayerRoleEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRoleEnum | EnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel> | $Enums.PlayerRoleEnum | null
  }

  export type EnumFootballRecordEnumNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.FootballRecordEnum[] | ListEnumFootballRecordEnumFieldRefInput<$PrismaModel> | null
    has?: $Enums.FootballRecordEnum | EnumFootballRecordEnumFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.FootballRecordEnum[] | ListEnumFootballRecordEnumFieldRefInput<$PrismaModel>
    hasSome?: $Enums.FootballRecordEnum[] | ListEnumFootballRecordEnumFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumInjuryTypeEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryTypeEnum | EnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel> | $Enums.InjuryTypeEnum | null
  }

  export type EnumInjuryTypeEnumNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    has?: $Enums.InjuryTypeEnum | EnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel>
    hasSome?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPlayerPersonalityTraitEnumNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerPersonalityTraitEnum[] | ListEnumPlayerPersonalityTraitEnumFieldRefInput<$PrismaModel> | null
    has?: $Enums.PlayerPersonalityTraitEnum | EnumPlayerPersonalityTraitEnumFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.PlayerPersonalityTraitEnum[] | ListEnumPlayerPersonalityTraitEnumFieldRefInput<$PrismaModel>
    hasSome?: $Enums.PlayerPersonalityTraitEnum[] | ListEnumPlayerPersonalityTraitEnumFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumOffFieldConcernTypeEnumNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.OffFieldConcernTypeEnum[] | ListEnumOffFieldConcernTypeEnumFieldRefInput<$PrismaModel> | null
    has?: $Enums.OffFieldConcernTypeEnum | EnumOffFieldConcernTypeEnumFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.OffFieldConcernTypeEnum[] | ListEnumOffFieldConcernTypeEnumFieldRefInput<$PrismaModel>
    hasSome?: $Enums.OffFieldConcernTypeEnum[] | ListEnumOffFieldConcernTypeEnumFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPlayerEventEnumNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerEventEnum[] | ListEnumPlayerEventEnumFieldRefInput<$PrismaModel> | null
    has?: $Enums.PlayerEventEnum | EnumPlayerEventEnumFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.PlayerEventEnum[] | ListEnumPlayerEventEnumFieldRefInput<$PrismaModel>
    hasSome?: $Enums.PlayerEventEnum[] | ListEnumPlayerEventEnumFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumContractNegotiationStatusEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractNegotiationStatusEnum | EnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel> | $Enums.ContractNegotiationStatusEnum | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type PlayerContractNullableScalarRelationFilter = {
    is?: PlayerContractWhereInput | null
    isNot?: PlayerContractWhereInput | null
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type RatingNullableScalarRelationFilter = {
    is?: RatingWhereInput | null
    isNot?: RatingWhereInput | null
  }

  export type StatNullableScalarRelationFilter = {
    is?: StatWhereInput | null
    isNot?: StatWhereInput | null
  }

  export type ContractDesiresNullableScalarRelationFilter = {
    is?: ContractDesiresWhereInput | null
    isNot?: ContractDesiresWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    college?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    teamId?: SortOrder
    practiceSquadTeamId?: SortOrder
    injuredReserveTeamId?: SortOrder
    suspendedListTeamId?: SortOrder
    currentContractId?: SortOrder
    agentId?: SortOrder
    ratingsId?: SortOrder
    statsId?: SortOrder
    position?: SortOrder
    expectedRole?: SortOrder
    actualRole?: SortOrder
    recordsHeld?: SortOrder
    currentInjury?: SortOrder
    injuryHistory?: SortOrder
    personalityTraits?: SortOrder
    offFieldConcerns?: SortOrder
    pastEvents?: SortOrder
    isStarter?: SortOrder
    isCaptain?: SortOrder
    isFreeAgent?: SortOrder
    isRetired?: SortOrder
    isSuspended?: SortOrder
    isPracticeSquad?: SortOrder
    isTradeBlock?: SortOrder
    offense?: SortOrder
    defense?: SortOrder
    specialTeams?: SortOrder
    draftYear?: SortOrder
    draftRound?: SortOrder
    isRecordHolder?: SortOrder
    contractDesiresId?: SortOrder
    contractNegotiationStatus?: SortOrder
    lastContractUpdate?: SortOrder
    performanceRating?: SortOrder
    impactRating?: SortOrder
    potential?: SortOrder
    experience?: SortOrder
    isInjured?: SortOrder
    injuryProneness?: SortOrder
    expectedReturnFromInjury?: SortOrder
    morale?: SortOrder
    leadership?: SortOrder
    adaptability?: SortOrder
    workEthic?: SortOrder
    consistency?: SortOrder
    clutchFactor?: SortOrder
    footballIQ?: SortOrder
    popularity?: SortOrder
    trainingFocus?: SortOrder
    trainingProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    age?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    draftYear?: SortOrder
    draftRound?: SortOrder
    performanceRating?: SortOrder
    impactRating?: SortOrder
    potential?: SortOrder
    experience?: SortOrder
    morale?: SortOrder
    leadership?: SortOrder
    adaptability?: SortOrder
    workEthic?: SortOrder
    consistency?: SortOrder
    clutchFactor?: SortOrder
    footballIQ?: SortOrder
    popularity?: SortOrder
    trainingProgress?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    college?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    teamId?: SortOrder
    practiceSquadTeamId?: SortOrder
    injuredReserveTeamId?: SortOrder
    suspendedListTeamId?: SortOrder
    currentContractId?: SortOrder
    agentId?: SortOrder
    ratingsId?: SortOrder
    statsId?: SortOrder
    position?: SortOrder
    expectedRole?: SortOrder
    actualRole?: SortOrder
    currentInjury?: SortOrder
    isStarter?: SortOrder
    isCaptain?: SortOrder
    isFreeAgent?: SortOrder
    isRetired?: SortOrder
    isSuspended?: SortOrder
    isPracticeSquad?: SortOrder
    isTradeBlock?: SortOrder
    offense?: SortOrder
    defense?: SortOrder
    specialTeams?: SortOrder
    draftYear?: SortOrder
    draftRound?: SortOrder
    isRecordHolder?: SortOrder
    contractDesiresId?: SortOrder
    contractNegotiationStatus?: SortOrder
    lastContractUpdate?: SortOrder
    performanceRating?: SortOrder
    impactRating?: SortOrder
    potential?: SortOrder
    experience?: SortOrder
    isInjured?: SortOrder
    injuryProneness?: SortOrder
    expectedReturnFromInjury?: SortOrder
    morale?: SortOrder
    leadership?: SortOrder
    adaptability?: SortOrder
    workEthic?: SortOrder
    consistency?: SortOrder
    clutchFactor?: SortOrder
    footballIQ?: SortOrder
    popularity?: SortOrder
    trainingFocus?: SortOrder
    trainingProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    college?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    teamId?: SortOrder
    practiceSquadTeamId?: SortOrder
    injuredReserveTeamId?: SortOrder
    suspendedListTeamId?: SortOrder
    currentContractId?: SortOrder
    agentId?: SortOrder
    ratingsId?: SortOrder
    statsId?: SortOrder
    position?: SortOrder
    expectedRole?: SortOrder
    actualRole?: SortOrder
    currentInjury?: SortOrder
    isStarter?: SortOrder
    isCaptain?: SortOrder
    isFreeAgent?: SortOrder
    isRetired?: SortOrder
    isSuspended?: SortOrder
    isPracticeSquad?: SortOrder
    isTradeBlock?: SortOrder
    offense?: SortOrder
    defense?: SortOrder
    specialTeams?: SortOrder
    draftYear?: SortOrder
    draftRound?: SortOrder
    isRecordHolder?: SortOrder
    contractDesiresId?: SortOrder
    contractNegotiationStatus?: SortOrder
    lastContractUpdate?: SortOrder
    performanceRating?: SortOrder
    impactRating?: SortOrder
    potential?: SortOrder
    experience?: SortOrder
    isInjured?: SortOrder
    injuryProneness?: SortOrder
    expectedReturnFromInjury?: SortOrder
    morale?: SortOrder
    leadership?: SortOrder
    adaptability?: SortOrder
    workEthic?: SortOrder
    consistency?: SortOrder
    clutchFactor?: SortOrder
    footballIQ?: SortOrder
    popularity?: SortOrder
    trainingFocus?: SortOrder
    trainingProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    age?: SortOrder
    heightInInches?: SortOrder
    weightInPounds?: SortOrder
    draftYear?: SortOrder
    draftRound?: SortOrder
    performanceRating?: SortOrder
    impactRating?: SortOrder
    potential?: SortOrder
    experience?: SortOrder
    morale?: SortOrder
    leadership?: SortOrder
    adaptability?: SortOrder
    workEthic?: SortOrder
    consistency?: SortOrder
    clutchFactor?: SortOrder
    footballIQ?: SortOrder
    popularity?: SortOrder
    trainingProgress?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPlayerPositionEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerPositionEnum | EnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerPositionEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.PlayerPositionEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel>
  }

  export type EnumPlayerRoleEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRoleEnum | EnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerRoleEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.PlayerRoleEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel>
  }

  export type EnumInjuryTypeEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryTypeEnum | EnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInjuryTypeEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.InjuryTypeEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumContractNegotiationStatusEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractNegotiationStatusEnum | EnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractNegotiationStatusEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractNegotiationStatusEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDivisionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DivisionEnum | EnumDivisionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDivisionEnumFilter<$PrismaModel> | $Enums.DivisionEnum
  }

  export type EnumConferenceEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceEnum | EnumConferenceEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceEnumFilter<$PrismaModel> | $Enums.ConferenceEnum
  }

  export type EnumOffensiveSchemeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.OffensiveSchemeEnum | EnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumOffensiveSchemeEnumFilter<$PrismaModel> | $Enums.OffensiveSchemeEnum
  }

  export type EnumDefensiveSchemeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DefensiveSchemeEnum | EnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefensiveSchemeEnumFilter<$PrismaModel> | $Enums.DefensiveSchemeEnum
  }

  export type EnumPlayerPositionEnumNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    has?: $Enums.PlayerPositionEnum | EnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel>
    hasSome?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFinancialHealthEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialHealthEnum | EnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialHealthEnumFilter<$PrismaModel> | $Enums.FinancialHealthEnum
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type PlayerContractListRelationFilter = {
    every?: PlayerContractWhereInput
    some?: PlayerContractWhereInput
    none?: PlayerContractWhereInput
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    location?: SortOrder
    abbreviation?: SortOrder
    logoUrl?: SortOrder
    division?: SortOrder
    conference?: SortOrder
    overallRating?: SortOrder
    offensiveScheme?: SortOrder
    defensiveScheme?: SortOrder
    teamNeeds?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    financialHealth?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    retiredNumbers?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
    rivalTeams?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    overallRating?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    retiredNumbers?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    location?: SortOrder
    abbreviation?: SortOrder
    logoUrl?: SortOrder
    division?: SortOrder
    conference?: SortOrder
    overallRating?: SortOrder
    offensiveScheme?: SortOrder
    defensiveScheme?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    financialHealth?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    location?: SortOrder
    abbreviation?: SortOrder
    logoUrl?: SortOrder
    division?: SortOrder
    conference?: SortOrder
    overallRating?: SortOrder
    offensiveScheme?: SortOrder
    defensiveScheme?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    financialHealth?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    overallRating?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    currentStreak?: SortOrder
    longestWinningStreak?: SortOrder
    playoffAppearances?: SortOrder
    superBowlAppearances?: SortOrder
    championships?: SortOrder
    capSpace?: SortOrder
    capLimit?: SortOrder
    totalPayroll?: SortOrder
    yearFounded?: SortOrder
    allTimeWins?: SortOrder
    allTimeLosses?: SortOrder
    allTimeTies?: SortOrder
    retiredNumbers?: SortOrder
    fanBaseSize?: SortOrder
    prestige?: SortOrder
  }

  export type EnumDivisionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DivisionEnum | EnumDivisionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDivisionEnumWithAggregatesFilter<$PrismaModel> | $Enums.DivisionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDivisionEnumFilter<$PrismaModel>
    _max?: NestedEnumDivisionEnumFilter<$PrismaModel>
  }

  export type EnumConferenceEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceEnum | EnumConferenceEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceEnumWithAggregatesFilter<$PrismaModel> | $Enums.ConferenceEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConferenceEnumFilter<$PrismaModel>
    _max?: NestedEnumConferenceEnumFilter<$PrismaModel>
  }

  export type EnumOffensiveSchemeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OffensiveSchemeEnum | EnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumOffensiveSchemeEnumWithAggregatesFilter<$PrismaModel> | $Enums.OffensiveSchemeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOffensiveSchemeEnumFilter<$PrismaModel>
    _max?: NestedEnumOffensiveSchemeEnumFilter<$PrismaModel>
  }

  export type EnumDefensiveSchemeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefensiveSchemeEnum | EnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefensiveSchemeEnumWithAggregatesFilter<$PrismaModel> | $Enums.DefensiveSchemeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefensiveSchemeEnumFilter<$PrismaModel>
    _max?: NestedEnumDefensiveSchemeEnumFilter<$PrismaModel>
  }

  export type EnumFinancialHealthEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialHealthEnum | EnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialHealthEnumWithAggregatesFilter<$PrismaModel> | $Enums.FinancialHealthEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialHealthEnumFilter<$PrismaModel>
    _max?: NestedEnumFinancialHealthEnumFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PlayerNullableScalarRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type ContractBonusListRelationFilter = {
    every?: ContractBonusWhereInput
    some?: ContractBonusWhereInput
    none?: ContractBonusWhereInput
  }

  export type SalaryByYearListRelationFilter = {
    every?: SalaryByYearWhereInput
    some?: SalaryByYearWhereInput
    none?: SalaryByYearWhereInput
  }

  export type CapHitByYearListRelationFilter = {
    every?: CapHitByYearWhereInput
    some?: CapHitByYearWhereInput
    none?: CapHitByYearWhereInput
  }

  export type DeadCapByYearListRelationFilter = {
    every?: DeadCapByYearWhereInput
    some?: DeadCapByYearWhereInput
    none?: DeadCapByYearWhereInput
  }

  export type OptOutYearListRelationFilter = {
    every?: OptOutYearWhereInput
    some?: OptOutYearWhereInput
    none?: OptOutYearWhereInput
  }

  export type RestructureEventListRelationFilter = {
    every?: RestructureEventWhereInput
    some?: RestructureEventWhereInput
    none?: RestructureEventWhereInput
  }

  export type ContractClauseListRelationFilter = {
    every?: ContractClauseWhereInput
    some?: ContractClauseWhereInput
    none?: ContractClauseWhereInput
  }

  export type ContractBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryByYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CapHitByYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeadCapByYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptOutYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestructureEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractClauseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerContractCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    signedDate?: SortOrder
    startSeason?: SortOrder
    endSeason?: SortOrder
    totalValue?: SortOrder
    averagePerYear?: SortOrder
    totalGuaranteed?: SortOrder
    isRookieContract?: SortOrder
    isFranchiseTag?: SortOrder
    isExtension?: SortOrder
    isPlayerOptOut?: SortOrder
    isTeamOptOut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerContractAvgOrderByAggregateInput = {
    startSeason?: SortOrder
    endSeason?: SortOrder
    totalValue?: SortOrder
    averagePerYear?: SortOrder
    totalGuaranteed?: SortOrder
  }

  export type PlayerContractMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    signedDate?: SortOrder
    startSeason?: SortOrder
    endSeason?: SortOrder
    totalValue?: SortOrder
    averagePerYear?: SortOrder
    totalGuaranteed?: SortOrder
    isRookieContract?: SortOrder
    isFranchiseTag?: SortOrder
    isExtension?: SortOrder
    isPlayerOptOut?: SortOrder
    isTeamOptOut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerContractMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    signedDate?: SortOrder
    startSeason?: SortOrder
    endSeason?: SortOrder
    totalValue?: SortOrder
    averagePerYear?: SortOrder
    totalGuaranteed?: SortOrder
    isRookieContract?: SortOrder
    isFranchiseTag?: SortOrder
    isExtension?: SortOrder
    isPlayerOptOut?: SortOrder
    isTeamOptOut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerContractSumOrderByAggregateInput = {
    startSeason?: SortOrder
    endSeason?: SortOrder
    totalValue?: SortOrder
    averagePerYear?: SortOrder
    totalGuaranteed?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PlayerContractScalarRelationFilter = {
    is?: PlayerContractWhereInput
    isNot?: PlayerContractWhereInput
  }

  export type ContractBonusCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    signingBonus?: SortOrder
    rosterBonus?: SortOrder
    workoutBonus?: SortOrder
    incentiveBonus?: SortOrder
  }

  export type ContractBonusAvgOrderByAggregateInput = {
    year?: SortOrder
    signingBonus?: SortOrder
    rosterBonus?: SortOrder
    workoutBonus?: SortOrder
    incentiveBonus?: SortOrder
  }

  export type ContractBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    signingBonus?: SortOrder
    rosterBonus?: SortOrder
    workoutBonus?: SortOrder
    incentiveBonus?: SortOrder
  }

  export type ContractBonusMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    signingBonus?: SortOrder
    rosterBonus?: SortOrder
    workoutBonus?: SortOrder
    incentiveBonus?: SortOrder
  }

  export type ContractBonusSumOrderByAggregateInput = {
    year?: SortOrder
    signingBonus?: SortOrder
    rosterBonus?: SortOrder
    workoutBonus?: SortOrder
    incentiveBonus?: SortOrder
  }

  export type SalaryByYearCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type SalaryByYearAvgOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type SalaryByYearMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type SalaryByYearMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type SalaryByYearSumOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type CapHitByYearCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type CapHitByYearAvgOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type CapHitByYearMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type CapHitByYearMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type CapHitByYearSumOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type DeadCapByYearCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type DeadCapByYearAvgOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type DeadCapByYearMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type DeadCapByYearMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
  }

  export type DeadCapByYearSumOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type OptOutYearCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
  }

  export type OptOutYearAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type OptOutYearMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
  }

  export type OptOutYearMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
  }

  export type OptOutYearSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type RestructureEventCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    date?: SortOrder
    amountConvertedToBonus?: SortOrder
    newCapHit?: SortOrder
    newDeadCap?: SortOrder
  }

  export type RestructureEventAvgOrderByAggregateInput = {
    year?: SortOrder
    amountConvertedToBonus?: SortOrder
    newCapHit?: SortOrder
    newDeadCap?: SortOrder
  }

  export type RestructureEventMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    date?: SortOrder
    amountConvertedToBonus?: SortOrder
    newCapHit?: SortOrder
    newDeadCap?: SortOrder
  }

  export type RestructureEventMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    year?: SortOrder
    date?: SortOrder
    amountConvertedToBonus?: SortOrder
    newCapHit?: SortOrder
    newDeadCap?: SortOrder
  }

  export type RestructureEventSumOrderByAggregateInput = {
    year?: SortOrder
    amountConvertedToBonus?: SortOrder
    newCapHit?: SortOrder
    newDeadCap?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PerformanceBonusNullableScalarRelationFilter = {
    is?: PerformanceBonusWhereInput | null
    isNot?: PerformanceBonusWhereInput | null
  }

  export type RosterBonusNullableScalarRelationFilter = {
    is?: RosterBonusWhereInput | null
    isNot?: RosterBonusWhereInput | null
  }

  export type WorkoutBonusNullableScalarRelationFilter = {
    is?: WorkoutBonusWhereInput | null
    isNot?: WorkoutBonusWhereInput | null
  }

  export type OptionBonusNullableScalarRelationFilter = {
    is?: OptionBonusWhereInput | null
    isNot?: OptionBonusWhereInput | null
  }

  export type ContractClauseCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    noTradeClause?: SortOrder
    injuryGuarantee?: SortOrder
    restructureEligible?: SortOrder
    earlyTerminationPenalty?: SortOrder
    performanceBonusId?: SortOrder
    rosterBonusId?: SortOrder
    workoutBonusId?: SortOrder
    optionBonusId?: SortOrder
  }

  export type ContractClauseAvgOrderByAggregateInput = {
    earlyTerminationPenalty?: SortOrder
  }

  export type ContractClauseMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    noTradeClause?: SortOrder
    injuryGuarantee?: SortOrder
    restructureEligible?: SortOrder
    earlyTerminationPenalty?: SortOrder
    performanceBonusId?: SortOrder
    rosterBonusId?: SortOrder
    workoutBonusId?: SortOrder
    optionBonusId?: SortOrder
  }

  export type ContractClauseMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    noTradeClause?: SortOrder
    injuryGuarantee?: SortOrder
    restructureEligible?: SortOrder
    earlyTerminationPenalty?: SortOrder
    performanceBonusId?: SortOrder
    rosterBonusId?: SortOrder
    workoutBonusId?: SortOrder
    optionBonusId?: SortOrder
  }

  export type ContractClauseSumOrderByAggregateInput = {
    earlyTerminationPenalty?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ContractClauseScalarRelationFilter = {
    is?: ContractClauseWhereInput
    isNot?: ContractClauseWhereInput
  }

  export type StatMilestoneNullableScalarRelationFilter = {
    is?: StatMilestoneWhereInput | null
    isNot?: StatMilestoneWhereInput | null
  }

  export type PerformanceBonusCountOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    proBowl?: SortOrder
    allPro?: SortOrder
    mvp?: SortOrder
    superBowlMVP?: SortOrder
    playoffAppearance?: SortOrder
  }

  export type PerformanceBonusAvgOrderByAggregateInput = {
    proBowl?: SortOrder
    allPro?: SortOrder
    mvp?: SortOrder
    superBowlMVP?: SortOrder
    playoffAppearance?: SortOrder
  }

  export type PerformanceBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    proBowl?: SortOrder
    allPro?: SortOrder
    mvp?: SortOrder
    superBowlMVP?: SortOrder
    playoffAppearance?: SortOrder
  }

  export type PerformanceBonusMinOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    proBowl?: SortOrder
    allPro?: SortOrder
    mvp?: SortOrder
    superBowlMVP?: SortOrder
    playoffAppearance?: SortOrder
  }

  export type PerformanceBonusSumOrderByAggregateInput = {
    proBowl?: SortOrder
    allPro?: SortOrder
    mvp?: SortOrder
    superBowlMVP?: SortOrder
    playoffAppearance?: SortOrder
  }

  export type PerformanceBonusScalarRelationFilter = {
    is?: PerformanceBonusWhereInput
    isNot?: PerformanceBonusWhereInput
  }

  export type StatMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    performanceId?: SortOrder
    yards?: SortOrder
    touchdowns?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
  }

  export type StatMilestoneAvgOrderByAggregateInput = {
    yards?: SortOrder
    touchdowns?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
  }

  export type StatMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    performanceId?: SortOrder
    yards?: SortOrder
    touchdowns?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
  }

  export type StatMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    performanceId?: SortOrder
    yards?: SortOrder
    touchdowns?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
  }

  export type StatMilestoneSumOrderByAggregateInput = {
    yards?: SortOrder
    touchdowns?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
  }

  export type RosterBonusCountOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrder
    perGame?: SortOrder
  }

  export type RosterBonusAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RosterBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrder
    perGame?: SortOrder
  }

  export type RosterBonusMinOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrder
    perGame?: SortOrder
  }

  export type RosterBonusSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WorkoutBonusCountOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrder
    minWorkouts?: SortOrder
  }

  export type WorkoutBonusAvgOrderByAggregateInput = {
    amount?: SortOrder
    minWorkouts?: SortOrder
  }

  export type WorkoutBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrder
    minWorkouts?: SortOrder
  }

  export type WorkoutBonusMinOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    amount?: SortOrder
    minWorkouts?: SortOrder
  }

  export type WorkoutBonusSumOrderByAggregateInput = {
    amount?: SortOrder
    minWorkouts?: SortOrder
  }

  export type EnumOptionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOptionTypeNullableFilter<$PrismaModel> | $Enums.OptionType | null
  }

  export type OptionBonusCountOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type OptionBonusAvgOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type OptionBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type OptionBonusMinOrderByAggregateInput = {
    id?: SortOrder
    clauseId?: SortOrder
    year?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type OptionBonusSumOrderByAggregateInput = {
    year?: SortOrder
    amount?: SortOrder
  }

  export type EnumOptionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOptionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OptionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOptionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOptionTypeNullableFilter<$PrismaModel>
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    agencyName?: SortOrder
    reputation?: SortOrder
    yearsOfExperience?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    reputation?: SortOrder
    yearsOfExperience?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    agencyName?: SortOrder
    reputation?: SortOrder
    yearsOfExperience?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    agencyName?: SortOrder
    reputation?: SortOrder
    yearsOfExperience?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    reputation?: SortOrder
    yearsOfExperience?: SortOrder
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    speed?: SortOrder
    acceleration?: SortOrder
    agility?: SortOrder
    changeOfDirection?: SortOrder
    strength?: SortOrder
    impactPower?: SortOrder
    verticalJump?: SortOrder
    stamina?: SortOrder
    toughness?: SortOrder
    awareness?: SortOrder
    discipline?: SortOrder
    injuryRecovery?: SortOrder
    throwPower?: SortOrder
    throwAccuracyShort?: SortOrder
    throwAccuracyMedium?: SortOrder
    throwAccuracyDeep?: SortOrder
    throwOnRun?: SortOrder
    playAction?: SortOrder
    pocketPresence?: SortOrder
    releaseTime?: SortOrder
    decisionMaking?: SortOrder
    scrambling?: SortOrder
    breakSack?: SortOrder
    fieldVision?: SortOrder
    ballSecurity?: SortOrder
    ballCarrierVision?: SortOrder
    breakTackle?: SortOrder
    topBallCarrierSpeed?: SortOrder
    trucking?: SortOrder
    elusiveness?: SortOrder
    stiffArm?: SortOrder
    spinMove?: SortOrder
    jukeMove?: SortOrder
    shortYardage?: SortOrder
    goalLine?: SortOrder
    openFieldRunning?: SortOrder
    catching?: SortOrder
    catchInTraffic?: SortOrder
    spectacularCatch?: SortOrder
    contestedCatches?: SortOrder
    yardsAfterCatch?: SortOrder
    jumpBallTiming?: SortOrder
    routeRunning?: SortOrder
    shortRoute?: SortOrder
    mediumRoute?: SortOrder
    deepRoute?: SortOrder
    separation?: SortOrder
    release?: SortOrder
    runBlocking?: SortOrder
    passBlocking?: SortOrder
    pullBlocking?: SortOrder
    scrambleBlocking?: SortOrder
    playActionBlocking?: SortOrder
    screenBlocking?: SortOrder
    leadBlocking?: SortOrder
    tackling?: SortOrder
    blockShedding?: SortOrder
    blitzing?: SortOrder
    playRecognition?: SortOrder
    openFieldTackling?: SortOrder
    coverageAgainstTEsRBs?: SortOrder
    coverageAgainstSlot?: SortOrder
    deepCoverage?: SortOrder
    runDefense?: SortOrder
    passRush?: SortOrder
    finessePassRush?: SortOrder
    powerPassRush?: SortOrder
    runStopping?: SortOrder
    penetration?: SortOrder
    edgeSetting?: SortOrder
    disengagement?: SortOrder
    offensiveLineRecognition?: SortOrder
    hitPower?: SortOrder
    pressCoverage?: SortOrder
    offBallCoverage?: SortOrder
    manCoverage?: SortOrder
    zoneCoverage?: SortOrder
    ballHawking?: SortOrder
    interceptions?: SortOrder
    passDeflection?: SortOrder
    kickPower?: SortOrder
    kickAccuracy?: SortOrder
    puntPower?: SortOrder
    puntAccuracy?: SortOrder
    onsideKickAbility?: SortOrder
    kickReturnVision?: SortOrder
    puntReturnVision?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    speed?: SortOrder
    acceleration?: SortOrder
    agility?: SortOrder
    changeOfDirection?: SortOrder
    strength?: SortOrder
    impactPower?: SortOrder
    verticalJump?: SortOrder
    stamina?: SortOrder
    toughness?: SortOrder
    awareness?: SortOrder
    discipline?: SortOrder
    injuryRecovery?: SortOrder
    throwPower?: SortOrder
    throwAccuracyShort?: SortOrder
    throwAccuracyMedium?: SortOrder
    throwAccuracyDeep?: SortOrder
    throwOnRun?: SortOrder
    playAction?: SortOrder
    pocketPresence?: SortOrder
    releaseTime?: SortOrder
    decisionMaking?: SortOrder
    scrambling?: SortOrder
    breakSack?: SortOrder
    fieldVision?: SortOrder
    ballSecurity?: SortOrder
    ballCarrierVision?: SortOrder
    breakTackle?: SortOrder
    topBallCarrierSpeed?: SortOrder
    trucking?: SortOrder
    elusiveness?: SortOrder
    stiffArm?: SortOrder
    spinMove?: SortOrder
    jukeMove?: SortOrder
    shortYardage?: SortOrder
    goalLine?: SortOrder
    openFieldRunning?: SortOrder
    catching?: SortOrder
    catchInTraffic?: SortOrder
    spectacularCatch?: SortOrder
    contestedCatches?: SortOrder
    yardsAfterCatch?: SortOrder
    jumpBallTiming?: SortOrder
    routeRunning?: SortOrder
    shortRoute?: SortOrder
    mediumRoute?: SortOrder
    deepRoute?: SortOrder
    separation?: SortOrder
    release?: SortOrder
    runBlocking?: SortOrder
    passBlocking?: SortOrder
    pullBlocking?: SortOrder
    scrambleBlocking?: SortOrder
    playActionBlocking?: SortOrder
    screenBlocking?: SortOrder
    leadBlocking?: SortOrder
    tackling?: SortOrder
    blockShedding?: SortOrder
    blitzing?: SortOrder
    playRecognition?: SortOrder
    openFieldTackling?: SortOrder
    coverageAgainstTEsRBs?: SortOrder
    coverageAgainstSlot?: SortOrder
    deepCoverage?: SortOrder
    runDefense?: SortOrder
    passRush?: SortOrder
    finessePassRush?: SortOrder
    powerPassRush?: SortOrder
    runStopping?: SortOrder
    penetration?: SortOrder
    edgeSetting?: SortOrder
    disengagement?: SortOrder
    offensiveLineRecognition?: SortOrder
    hitPower?: SortOrder
    pressCoverage?: SortOrder
    offBallCoverage?: SortOrder
    manCoverage?: SortOrder
    zoneCoverage?: SortOrder
    ballHawking?: SortOrder
    interceptions?: SortOrder
    passDeflection?: SortOrder
    kickPower?: SortOrder
    kickAccuracy?: SortOrder
    puntPower?: SortOrder
    puntAccuracy?: SortOrder
    onsideKickAbility?: SortOrder
    kickReturnVision?: SortOrder
    puntReturnVision?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    speed?: SortOrder
    acceleration?: SortOrder
    agility?: SortOrder
    changeOfDirection?: SortOrder
    strength?: SortOrder
    impactPower?: SortOrder
    verticalJump?: SortOrder
    stamina?: SortOrder
    toughness?: SortOrder
    awareness?: SortOrder
    discipline?: SortOrder
    injuryRecovery?: SortOrder
    throwPower?: SortOrder
    throwAccuracyShort?: SortOrder
    throwAccuracyMedium?: SortOrder
    throwAccuracyDeep?: SortOrder
    throwOnRun?: SortOrder
    playAction?: SortOrder
    pocketPresence?: SortOrder
    releaseTime?: SortOrder
    decisionMaking?: SortOrder
    scrambling?: SortOrder
    breakSack?: SortOrder
    fieldVision?: SortOrder
    ballSecurity?: SortOrder
    ballCarrierVision?: SortOrder
    breakTackle?: SortOrder
    topBallCarrierSpeed?: SortOrder
    trucking?: SortOrder
    elusiveness?: SortOrder
    stiffArm?: SortOrder
    spinMove?: SortOrder
    jukeMove?: SortOrder
    shortYardage?: SortOrder
    goalLine?: SortOrder
    openFieldRunning?: SortOrder
    catching?: SortOrder
    catchInTraffic?: SortOrder
    spectacularCatch?: SortOrder
    contestedCatches?: SortOrder
    yardsAfterCatch?: SortOrder
    jumpBallTiming?: SortOrder
    routeRunning?: SortOrder
    shortRoute?: SortOrder
    mediumRoute?: SortOrder
    deepRoute?: SortOrder
    separation?: SortOrder
    release?: SortOrder
    runBlocking?: SortOrder
    passBlocking?: SortOrder
    pullBlocking?: SortOrder
    scrambleBlocking?: SortOrder
    playActionBlocking?: SortOrder
    screenBlocking?: SortOrder
    leadBlocking?: SortOrder
    tackling?: SortOrder
    blockShedding?: SortOrder
    blitzing?: SortOrder
    playRecognition?: SortOrder
    openFieldTackling?: SortOrder
    coverageAgainstTEsRBs?: SortOrder
    coverageAgainstSlot?: SortOrder
    deepCoverage?: SortOrder
    runDefense?: SortOrder
    passRush?: SortOrder
    finessePassRush?: SortOrder
    powerPassRush?: SortOrder
    runStopping?: SortOrder
    penetration?: SortOrder
    edgeSetting?: SortOrder
    disengagement?: SortOrder
    offensiveLineRecognition?: SortOrder
    hitPower?: SortOrder
    pressCoverage?: SortOrder
    offBallCoverage?: SortOrder
    manCoverage?: SortOrder
    zoneCoverage?: SortOrder
    ballHawking?: SortOrder
    interceptions?: SortOrder
    passDeflection?: SortOrder
    kickPower?: SortOrder
    kickAccuracy?: SortOrder
    puntPower?: SortOrder
    puntAccuracy?: SortOrder
    onsideKickAbility?: SortOrder
    kickReturnVision?: SortOrder
    puntReturnVision?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    speed?: SortOrder
    acceleration?: SortOrder
    agility?: SortOrder
    changeOfDirection?: SortOrder
    strength?: SortOrder
    impactPower?: SortOrder
    verticalJump?: SortOrder
    stamina?: SortOrder
    toughness?: SortOrder
    awareness?: SortOrder
    discipline?: SortOrder
    injuryRecovery?: SortOrder
    throwPower?: SortOrder
    throwAccuracyShort?: SortOrder
    throwAccuracyMedium?: SortOrder
    throwAccuracyDeep?: SortOrder
    throwOnRun?: SortOrder
    playAction?: SortOrder
    pocketPresence?: SortOrder
    releaseTime?: SortOrder
    decisionMaking?: SortOrder
    scrambling?: SortOrder
    breakSack?: SortOrder
    fieldVision?: SortOrder
    ballSecurity?: SortOrder
    ballCarrierVision?: SortOrder
    breakTackle?: SortOrder
    topBallCarrierSpeed?: SortOrder
    trucking?: SortOrder
    elusiveness?: SortOrder
    stiffArm?: SortOrder
    spinMove?: SortOrder
    jukeMove?: SortOrder
    shortYardage?: SortOrder
    goalLine?: SortOrder
    openFieldRunning?: SortOrder
    catching?: SortOrder
    catchInTraffic?: SortOrder
    spectacularCatch?: SortOrder
    contestedCatches?: SortOrder
    yardsAfterCatch?: SortOrder
    jumpBallTiming?: SortOrder
    routeRunning?: SortOrder
    shortRoute?: SortOrder
    mediumRoute?: SortOrder
    deepRoute?: SortOrder
    separation?: SortOrder
    release?: SortOrder
    runBlocking?: SortOrder
    passBlocking?: SortOrder
    pullBlocking?: SortOrder
    scrambleBlocking?: SortOrder
    playActionBlocking?: SortOrder
    screenBlocking?: SortOrder
    leadBlocking?: SortOrder
    tackling?: SortOrder
    blockShedding?: SortOrder
    blitzing?: SortOrder
    playRecognition?: SortOrder
    openFieldTackling?: SortOrder
    coverageAgainstTEsRBs?: SortOrder
    coverageAgainstSlot?: SortOrder
    deepCoverage?: SortOrder
    runDefense?: SortOrder
    passRush?: SortOrder
    finessePassRush?: SortOrder
    powerPassRush?: SortOrder
    runStopping?: SortOrder
    penetration?: SortOrder
    edgeSetting?: SortOrder
    disengagement?: SortOrder
    offensiveLineRecognition?: SortOrder
    hitPower?: SortOrder
    pressCoverage?: SortOrder
    offBallCoverage?: SortOrder
    manCoverage?: SortOrder
    zoneCoverage?: SortOrder
    ballHawking?: SortOrder
    interceptions?: SortOrder
    passDeflection?: SortOrder
    kickPower?: SortOrder
    kickAccuracy?: SortOrder
    puntPower?: SortOrder
    puntAccuracy?: SortOrder
    onsideKickAbility?: SortOrder
    kickReturnVision?: SortOrder
    puntReturnVision?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    speed?: SortOrder
    acceleration?: SortOrder
    agility?: SortOrder
    changeOfDirection?: SortOrder
    strength?: SortOrder
    impactPower?: SortOrder
    verticalJump?: SortOrder
    stamina?: SortOrder
    toughness?: SortOrder
    awareness?: SortOrder
    discipline?: SortOrder
    injuryRecovery?: SortOrder
    throwPower?: SortOrder
    throwAccuracyShort?: SortOrder
    throwAccuracyMedium?: SortOrder
    throwAccuracyDeep?: SortOrder
    throwOnRun?: SortOrder
    playAction?: SortOrder
    pocketPresence?: SortOrder
    releaseTime?: SortOrder
    decisionMaking?: SortOrder
    scrambling?: SortOrder
    breakSack?: SortOrder
    fieldVision?: SortOrder
    ballSecurity?: SortOrder
    ballCarrierVision?: SortOrder
    breakTackle?: SortOrder
    topBallCarrierSpeed?: SortOrder
    trucking?: SortOrder
    elusiveness?: SortOrder
    stiffArm?: SortOrder
    spinMove?: SortOrder
    jukeMove?: SortOrder
    shortYardage?: SortOrder
    goalLine?: SortOrder
    openFieldRunning?: SortOrder
    catching?: SortOrder
    catchInTraffic?: SortOrder
    spectacularCatch?: SortOrder
    contestedCatches?: SortOrder
    yardsAfterCatch?: SortOrder
    jumpBallTiming?: SortOrder
    routeRunning?: SortOrder
    shortRoute?: SortOrder
    mediumRoute?: SortOrder
    deepRoute?: SortOrder
    separation?: SortOrder
    release?: SortOrder
    runBlocking?: SortOrder
    passBlocking?: SortOrder
    pullBlocking?: SortOrder
    scrambleBlocking?: SortOrder
    playActionBlocking?: SortOrder
    screenBlocking?: SortOrder
    leadBlocking?: SortOrder
    tackling?: SortOrder
    blockShedding?: SortOrder
    blitzing?: SortOrder
    playRecognition?: SortOrder
    openFieldTackling?: SortOrder
    coverageAgainstTEsRBs?: SortOrder
    coverageAgainstSlot?: SortOrder
    deepCoverage?: SortOrder
    runDefense?: SortOrder
    passRush?: SortOrder
    finessePassRush?: SortOrder
    powerPassRush?: SortOrder
    runStopping?: SortOrder
    penetration?: SortOrder
    edgeSetting?: SortOrder
    disengagement?: SortOrder
    offensiveLineRecognition?: SortOrder
    hitPower?: SortOrder
    pressCoverage?: SortOrder
    offBallCoverage?: SortOrder
    manCoverage?: SortOrder
    zoneCoverage?: SortOrder
    ballHawking?: SortOrder
    interceptions?: SortOrder
    passDeflection?: SortOrder
    kickPower?: SortOrder
    kickAccuracy?: SortOrder
    puntPower?: SortOrder
    puntAccuracy?: SortOrder
    onsideKickAbility?: SortOrder
    kickReturnVision?: SortOrder
    puntReturnVision?: SortOrder
  }

  export type StatPlayerIdSeasonCompoundUniqueInput = {
    playerId: string
    season: number
  }

  export type StatCountOrderByAggregateInput = {
    id?: SortOrder
    season?: SortOrder
    playerId?: SortOrder
    gamesPlayed?: SortOrder
    gamesStarted?: SortOrder
    snaps?: SortOrder
    rushingAttempts?: SortOrder
    rushingYards?: SortOrder
    yardsPerCarry?: SortOrder
    yardsAfterContact?: SortOrder
    yardsPerGame?: SortOrder
    rushingLong?: SortOrder
    rushingTouchdowns?: SortOrder
    fumblesLost?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    yardsPerReception?: SortOrder
    yardsAfterCatch?: SortOrder
    yardsPerTarget?: SortOrder
    airYards?: SortOrder
    receivingLong?: SortOrder
    targets?: SortOrder
    receivingTouchdowns?: SortOrder
    drops?: SortOrder
    passingAttempts?: SortOrder
    passingCompletions?: SortOrder
    passingYards?: SortOrder
    yardsPerPass?: SortOrder
    yardsPerCompletion?: SortOrder
    completionPercentage?: SortOrder
    passingTouchdowns?: SortOrder
    interceptions?: SortOrder
    sacksTaken?: SortOrder
    passerRating?: SortOrder
    pancakes?: SortOrder
    sacksAllowed?: SortOrder
    hurriesAllowed?: SortOrder
    tackles?: SortOrder
    tacklesForLoss?: SortOrder
    sacks?: SortOrder
    interceptionsMade?: SortOrder
    forcedFumbles?: SortOrder
    fumbleRecoveries?: SortOrder
    passesDefended?: SortOrder
    defensiveTouchdowns?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    punts?: SortOrder
    puntYards?: SortOrder
    kickReturns?: SortOrder
    kickReturnYards?: SortOrder
    puntReturns?: SortOrder
    puntReturnYards?: SortOrder
    specialTeamsTouchdowns?: SortOrder
    penaltiesCommitted?: SortOrder
    penaltyYards?: SortOrder
  }

  export type StatAvgOrderByAggregateInput = {
    season?: SortOrder
    gamesPlayed?: SortOrder
    gamesStarted?: SortOrder
    snaps?: SortOrder
    rushingAttempts?: SortOrder
    rushingYards?: SortOrder
    yardsPerCarry?: SortOrder
    yardsAfterContact?: SortOrder
    yardsPerGame?: SortOrder
    rushingLong?: SortOrder
    rushingTouchdowns?: SortOrder
    fumblesLost?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    yardsPerReception?: SortOrder
    yardsAfterCatch?: SortOrder
    yardsPerTarget?: SortOrder
    airYards?: SortOrder
    receivingLong?: SortOrder
    targets?: SortOrder
    receivingTouchdowns?: SortOrder
    drops?: SortOrder
    passingAttempts?: SortOrder
    passingCompletions?: SortOrder
    passingYards?: SortOrder
    yardsPerPass?: SortOrder
    yardsPerCompletion?: SortOrder
    completionPercentage?: SortOrder
    passingTouchdowns?: SortOrder
    interceptions?: SortOrder
    sacksTaken?: SortOrder
    passerRating?: SortOrder
    pancakes?: SortOrder
    sacksAllowed?: SortOrder
    hurriesAllowed?: SortOrder
    tackles?: SortOrder
    tacklesForLoss?: SortOrder
    sacks?: SortOrder
    interceptionsMade?: SortOrder
    forcedFumbles?: SortOrder
    fumbleRecoveries?: SortOrder
    passesDefended?: SortOrder
    defensiveTouchdowns?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    punts?: SortOrder
    puntYards?: SortOrder
    kickReturns?: SortOrder
    kickReturnYards?: SortOrder
    puntReturns?: SortOrder
    puntReturnYards?: SortOrder
    specialTeamsTouchdowns?: SortOrder
    penaltiesCommitted?: SortOrder
    penaltyYards?: SortOrder
  }

  export type StatMaxOrderByAggregateInput = {
    id?: SortOrder
    season?: SortOrder
    playerId?: SortOrder
    gamesPlayed?: SortOrder
    gamesStarted?: SortOrder
    snaps?: SortOrder
    rushingAttempts?: SortOrder
    rushingYards?: SortOrder
    yardsPerCarry?: SortOrder
    yardsAfterContact?: SortOrder
    yardsPerGame?: SortOrder
    rushingLong?: SortOrder
    rushingTouchdowns?: SortOrder
    fumblesLost?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    yardsPerReception?: SortOrder
    yardsAfterCatch?: SortOrder
    yardsPerTarget?: SortOrder
    airYards?: SortOrder
    receivingLong?: SortOrder
    targets?: SortOrder
    receivingTouchdowns?: SortOrder
    drops?: SortOrder
    passingAttempts?: SortOrder
    passingCompletions?: SortOrder
    passingYards?: SortOrder
    yardsPerPass?: SortOrder
    yardsPerCompletion?: SortOrder
    completionPercentage?: SortOrder
    passingTouchdowns?: SortOrder
    interceptions?: SortOrder
    sacksTaken?: SortOrder
    passerRating?: SortOrder
    pancakes?: SortOrder
    sacksAllowed?: SortOrder
    hurriesAllowed?: SortOrder
    tackles?: SortOrder
    tacklesForLoss?: SortOrder
    sacks?: SortOrder
    interceptionsMade?: SortOrder
    forcedFumbles?: SortOrder
    fumbleRecoveries?: SortOrder
    passesDefended?: SortOrder
    defensiveTouchdowns?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    punts?: SortOrder
    puntYards?: SortOrder
    kickReturns?: SortOrder
    kickReturnYards?: SortOrder
    puntReturns?: SortOrder
    puntReturnYards?: SortOrder
    specialTeamsTouchdowns?: SortOrder
    penaltiesCommitted?: SortOrder
    penaltyYards?: SortOrder
  }

  export type StatMinOrderByAggregateInput = {
    id?: SortOrder
    season?: SortOrder
    playerId?: SortOrder
    gamesPlayed?: SortOrder
    gamesStarted?: SortOrder
    snaps?: SortOrder
    rushingAttempts?: SortOrder
    rushingYards?: SortOrder
    yardsPerCarry?: SortOrder
    yardsAfterContact?: SortOrder
    yardsPerGame?: SortOrder
    rushingLong?: SortOrder
    rushingTouchdowns?: SortOrder
    fumblesLost?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    yardsPerReception?: SortOrder
    yardsAfterCatch?: SortOrder
    yardsPerTarget?: SortOrder
    airYards?: SortOrder
    receivingLong?: SortOrder
    targets?: SortOrder
    receivingTouchdowns?: SortOrder
    drops?: SortOrder
    passingAttempts?: SortOrder
    passingCompletions?: SortOrder
    passingYards?: SortOrder
    yardsPerPass?: SortOrder
    yardsPerCompletion?: SortOrder
    completionPercentage?: SortOrder
    passingTouchdowns?: SortOrder
    interceptions?: SortOrder
    sacksTaken?: SortOrder
    passerRating?: SortOrder
    pancakes?: SortOrder
    sacksAllowed?: SortOrder
    hurriesAllowed?: SortOrder
    tackles?: SortOrder
    tacklesForLoss?: SortOrder
    sacks?: SortOrder
    interceptionsMade?: SortOrder
    forcedFumbles?: SortOrder
    fumbleRecoveries?: SortOrder
    passesDefended?: SortOrder
    defensiveTouchdowns?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    punts?: SortOrder
    puntYards?: SortOrder
    kickReturns?: SortOrder
    kickReturnYards?: SortOrder
    puntReturns?: SortOrder
    puntReturnYards?: SortOrder
    specialTeamsTouchdowns?: SortOrder
    penaltiesCommitted?: SortOrder
    penaltyYards?: SortOrder
  }

  export type StatSumOrderByAggregateInput = {
    season?: SortOrder
    gamesPlayed?: SortOrder
    gamesStarted?: SortOrder
    snaps?: SortOrder
    rushingAttempts?: SortOrder
    rushingYards?: SortOrder
    yardsPerCarry?: SortOrder
    yardsAfterContact?: SortOrder
    yardsPerGame?: SortOrder
    rushingLong?: SortOrder
    rushingTouchdowns?: SortOrder
    fumblesLost?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    yardsPerReception?: SortOrder
    yardsAfterCatch?: SortOrder
    yardsPerTarget?: SortOrder
    airYards?: SortOrder
    receivingLong?: SortOrder
    targets?: SortOrder
    receivingTouchdowns?: SortOrder
    drops?: SortOrder
    passingAttempts?: SortOrder
    passingCompletions?: SortOrder
    passingYards?: SortOrder
    yardsPerPass?: SortOrder
    yardsPerCompletion?: SortOrder
    completionPercentage?: SortOrder
    passingTouchdowns?: SortOrder
    interceptions?: SortOrder
    sacksTaken?: SortOrder
    passerRating?: SortOrder
    pancakes?: SortOrder
    sacksAllowed?: SortOrder
    hurriesAllowed?: SortOrder
    tackles?: SortOrder
    tacklesForLoss?: SortOrder
    sacks?: SortOrder
    interceptionsMade?: SortOrder
    forcedFumbles?: SortOrder
    fumbleRecoveries?: SortOrder
    passesDefended?: SortOrder
    defensiveTouchdowns?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    punts?: SortOrder
    puntYards?: SortOrder
    kickReturns?: SortOrder
    kickReturnYards?: SortOrder
    puntReturns?: SortOrder
    puntReturnYards?: SortOrder
    specialTeamsTouchdowns?: SortOrder
    penaltiesCommitted?: SortOrder
    penaltyYards?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ContractDesiresCountOrderByAggregateInput = {
    id?: SortOrder
    years?: SortOrder
    averageSalary?: SortOrder
    totalGuaranteed?: SortOrder
    bonuses?: SortOrder
    tradeClause?: SortOrder
    injuryGuarantee?: SortOrder
    rosterBonus?: SortOrder
    workoutBonus?: SortOrder
    incentives?: SortOrder
    optOutYears?: SortOrder
    isPlayerOptOut?: SortOrder
    isTeamOptOut?: SortOrder
    playerId?: SortOrder
  }

  export type ContractDesiresAvgOrderByAggregateInput = {
    years?: SortOrder
    averageSalary?: SortOrder
    totalGuaranteed?: SortOrder
    optOutYears?: SortOrder
  }

  export type ContractDesiresMaxOrderByAggregateInput = {
    id?: SortOrder
    years?: SortOrder
    averageSalary?: SortOrder
    totalGuaranteed?: SortOrder
    tradeClause?: SortOrder
    injuryGuarantee?: SortOrder
    isPlayerOptOut?: SortOrder
    isTeamOptOut?: SortOrder
    playerId?: SortOrder
  }

  export type ContractDesiresMinOrderByAggregateInput = {
    id?: SortOrder
    years?: SortOrder
    averageSalary?: SortOrder
    totalGuaranteed?: SortOrder
    tradeClause?: SortOrder
    injuryGuarantee?: SortOrder
    isPlayerOptOut?: SortOrder
    isTeamOptOut?: SortOrder
    playerId?: SortOrder
  }

  export type ContractDesiresSumOrderByAggregateInput = {
    years?: SortOrder
    averageSalary?: SortOrder
    totalGuaranteed?: SortOrder
    optOutYears?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PlayerCreaterecordsHeldInput = {
    set: $Enums.FootballRecordEnum[]
  }

  export type PlayerCreateinjuryHistoryInput = {
    set: $Enums.InjuryTypeEnum[]
  }

  export type PlayerCreatepersonalityTraitsInput = {
    set: $Enums.PlayerPersonalityTraitEnum[]
  }

  export type PlayerCreateoffFieldConcernsInput = {
    set: $Enums.OffFieldConcernTypeEnum[]
  }

  export type PlayerCreatepastEventsInput = {
    set: $Enums.PlayerEventEnum[]
  }

  export type TeamCreateNestedOneWithoutPlayersInput = {
    create?: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayersInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutPracticeSquadInput = {
    create?: XOR<TeamCreateWithoutPracticeSquadInput, TeamUncheckedCreateWithoutPracticeSquadInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPracticeSquadInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutInjuredReserveInput = {
    create?: XOR<TeamCreateWithoutInjuredReserveInput, TeamUncheckedCreateWithoutInjuredReserveInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInjuredReserveInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSuspendedListInput = {
    create?: XOR<TeamCreateWithoutSuspendedListInput, TeamUncheckedCreateWithoutSuspendedListInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSuspendedListInput
    connect?: TeamWhereUniqueInput
  }

  export type PlayerContractCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerContractCreateWithoutPlayerInput, PlayerContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutPlayerInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutPlayersInput = {
    create?: XOR<AgentCreateWithoutPlayersInput, AgentUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPlayersInput
    connect?: AgentWhereUniqueInput
  }

  export type RatingCreateNestedOneWithoutPlayerInput = {
    create?: XOR<RatingCreateWithoutPlayerInput, RatingUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: RatingCreateOrConnectWithoutPlayerInput
    connect?: RatingWhereUniqueInput
  }

  export type StatCreateNestedOneWithoutPlayerInput = {
    create?: XOR<StatCreateWithoutPlayerInput, StatUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: StatCreateOrConnectWithoutPlayerInput
    connect?: StatWhereUniqueInput
  }

  export type ContractDesiresCreateNestedOneWithoutPlayerInput = {
    create?: XOR<ContractDesiresCreateWithoutPlayerInput, ContractDesiresUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ContractDesiresCreateOrConnectWithoutPlayerInput
    connect?: ContractDesiresWhereUniqueInput
  }

  export type PlayerContractUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerContractCreateWithoutPlayerInput, PlayerContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutPlayerInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumPlayerPositionEnumFieldUpdateOperationsInput = {
    set?: $Enums.PlayerPositionEnum | null
  }

  export type NullableEnumPlayerRoleEnumFieldUpdateOperationsInput = {
    set?: $Enums.PlayerRoleEnum | null
  }

  export type PlayerUpdaterecordsHeldInput = {
    set?: $Enums.FootballRecordEnum[]
    push?: $Enums.FootballRecordEnum | $Enums.FootballRecordEnum[]
  }

  export type NullableEnumInjuryTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.InjuryTypeEnum | null
  }

  export type PlayerUpdateinjuryHistoryInput = {
    set?: $Enums.InjuryTypeEnum[]
    push?: $Enums.InjuryTypeEnum | $Enums.InjuryTypeEnum[]
  }

  export type PlayerUpdatepersonalityTraitsInput = {
    set?: $Enums.PlayerPersonalityTraitEnum[]
    push?: $Enums.PlayerPersonalityTraitEnum | $Enums.PlayerPersonalityTraitEnum[]
  }

  export type PlayerUpdateoffFieldConcernsInput = {
    set?: $Enums.OffFieldConcernTypeEnum[]
    push?: $Enums.OffFieldConcernTypeEnum | $Enums.OffFieldConcernTypeEnum[]
  }

  export type PlayerUpdatepastEventsInput = {
    set?: $Enums.PlayerEventEnum[]
    push?: $Enums.PlayerEventEnum | $Enums.PlayerEventEnum[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.ContractNegotiationStatusEnum | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeamUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayersInput
    upsert?: TeamUpsertWithoutPlayersInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlayersInput, TeamUpdateWithoutPlayersInput>, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type TeamUpdateOneWithoutPracticeSquadNestedInput = {
    create?: XOR<TeamCreateWithoutPracticeSquadInput, TeamUncheckedCreateWithoutPracticeSquadInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPracticeSquadInput
    upsert?: TeamUpsertWithoutPracticeSquadInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPracticeSquadInput, TeamUpdateWithoutPracticeSquadInput>, TeamUncheckedUpdateWithoutPracticeSquadInput>
  }

  export type TeamUpdateOneWithoutInjuredReserveNestedInput = {
    create?: XOR<TeamCreateWithoutInjuredReserveInput, TeamUncheckedCreateWithoutInjuredReserveInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInjuredReserveInput
    upsert?: TeamUpsertWithoutInjuredReserveInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutInjuredReserveInput, TeamUpdateWithoutInjuredReserveInput>, TeamUncheckedUpdateWithoutInjuredReserveInput>
  }

  export type TeamUpdateOneWithoutSuspendedListNestedInput = {
    create?: XOR<TeamCreateWithoutSuspendedListInput, TeamUncheckedCreateWithoutSuspendedListInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSuspendedListInput
    upsert?: TeamUpsertWithoutSuspendedListInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSuspendedListInput, TeamUpdateWithoutSuspendedListInput>, TeamUncheckedUpdateWithoutSuspendedListInput>
  }

  export type PlayerContractUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerContractCreateWithoutPlayerInput, PlayerContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutPlayerInput
    upsert?: PlayerContractUpsertWithoutPlayerInput
    disconnect?: PlayerContractWhereInput | boolean
    delete?: PlayerContractWhereInput | boolean
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutPlayerInput, PlayerContractUpdateWithoutPlayerInput>, PlayerContractUncheckedUpdateWithoutPlayerInput>
  }

  export type AgentUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<AgentCreateWithoutPlayersInput, AgentUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPlayersInput
    upsert?: AgentUpsertWithoutPlayersInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPlayersInput, AgentUpdateWithoutPlayersInput>, AgentUncheckedUpdateWithoutPlayersInput>
  }

  export type RatingUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<RatingCreateWithoutPlayerInput, RatingUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: RatingCreateOrConnectWithoutPlayerInput
    upsert?: RatingUpsertWithoutPlayerInput
    disconnect?: RatingWhereInput | boolean
    delete?: RatingWhereInput | boolean
    connect?: RatingWhereUniqueInput
    update?: XOR<XOR<RatingUpdateToOneWithWhereWithoutPlayerInput, RatingUpdateWithoutPlayerInput>, RatingUncheckedUpdateWithoutPlayerInput>
  }

  export type StatUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<StatCreateWithoutPlayerInput, StatUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: StatCreateOrConnectWithoutPlayerInput
    upsert?: StatUpsertWithoutPlayerInput
    disconnect?: StatWhereInput | boolean
    delete?: StatWhereInput | boolean
    connect?: StatWhereUniqueInput
    update?: XOR<XOR<StatUpdateToOneWithWhereWithoutPlayerInput, StatUpdateWithoutPlayerInput>, StatUncheckedUpdateWithoutPlayerInput>
  }

  export type ContractDesiresUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<ContractDesiresCreateWithoutPlayerInput, ContractDesiresUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ContractDesiresCreateOrConnectWithoutPlayerInput
    upsert?: ContractDesiresUpsertWithoutPlayerInput
    disconnect?: ContractDesiresWhereInput | boolean
    delete?: ContractDesiresWhereInput | boolean
    connect?: ContractDesiresWhereUniqueInput
    update?: XOR<XOR<ContractDesiresUpdateToOneWithWhereWithoutPlayerInput, ContractDesiresUpdateWithoutPlayerInput>, ContractDesiresUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerContractCreateWithoutPlayerInput, PlayerContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutPlayerInput
    upsert?: PlayerContractUpsertWithoutPlayerInput
    disconnect?: PlayerContractWhereInput | boolean
    delete?: PlayerContractWhereInput | boolean
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutPlayerInput, PlayerContractUpdateWithoutPlayerInput>, PlayerContractUncheckedUpdateWithoutPlayerInput>
  }

  export type TeamCreateteamNeedsInput = {
    set: $Enums.PlayerPositionEnum[]
  }

  export type TeamCreateretiredNumbersInput = {
    set: number[]
  }

  export type TeamCreaterivalTeamsInput = {
    set: string[]
  }

  export type PlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutPracticeSquadTeamInput = {
    create?: XOR<PlayerCreateWithoutPracticeSquadTeamInput, PlayerUncheckedCreateWithoutPracticeSquadTeamInput> | PlayerCreateWithoutPracticeSquadTeamInput[] | PlayerUncheckedCreateWithoutPracticeSquadTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutPracticeSquadTeamInput | PlayerCreateOrConnectWithoutPracticeSquadTeamInput[]
    createMany?: PlayerCreateManyPracticeSquadTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutInjuredReserveTeamInput = {
    create?: XOR<PlayerCreateWithoutInjuredReserveTeamInput, PlayerUncheckedCreateWithoutInjuredReserveTeamInput> | PlayerCreateWithoutInjuredReserveTeamInput[] | PlayerUncheckedCreateWithoutInjuredReserveTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutInjuredReserveTeamInput | PlayerCreateOrConnectWithoutInjuredReserveTeamInput[]
    createMany?: PlayerCreateManyInjuredReserveTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutSuspendedListTeamInput = {
    create?: XOR<PlayerCreateWithoutSuspendedListTeamInput, PlayerUncheckedCreateWithoutSuspendedListTeamInput> | PlayerCreateWithoutSuspendedListTeamInput[] | PlayerUncheckedCreateWithoutSuspendedListTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutSuspendedListTeamInput | PlayerCreateOrConnectWithoutSuspendedListTeamInput[]
    createMany?: PlayerCreateManySuspendedListTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerContractCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerContractCreateWithoutTeamInput, PlayerContractUncheckedCreateWithoutTeamInput> | PlayerContractCreateWithoutTeamInput[] | PlayerContractUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerContractCreateOrConnectWithoutTeamInput | PlayerContractCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerContractCreateManyTeamInputEnvelope
    connect?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutPracticeSquadTeamInput = {
    create?: XOR<PlayerCreateWithoutPracticeSquadTeamInput, PlayerUncheckedCreateWithoutPracticeSquadTeamInput> | PlayerCreateWithoutPracticeSquadTeamInput[] | PlayerUncheckedCreateWithoutPracticeSquadTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutPracticeSquadTeamInput | PlayerCreateOrConnectWithoutPracticeSquadTeamInput[]
    createMany?: PlayerCreateManyPracticeSquadTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutInjuredReserveTeamInput = {
    create?: XOR<PlayerCreateWithoutInjuredReserveTeamInput, PlayerUncheckedCreateWithoutInjuredReserveTeamInput> | PlayerCreateWithoutInjuredReserveTeamInput[] | PlayerUncheckedCreateWithoutInjuredReserveTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutInjuredReserveTeamInput | PlayerCreateOrConnectWithoutInjuredReserveTeamInput[]
    createMany?: PlayerCreateManyInjuredReserveTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutSuspendedListTeamInput = {
    create?: XOR<PlayerCreateWithoutSuspendedListTeamInput, PlayerUncheckedCreateWithoutSuspendedListTeamInput> | PlayerCreateWithoutSuspendedListTeamInput[] | PlayerUncheckedCreateWithoutSuspendedListTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutSuspendedListTeamInput | PlayerCreateOrConnectWithoutSuspendedListTeamInput[]
    createMany?: PlayerCreateManySuspendedListTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerContractUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerContractCreateWithoutTeamInput, PlayerContractUncheckedCreateWithoutTeamInput> | PlayerContractCreateWithoutTeamInput[] | PlayerContractUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerContractCreateOrConnectWithoutTeamInput | PlayerContractCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerContractCreateManyTeamInputEnvelope
    connect?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
  }

  export type EnumDivisionEnumFieldUpdateOperationsInput = {
    set?: $Enums.DivisionEnum
  }

  export type EnumConferenceEnumFieldUpdateOperationsInput = {
    set?: $Enums.ConferenceEnum
  }

  export type EnumOffensiveSchemeEnumFieldUpdateOperationsInput = {
    set?: $Enums.OffensiveSchemeEnum
  }

  export type EnumDefensiveSchemeEnumFieldUpdateOperationsInput = {
    set?: $Enums.DefensiveSchemeEnum
  }

  export type TeamUpdateteamNeedsInput = {
    set?: $Enums.PlayerPositionEnum[]
    push?: $Enums.PlayerPositionEnum | $Enums.PlayerPositionEnum[]
  }

  export type EnumFinancialHealthEnumFieldUpdateOperationsInput = {
    set?: $Enums.FinancialHealthEnum
  }

  export type TeamUpdateretiredNumbersInput = {
    set?: number[]
    push?: number | number[]
  }

  export type TeamUpdaterivalTeamsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutTeamInput | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutTeamInput | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutTeamInput | PlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutPracticeSquadTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutPracticeSquadTeamInput, PlayerUncheckedCreateWithoutPracticeSquadTeamInput> | PlayerCreateWithoutPracticeSquadTeamInput[] | PlayerUncheckedCreateWithoutPracticeSquadTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutPracticeSquadTeamInput | PlayerCreateOrConnectWithoutPracticeSquadTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutPracticeSquadTeamInput | PlayerUpsertWithWhereUniqueWithoutPracticeSquadTeamInput[]
    createMany?: PlayerCreateManyPracticeSquadTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutPracticeSquadTeamInput | PlayerUpdateWithWhereUniqueWithoutPracticeSquadTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutPracticeSquadTeamInput | PlayerUpdateManyWithWhereWithoutPracticeSquadTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutInjuredReserveTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutInjuredReserveTeamInput, PlayerUncheckedCreateWithoutInjuredReserveTeamInput> | PlayerCreateWithoutInjuredReserveTeamInput[] | PlayerUncheckedCreateWithoutInjuredReserveTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutInjuredReserveTeamInput | PlayerCreateOrConnectWithoutInjuredReserveTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutInjuredReserveTeamInput | PlayerUpsertWithWhereUniqueWithoutInjuredReserveTeamInput[]
    createMany?: PlayerCreateManyInjuredReserveTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutInjuredReserveTeamInput | PlayerUpdateWithWhereUniqueWithoutInjuredReserveTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutInjuredReserveTeamInput | PlayerUpdateManyWithWhereWithoutInjuredReserveTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutSuspendedListTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutSuspendedListTeamInput, PlayerUncheckedCreateWithoutSuspendedListTeamInput> | PlayerCreateWithoutSuspendedListTeamInput[] | PlayerUncheckedCreateWithoutSuspendedListTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutSuspendedListTeamInput | PlayerCreateOrConnectWithoutSuspendedListTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutSuspendedListTeamInput | PlayerUpsertWithWhereUniqueWithoutSuspendedListTeamInput[]
    createMany?: PlayerCreateManySuspendedListTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutSuspendedListTeamInput | PlayerUpdateWithWhereUniqueWithoutSuspendedListTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutSuspendedListTeamInput | PlayerUpdateManyWithWhereWithoutSuspendedListTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerContractUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerContractCreateWithoutTeamInput, PlayerContractUncheckedCreateWithoutTeamInput> | PlayerContractCreateWithoutTeamInput[] | PlayerContractUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerContractCreateOrConnectWithoutTeamInput | PlayerContractCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerContractUpsertWithWhereUniqueWithoutTeamInput | PlayerContractUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerContractCreateManyTeamInputEnvelope
    set?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    disconnect?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    delete?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    connect?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    update?: PlayerContractUpdateWithWhereUniqueWithoutTeamInput | PlayerContractUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerContractUpdateManyWithWhereWithoutTeamInput | PlayerContractUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerContractScalarWhereInput | PlayerContractScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutTeamInput | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutTeamInput | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutTeamInput | PlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutPracticeSquadTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutPracticeSquadTeamInput, PlayerUncheckedCreateWithoutPracticeSquadTeamInput> | PlayerCreateWithoutPracticeSquadTeamInput[] | PlayerUncheckedCreateWithoutPracticeSquadTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutPracticeSquadTeamInput | PlayerCreateOrConnectWithoutPracticeSquadTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutPracticeSquadTeamInput | PlayerUpsertWithWhereUniqueWithoutPracticeSquadTeamInput[]
    createMany?: PlayerCreateManyPracticeSquadTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutPracticeSquadTeamInput | PlayerUpdateWithWhereUniqueWithoutPracticeSquadTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutPracticeSquadTeamInput | PlayerUpdateManyWithWhereWithoutPracticeSquadTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutInjuredReserveTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutInjuredReserveTeamInput, PlayerUncheckedCreateWithoutInjuredReserveTeamInput> | PlayerCreateWithoutInjuredReserveTeamInput[] | PlayerUncheckedCreateWithoutInjuredReserveTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutInjuredReserveTeamInput | PlayerCreateOrConnectWithoutInjuredReserveTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutInjuredReserveTeamInput | PlayerUpsertWithWhereUniqueWithoutInjuredReserveTeamInput[]
    createMany?: PlayerCreateManyInjuredReserveTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutInjuredReserveTeamInput | PlayerUpdateWithWhereUniqueWithoutInjuredReserveTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutInjuredReserveTeamInput | PlayerUpdateManyWithWhereWithoutInjuredReserveTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutSuspendedListTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutSuspendedListTeamInput, PlayerUncheckedCreateWithoutSuspendedListTeamInput> | PlayerCreateWithoutSuspendedListTeamInput[] | PlayerUncheckedCreateWithoutSuspendedListTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutSuspendedListTeamInput | PlayerCreateOrConnectWithoutSuspendedListTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutSuspendedListTeamInput | PlayerUpsertWithWhereUniqueWithoutSuspendedListTeamInput[]
    createMany?: PlayerCreateManySuspendedListTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutSuspendedListTeamInput | PlayerUpdateWithWhereUniqueWithoutSuspendedListTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutSuspendedListTeamInput | PlayerUpdateManyWithWhereWithoutSuspendedListTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerContractUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerContractCreateWithoutTeamInput, PlayerContractUncheckedCreateWithoutTeamInput> | PlayerContractCreateWithoutTeamInput[] | PlayerContractUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerContractCreateOrConnectWithoutTeamInput | PlayerContractCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerContractUpsertWithWhereUniqueWithoutTeamInput | PlayerContractUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerContractCreateManyTeamInputEnvelope
    set?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    disconnect?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    delete?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    connect?: PlayerContractWhereUniqueInput | PlayerContractWhereUniqueInput[]
    update?: PlayerContractUpdateWithWhereUniqueWithoutTeamInput | PlayerContractUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerContractUpdateManyWithWhereWithoutTeamInput | PlayerContractUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerContractScalarWhereInput | PlayerContractScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutCurrentContractInput = {
    create?: XOR<PlayerCreateWithoutCurrentContractInput, PlayerUncheckedCreateWithoutCurrentContractInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentContractInput
    connect?: PlayerWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutPlayerContractsInput = {
    create?: XOR<TeamCreateWithoutPlayerContractsInput, TeamUncheckedCreateWithoutPlayerContractsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayerContractsInput
    connect?: TeamWhereUniqueInput
  }

  export type ContractBonusCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractBonusCreateWithoutContractInput, ContractBonusUncheckedCreateWithoutContractInput> | ContractBonusCreateWithoutContractInput[] | ContractBonusUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractBonusCreateOrConnectWithoutContractInput | ContractBonusCreateOrConnectWithoutContractInput[]
    createMany?: ContractBonusCreateManyContractInputEnvelope
    connect?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
  }

  export type SalaryByYearCreateNestedManyWithoutContractInput = {
    create?: XOR<SalaryByYearCreateWithoutContractInput, SalaryByYearUncheckedCreateWithoutContractInput> | SalaryByYearCreateWithoutContractInput[] | SalaryByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: SalaryByYearCreateOrConnectWithoutContractInput | SalaryByYearCreateOrConnectWithoutContractInput[]
    createMany?: SalaryByYearCreateManyContractInputEnvelope
    connect?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
  }

  export type CapHitByYearCreateNestedManyWithoutContractInput = {
    create?: XOR<CapHitByYearCreateWithoutContractInput, CapHitByYearUncheckedCreateWithoutContractInput> | CapHitByYearCreateWithoutContractInput[] | CapHitByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: CapHitByYearCreateOrConnectWithoutContractInput | CapHitByYearCreateOrConnectWithoutContractInput[]
    createMany?: CapHitByYearCreateManyContractInputEnvelope
    connect?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
  }

  export type DeadCapByYearCreateNestedManyWithoutContractInput = {
    create?: XOR<DeadCapByYearCreateWithoutContractInput, DeadCapByYearUncheckedCreateWithoutContractInput> | DeadCapByYearCreateWithoutContractInput[] | DeadCapByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DeadCapByYearCreateOrConnectWithoutContractInput | DeadCapByYearCreateOrConnectWithoutContractInput[]
    createMany?: DeadCapByYearCreateManyContractInputEnvelope
    connect?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
  }

  export type OptOutYearCreateNestedManyWithoutContractInput = {
    create?: XOR<OptOutYearCreateWithoutContractInput, OptOutYearUncheckedCreateWithoutContractInput> | OptOutYearCreateWithoutContractInput[] | OptOutYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: OptOutYearCreateOrConnectWithoutContractInput | OptOutYearCreateOrConnectWithoutContractInput[]
    createMany?: OptOutYearCreateManyContractInputEnvelope
    connect?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
  }

  export type RestructureEventCreateNestedManyWithoutContractInput = {
    create?: XOR<RestructureEventCreateWithoutContractInput, RestructureEventUncheckedCreateWithoutContractInput> | RestructureEventCreateWithoutContractInput[] | RestructureEventUncheckedCreateWithoutContractInput[]
    connectOrCreate?: RestructureEventCreateOrConnectWithoutContractInput | RestructureEventCreateOrConnectWithoutContractInput[]
    createMany?: RestructureEventCreateManyContractInputEnvelope
    connect?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
  }

  export type ContractClauseCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractClauseCreateWithoutContractInput, ContractClauseUncheckedCreateWithoutContractInput> | ContractClauseCreateWithoutContractInput[] | ContractClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractClauseCreateOrConnectWithoutContractInput | ContractClauseCreateOrConnectWithoutContractInput[]
    createMany?: ContractClauseCreateManyContractInputEnvelope
    connect?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
  }

  export type ContractBonusUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractBonusCreateWithoutContractInput, ContractBonusUncheckedCreateWithoutContractInput> | ContractBonusCreateWithoutContractInput[] | ContractBonusUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractBonusCreateOrConnectWithoutContractInput | ContractBonusCreateOrConnectWithoutContractInput[]
    createMany?: ContractBonusCreateManyContractInputEnvelope
    connect?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
  }

  export type SalaryByYearUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<SalaryByYearCreateWithoutContractInput, SalaryByYearUncheckedCreateWithoutContractInput> | SalaryByYearCreateWithoutContractInput[] | SalaryByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: SalaryByYearCreateOrConnectWithoutContractInput | SalaryByYearCreateOrConnectWithoutContractInput[]
    createMany?: SalaryByYearCreateManyContractInputEnvelope
    connect?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
  }

  export type CapHitByYearUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<CapHitByYearCreateWithoutContractInput, CapHitByYearUncheckedCreateWithoutContractInput> | CapHitByYearCreateWithoutContractInput[] | CapHitByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: CapHitByYearCreateOrConnectWithoutContractInput | CapHitByYearCreateOrConnectWithoutContractInput[]
    createMany?: CapHitByYearCreateManyContractInputEnvelope
    connect?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
  }

  export type DeadCapByYearUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<DeadCapByYearCreateWithoutContractInput, DeadCapByYearUncheckedCreateWithoutContractInput> | DeadCapByYearCreateWithoutContractInput[] | DeadCapByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DeadCapByYearCreateOrConnectWithoutContractInput | DeadCapByYearCreateOrConnectWithoutContractInput[]
    createMany?: DeadCapByYearCreateManyContractInputEnvelope
    connect?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
  }

  export type OptOutYearUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<OptOutYearCreateWithoutContractInput, OptOutYearUncheckedCreateWithoutContractInput> | OptOutYearCreateWithoutContractInput[] | OptOutYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: OptOutYearCreateOrConnectWithoutContractInput | OptOutYearCreateOrConnectWithoutContractInput[]
    createMany?: OptOutYearCreateManyContractInputEnvelope
    connect?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
  }

  export type RestructureEventUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<RestructureEventCreateWithoutContractInput, RestructureEventUncheckedCreateWithoutContractInput> | RestructureEventCreateWithoutContractInput[] | RestructureEventUncheckedCreateWithoutContractInput[]
    connectOrCreate?: RestructureEventCreateOrConnectWithoutContractInput | RestructureEventCreateOrConnectWithoutContractInput[]
    createMany?: RestructureEventCreateManyContractInputEnvelope
    connect?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
  }

  export type ContractClauseUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractClauseCreateWithoutContractInput, ContractClauseUncheckedCreateWithoutContractInput> | ContractClauseCreateWithoutContractInput[] | ContractClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractClauseCreateOrConnectWithoutContractInput | ContractClauseCreateOrConnectWithoutContractInput[]
    createMany?: ContractClauseCreateManyContractInputEnvelope
    connect?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PlayerUpdateOneWithoutCurrentContractNestedInput = {
    create?: XOR<PlayerCreateWithoutCurrentContractInput, PlayerUncheckedCreateWithoutCurrentContractInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentContractInput
    upsert?: PlayerUpsertWithoutCurrentContractInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCurrentContractInput, PlayerUpdateWithoutCurrentContractInput>, PlayerUncheckedUpdateWithoutCurrentContractInput>
  }

  export type TeamUpdateOneWithoutPlayerContractsNestedInput = {
    create?: XOR<TeamCreateWithoutPlayerContractsInput, TeamUncheckedCreateWithoutPlayerContractsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayerContractsInput
    upsert?: TeamUpsertWithoutPlayerContractsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlayerContractsInput, TeamUpdateWithoutPlayerContractsInput>, TeamUncheckedUpdateWithoutPlayerContractsInput>
  }

  export type ContractBonusUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractBonusCreateWithoutContractInput, ContractBonusUncheckedCreateWithoutContractInput> | ContractBonusCreateWithoutContractInput[] | ContractBonusUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractBonusCreateOrConnectWithoutContractInput | ContractBonusCreateOrConnectWithoutContractInput[]
    upsert?: ContractBonusUpsertWithWhereUniqueWithoutContractInput | ContractBonusUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractBonusCreateManyContractInputEnvelope
    set?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    disconnect?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    delete?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    connect?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    update?: ContractBonusUpdateWithWhereUniqueWithoutContractInput | ContractBonusUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractBonusUpdateManyWithWhereWithoutContractInput | ContractBonusUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractBonusScalarWhereInput | ContractBonusScalarWhereInput[]
  }

  export type SalaryByYearUpdateManyWithoutContractNestedInput = {
    create?: XOR<SalaryByYearCreateWithoutContractInput, SalaryByYearUncheckedCreateWithoutContractInput> | SalaryByYearCreateWithoutContractInput[] | SalaryByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: SalaryByYearCreateOrConnectWithoutContractInput | SalaryByYearCreateOrConnectWithoutContractInput[]
    upsert?: SalaryByYearUpsertWithWhereUniqueWithoutContractInput | SalaryByYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: SalaryByYearCreateManyContractInputEnvelope
    set?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    disconnect?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    delete?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    connect?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    update?: SalaryByYearUpdateWithWhereUniqueWithoutContractInput | SalaryByYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: SalaryByYearUpdateManyWithWhereWithoutContractInput | SalaryByYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: SalaryByYearScalarWhereInput | SalaryByYearScalarWhereInput[]
  }

  export type CapHitByYearUpdateManyWithoutContractNestedInput = {
    create?: XOR<CapHitByYearCreateWithoutContractInput, CapHitByYearUncheckedCreateWithoutContractInput> | CapHitByYearCreateWithoutContractInput[] | CapHitByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: CapHitByYearCreateOrConnectWithoutContractInput | CapHitByYearCreateOrConnectWithoutContractInput[]
    upsert?: CapHitByYearUpsertWithWhereUniqueWithoutContractInput | CapHitByYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: CapHitByYearCreateManyContractInputEnvelope
    set?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    disconnect?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    delete?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    connect?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    update?: CapHitByYearUpdateWithWhereUniqueWithoutContractInput | CapHitByYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: CapHitByYearUpdateManyWithWhereWithoutContractInput | CapHitByYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: CapHitByYearScalarWhereInput | CapHitByYearScalarWhereInput[]
  }

  export type DeadCapByYearUpdateManyWithoutContractNestedInput = {
    create?: XOR<DeadCapByYearCreateWithoutContractInput, DeadCapByYearUncheckedCreateWithoutContractInput> | DeadCapByYearCreateWithoutContractInput[] | DeadCapByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DeadCapByYearCreateOrConnectWithoutContractInput | DeadCapByYearCreateOrConnectWithoutContractInput[]
    upsert?: DeadCapByYearUpsertWithWhereUniqueWithoutContractInput | DeadCapByYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: DeadCapByYearCreateManyContractInputEnvelope
    set?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    disconnect?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    delete?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    connect?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    update?: DeadCapByYearUpdateWithWhereUniqueWithoutContractInput | DeadCapByYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: DeadCapByYearUpdateManyWithWhereWithoutContractInput | DeadCapByYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: DeadCapByYearScalarWhereInput | DeadCapByYearScalarWhereInput[]
  }

  export type OptOutYearUpdateManyWithoutContractNestedInput = {
    create?: XOR<OptOutYearCreateWithoutContractInput, OptOutYearUncheckedCreateWithoutContractInput> | OptOutYearCreateWithoutContractInput[] | OptOutYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: OptOutYearCreateOrConnectWithoutContractInput | OptOutYearCreateOrConnectWithoutContractInput[]
    upsert?: OptOutYearUpsertWithWhereUniqueWithoutContractInput | OptOutYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: OptOutYearCreateManyContractInputEnvelope
    set?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    disconnect?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    delete?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    connect?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    update?: OptOutYearUpdateWithWhereUniqueWithoutContractInput | OptOutYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: OptOutYearUpdateManyWithWhereWithoutContractInput | OptOutYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: OptOutYearScalarWhereInput | OptOutYearScalarWhereInput[]
  }

  export type RestructureEventUpdateManyWithoutContractNestedInput = {
    create?: XOR<RestructureEventCreateWithoutContractInput, RestructureEventUncheckedCreateWithoutContractInput> | RestructureEventCreateWithoutContractInput[] | RestructureEventUncheckedCreateWithoutContractInput[]
    connectOrCreate?: RestructureEventCreateOrConnectWithoutContractInput | RestructureEventCreateOrConnectWithoutContractInput[]
    upsert?: RestructureEventUpsertWithWhereUniqueWithoutContractInput | RestructureEventUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: RestructureEventCreateManyContractInputEnvelope
    set?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    disconnect?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    delete?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    connect?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    update?: RestructureEventUpdateWithWhereUniqueWithoutContractInput | RestructureEventUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: RestructureEventUpdateManyWithWhereWithoutContractInput | RestructureEventUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: RestructureEventScalarWhereInput | RestructureEventScalarWhereInput[]
  }

  export type ContractClauseUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractClauseCreateWithoutContractInput, ContractClauseUncheckedCreateWithoutContractInput> | ContractClauseCreateWithoutContractInput[] | ContractClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractClauseCreateOrConnectWithoutContractInput | ContractClauseCreateOrConnectWithoutContractInput[]
    upsert?: ContractClauseUpsertWithWhereUniqueWithoutContractInput | ContractClauseUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractClauseCreateManyContractInputEnvelope
    set?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    disconnect?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    delete?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    connect?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    update?: ContractClauseUpdateWithWhereUniqueWithoutContractInput | ContractClauseUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractClauseUpdateManyWithWhereWithoutContractInput | ContractClauseUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractClauseScalarWhereInput | ContractClauseScalarWhereInput[]
  }

  export type ContractBonusUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractBonusCreateWithoutContractInput, ContractBonusUncheckedCreateWithoutContractInput> | ContractBonusCreateWithoutContractInput[] | ContractBonusUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractBonusCreateOrConnectWithoutContractInput | ContractBonusCreateOrConnectWithoutContractInput[]
    upsert?: ContractBonusUpsertWithWhereUniqueWithoutContractInput | ContractBonusUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractBonusCreateManyContractInputEnvelope
    set?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    disconnect?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    delete?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    connect?: ContractBonusWhereUniqueInput | ContractBonusWhereUniqueInput[]
    update?: ContractBonusUpdateWithWhereUniqueWithoutContractInput | ContractBonusUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractBonusUpdateManyWithWhereWithoutContractInput | ContractBonusUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractBonusScalarWhereInput | ContractBonusScalarWhereInput[]
  }

  export type SalaryByYearUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<SalaryByYearCreateWithoutContractInput, SalaryByYearUncheckedCreateWithoutContractInput> | SalaryByYearCreateWithoutContractInput[] | SalaryByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: SalaryByYearCreateOrConnectWithoutContractInput | SalaryByYearCreateOrConnectWithoutContractInput[]
    upsert?: SalaryByYearUpsertWithWhereUniqueWithoutContractInput | SalaryByYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: SalaryByYearCreateManyContractInputEnvelope
    set?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    disconnect?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    delete?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    connect?: SalaryByYearWhereUniqueInput | SalaryByYearWhereUniqueInput[]
    update?: SalaryByYearUpdateWithWhereUniqueWithoutContractInput | SalaryByYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: SalaryByYearUpdateManyWithWhereWithoutContractInput | SalaryByYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: SalaryByYearScalarWhereInput | SalaryByYearScalarWhereInput[]
  }

  export type CapHitByYearUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<CapHitByYearCreateWithoutContractInput, CapHitByYearUncheckedCreateWithoutContractInput> | CapHitByYearCreateWithoutContractInput[] | CapHitByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: CapHitByYearCreateOrConnectWithoutContractInput | CapHitByYearCreateOrConnectWithoutContractInput[]
    upsert?: CapHitByYearUpsertWithWhereUniqueWithoutContractInput | CapHitByYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: CapHitByYearCreateManyContractInputEnvelope
    set?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    disconnect?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    delete?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    connect?: CapHitByYearWhereUniqueInput | CapHitByYearWhereUniqueInput[]
    update?: CapHitByYearUpdateWithWhereUniqueWithoutContractInput | CapHitByYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: CapHitByYearUpdateManyWithWhereWithoutContractInput | CapHitByYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: CapHitByYearScalarWhereInput | CapHitByYearScalarWhereInput[]
  }

  export type DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<DeadCapByYearCreateWithoutContractInput, DeadCapByYearUncheckedCreateWithoutContractInput> | DeadCapByYearCreateWithoutContractInput[] | DeadCapByYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DeadCapByYearCreateOrConnectWithoutContractInput | DeadCapByYearCreateOrConnectWithoutContractInput[]
    upsert?: DeadCapByYearUpsertWithWhereUniqueWithoutContractInput | DeadCapByYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: DeadCapByYearCreateManyContractInputEnvelope
    set?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    disconnect?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    delete?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    connect?: DeadCapByYearWhereUniqueInput | DeadCapByYearWhereUniqueInput[]
    update?: DeadCapByYearUpdateWithWhereUniqueWithoutContractInput | DeadCapByYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: DeadCapByYearUpdateManyWithWhereWithoutContractInput | DeadCapByYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: DeadCapByYearScalarWhereInput | DeadCapByYearScalarWhereInput[]
  }

  export type OptOutYearUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<OptOutYearCreateWithoutContractInput, OptOutYearUncheckedCreateWithoutContractInput> | OptOutYearCreateWithoutContractInput[] | OptOutYearUncheckedCreateWithoutContractInput[]
    connectOrCreate?: OptOutYearCreateOrConnectWithoutContractInput | OptOutYearCreateOrConnectWithoutContractInput[]
    upsert?: OptOutYearUpsertWithWhereUniqueWithoutContractInput | OptOutYearUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: OptOutYearCreateManyContractInputEnvelope
    set?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    disconnect?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    delete?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    connect?: OptOutYearWhereUniqueInput | OptOutYearWhereUniqueInput[]
    update?: OptOutYearUpdateWithWhereUniqueWithoutContractInput | OptOutYearUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: OptOutYearUpdateManyWithWhereWithoutContractInput | OptOutYearUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: OptOutYearScalarWhereInput | OptOutYearScalarWhereInput[]
  }

  export type RestructureEventUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<RestructureEventCreateWithoutContractInput, RestructureEventUncheckedCreateWithoutContractInput> | RestructureEventCreateWithoutContractInput[] | RestructureEventUncheckedCreateWithoutContractInput[]
    connectOrCreate?: RestructureEventCreateOrConnectWithoutContractInput | RestructureEventCreateOrConnectWithoutContractInput[]
    upsert?: RestructureEventUpsertWithWhereUniqueWithoutContractInput | RestructureEventUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: RestructureEventCreateManyContractInputEnvelope
    set?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    disconnect?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    delete?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    connect?: RestructureEventWhereUniqueInput | RestructureEventWhereUniqueInput[]
    update?: RestructureEventUpdateWithWhereUniqueWithoutContractInput | RestructureEventUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: RestructureEventUpdateManyWithWhereWithoutContractInput | RestructureEventUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: RestructureEventScalarWhereInput | RestructureEventScalarWhereInput[]
  }

  export type ContractClauseUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractClauseCreateWithoutContractInput, ContractClauseUncheckedCreateWithoutContractInput> | ContractClauseCreateWithoutContractInput[] | ContractClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractClauseCreateOrConnectWithoutContractInput | ContractClauseCreateOrConnectWithoutContractInput[]
    upsert?: ContractClauseUpsertWithWhereUniqueWithoutContractInput | ContractClauseUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractClauseCreateManyContractInputEnvelope
    set?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    disconnect?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    delete?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    connect?: ContractClauseWhereUniqueInput | ContractClauseWhereUniqueInput[]
    update?: ContractClauseUpdateWithWhereUniqueWithoutContractInput | ContractClauseUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractClauseUpdateManyWithWhereWithoutContractInput | ContractClauseUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractClauseScalarWhereInput | ContractClauseScalarWhereInput[]
  }

  export type PlayerContractCreateNestedOneWithoutBonusesInput = {
    create?: XOR<PlayerContractCreateWithoutBonusesInput, PlayerContractUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutBonusesInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PlayerContractUpdateOneRequiredWithoutBonusesNestedInput = {
    create?: XOR<PlayerContractCreateWithoutBonusesInput, PlayerContractUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutBonusesInput
    upsert?: PlayerContractUpsertWithoutBonusesInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutBonusesInput, PlayerContractUpdateWithoutBonusesInput>, PlayerContractUncheckedUpdateWithoutBonusesInput>
  }

  export type PlayerContractCreateNestedOneWithoutSalariesInput = {
    create?: XOR<PlayerContractCreateWithoutSalariesInput, PlayerContractUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutSalariesInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PlayerContractUpdateOneRequiredWithoutSalariesNestedInput = {
    create?: XOR<PlayerContractCreateWithoutSalariesInput, PlayerContractUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutSalariesInput
    upsert?: PlayerContractUpsertWithoutSalariesInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutSalariesInput, PlayerContractUpdateWithoutSalariesInput>, PlayerContractUncheckedUpdateWithoutSalariesInput>
  }

  export type PlayerContractCreateNestedOneWithoutCapHitsInput = {
    create?: XOR<PlayerContractCreateWithoutCapHitsInput, PlayerContractUncheckedCreateWithoutCapHitsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutCapHitsInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PlayerContractUpdateOneRequiredWithoutCapHitsNestedInput = {
    create?: XOR<PlayerContractCreateWithoutCapHitsInput, PlayerContractUncheckedCreateWithoutCapHitsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutCapHitsInput
    upsert?: PlayerContractUpsertWithoutCapHitsInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutCapHitsInput, PlayerContractUpdateWithoutCapHitsInput>, PlayerContractUncheckedUpdateWithoutCapHitsInput>
  }

  export type PlayerContractCreateNestedOneWithoutDeadCapsInput = {
    create?: XOR<PlayerContractCreateWithoutDeadCapsInput, PlayerContractUncheckedCreateWithoutDeadCapsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutDeadCapsInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PlayerContractUpdateOneRequiredWithoutDeadCapsNestedInput = {
    create?: XOR<PlayerContractCreateWithoutDeadCapsInput, PlayerContractUncheckedCreateWithoutDeadCapsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutDeadCapsInput
    upsert?: PlayerContractUpsertWithoutDeadCapsInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutDeadCapsInput, PlayerContractUpdateWithoutDeadCapsInput>, PlayerContractUncheckedUpdateWithoutDeadCapsInput>
  }

  export type PlayerContractCreateNestedOneWithoutOptOutYearsInput = {
    create?: XOR<PlayerContractCreateWithoutOptOutYearsInput, PlayerContractUncheckedCreateWithoutOptOutYearsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutOptOutYearsInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PlayerContractUpdateOneRequiredWithoutOptOutYearsNestedInput = {
    create?: XOR<PlayerContractCreateWithoutOptOutYearsInput, PlayerContractUncheckedCreateWithoutOptOutYearsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutOptOutYearsInput
    upsert?: PlayerContractUpsertWithoutOptOutYearsInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutOptOutYearsInput, PlayerContractUpdateWithoutOptOutYearsInput>, PlayerContractUncheckedUpdateWithoutOptOutYearsInput>
  }

  export type PlayerContractCreateNestedOneWithoutRestructureEventsInput = {
    create?: XOR<PlayerContractCreateWithoutRestructureEventsInput, PlayerContractUncheckedCreateWithoutRestructureEventsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutRestructureEventsInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PlayerContractUpdateOneRequiredWithoutRestructureEventsNestedInput = {
    create?: XOR<PlayerContractCreateWithoutRestructureEventsInput, PlayerContractUncheckedCreateWithoutRestructureEventsInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutRestructureEventsInput
    upsert?: PlayerContractUpsertWithoutRestructureEventsInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutRestructureEventsInput, PlayerContractUpdateWithoutRestructureEventsInput>, PlayerContractUncheckedUpdateWithoutRestructureEventsInput>
  }

  export type PlayerContractCreateNestedOneWithoutClausesInput = {
    create?: XOR<PlayerContractCreateWithoutClausesInput, PlayerContractUncheckedCreateWithoutClausesInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutClausesInput
    connect?: PlayerContractWhereUniqueInput
  }

  export type PerformanceBonusCreateNestedOneWithoutClausesInput = {
    create?: XOR<PerformanceBonusCreateWithoutClausesInput, PerformanceBonusUncheckedCreateWithoutClausesInput>
    connectOrCreate?: PerformanceBonusCreateOrConnectWithoutClausesInput
    connect?: PerformanceBonusWhereUniqueInput
  }

  export type RosterBonusCreateNestedOneWithoutClauseInput = {
    create?: XOR<RosterBonusCreateWithoutClauseInput, RosterBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: RosterBonusCreateOrConnectWithoutClauseInput
    connect?: RosterBonusWhereUniqueInput
  }

  export type WorkoutBonusCreateNestedOneWithoutClauseInput = {
    create?: XOR<WorkoutBonusCreateWithoutClauseInput, WorkoutBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: WorkoutBonusCreateOrConnectWithoutClauseInput
    connect?: WorkoutBonusWhereUniqueInput
  }

  export type OptionBonusCreateNestedOneWithoutClauseInput = {
    create?: XOR<OptionBonusCreateWithoutClauseInput, OptionBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: OptionBonusCreateOrConnectWithoutClauseInput
    connect?: OptionBonusWhereUniqueInput
  }

  export type PerformanceBonusUncheckedCreateNestedOneWithoutClausesInput = {
    create?: XOR<PerformanceBonusCreateWithoutClausesInput, PerformanceBonusUncheckedCreateWithoutClausesInput>
    connectOrCreate?: PerformanceBonusCreateOrConnectWithoutClausesInput
    connect?: PerformanceBonusWhereUniqueInput
  }

  export type RosterBonusUncheckedCreateNestedOneWithoutClauseInput = {
    create?: XOR<RosterBonusCreateWithoutClauseInput, RosterBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: RosterBonusCreateOrConnectWithoutClauseInput
    connect?: RosterBonusWhereUniqueInput
  }

  export type WorkoutBonusUncheckedCreateNestedOneWithoutClauseInput = {
    create?: XOR<WorkoutBonusCreateWithoutClauseInput, WorkoutBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: WorkoutBonusCreateOrConnectWithoutClauseInput
    connect?: WorkoutBonusWhereUniqueInput
  }

  export type OptionBonusUncheckedCreateNestedOneWithoutClauseInput = {
    create?: XOR<OptionBonusCreateWithoutClauseInput, OptionBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: OptionBonusCreateOrConnectWithoutClauseInput
    connect?: OptionBonusWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlayerContractUpdateOneRequiredWithoutClausesNestedInput = {
    create?: XOR<PlayerContractCreateWithoutClausesInput, PlayerContractUncheckedCreateWithoutClausesInput>
    connectOrCreate?: PlayerContractCreateOrConnectWithoutClausesInput
    upsert?: PlayerContractUpsertWithoutClausesInput
    connect?: PlayerContractWhereUniqueInput
    update?: XOR<XOR<PlayerContractUpdateToOneWithWhereWithoutClausesInput, PlayerContractUpdateWithoutClausesInput>, PlayerContractUncheckedUpdateWithoutClausesInput>
  }

  export type PerformanceBonusUpdateOneWithoutClausesNestedInput = {
    create?: XOR<PerformanceBonusCreateWithoutClausesInput, PerformanceBonusUncheckedCreateWithoutClausesInput>
    connectOrCreate?: PerformanceBonusCreateOrConnectWithoutClausesInput
    upsert?: PerformanceBonusUpsertWithoutClausesInput
    disconnect?: PerformanceBonusWhereInput | boolean
    delete?: PerformanceBonusWhereInput | boolean
    connect?: PerformanceBonusWhereUniqueInput
    update?: XOR<XOR<PerformanceBonusUpdateToOneWithWhereWithoutClausesInput, PerformanceBonusUpdateWithoutClausesInput>, PerformanceBonusUncheckedUpdateWithoutClausesInput>
  }

  export type RosterBonusUpdateOneWithoutClauseNestedInput = {
    create?: XOR<RosterBonusCreateWithoutClauseInput, RosterBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: RosterBonusCreateOrConnectWithoutClauseInput
    upsert?: RosterBonusUpsertWithoutClauseInput
    disconnect?: RosterBonusWhereInput | boolean
    delete?: RosterBonusWhereInput | boolean
    connect?: RosterBonusWhereUniqueInput
    update?: XOR<XOR<RosterBonusUpdateToOneWithWhereWithoutClauseInput, RosterBonusUpdateWithoutClauseInput>, RosterBonusUncheckedUpdateWithoutClauseInput>
  }

  export type WorkoutBonusUpdateOneWithoutClauseNestedInput = {
    create?: XOR<WorkoutBonusCreateWithoutClauseInput, WorkoutBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: WorkoutBonusCreateOrConnectWithoutClauseInput
    upsert?: WorkoutBonusUpsertWithoutClauseInput
    disconnect?: WorkoutBonusWhereInput | boolean
    delete?: WorkoutBonusWhereInput | boolean
    connect?: WorkoutBonusWhereUniqueInput
    update?: XOR<XOR<WorkoutBonusUpdateToOneWithWhereWithoutClauseInput, WorkoutBonusUpdateWithoutClauseInput>, WorkoutBonusUncheckedUpdateWithoutClauseInput>
  }

  export type OptionBonusUpdateOneWithoutClauseNestedInput = {
    create?: XOR<OptionBonusCreateWithoutClauseInput, OptionBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: OptionBonusCreateOrConnectWithoutClauseInput
    upsert?: OptionBonusUpsertWithoutClauseInput
    disconnect?: OptionBonusWhereInput | boolean
    delete?: OptionBonusWhereInput | boolean
    connect?: OptionBonusWhereUniqueInput
    update?: XOR<XOR<OptionBonusUpdateToOneWithWhereWithoutClauseInput, OptionBonusUpdateWithoutClauseInput>, OptionBonusUncheckedUpdateWithoutClauseInput>
  }

  export type PerformanceBonusUncheckedUpdateOneWithoutClausesNestedInput = {
    create?: XOR<PerformanceBonusCreateWithoutClausesInput, PerformanceBonusUncheckedCreateWithoutClausesInput>
    connectOrCreate?: PerformanceBonusCreateOrConnectWithoutClausesInput
    upsert?: PerformanceBonusUpsertWithoutClausesInput
    disconnect?: PerformanceBonusWhereInput | boolean
    delete?: PerformanceBonusWhereInput | boolean
    connect?: PerformanceBonusWhereUniqueInput
    update?: XOR<XOR<PerformanceBonusUpdateToOneWithWhereWithoutClausesInput, PerformanceBonusUpdateWithoutClausesInput>, PerformanceBonusUncheckedUpdateWithoutClausesInput>
  }

  export type RosterBonusUncheckedUpdateOneWithoutClauseNestedInput = {
    create?: XOR<RosterBonusCreateWithoutClauseInput, RosterBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: RosterBonusCreateOrConnectWithoutClauseInput
    upsert?: RosterBonusUpsertWithoutClauseInput
    disconnect?: RosterBonusWhereInput | boolean
    delete?: RosterBonusWhereInput | boolean
    connect?: RosterBonusWhereUniqueInput
    update?: XOR<XOR<RosterBonusUpdateToOneWithWhereWithoutClauseInput, RosterBonusUpdateWithoutClauseInput>, RosterBonusUncheckedUpdateWithoutClauseInput>
  }

  export type WorkoutBonusUncheckedUpdateOneWithoutClauseNestedInput = {
    create?: XOR<WorkoutBonusCreateWithoutClauseInput, WorkoutBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: WorkoutBonusCreateOrConnectWithoutClauseInput
    upsert?: WorkoutBonusUpsertWithoutClauseInput
    disconnect?: WorkoutBonusWhereInput | boolean
    delete?: WorkoutBonusWhereInput | boolean
    connect?: WorkoutBonusWhereUniqueInput
    update?: XOR<XOR<WorkoutBonusUpdateToOneWithWhereWithoutClauseInput, WorkoutBonusUpdateWithoutClauseInput>, WorkoutBonusUncheckedUpdateWithoutClauseInput>
  }

  export type OptionBonusUncheckedUpdateOneWithoutClauseNestedInput = {
    create?: XOR<OptionBonusCreateWithoutClauseInput, OptionBonusUncheckedCreateWithoutClauseInput>
    connectOrCreate?: OptionBonusCreateOrConnectWithoutClauseInput
    upsert?: OptionBonusUpsertWithoutClauseInput
    disconnect?: OptionBonusWhereInput | boolean
    delete?: OptionBonusWhereInput | boolean
    connect?: OptionBonusWhereUniqueInput
    update?: XOR<XOR<OptionBonusUpdateToOneWithWhereWithoutClauseInput, OptionBonusUpdateWithoutClauseInput>, OptionBonusUncheckedUpdateWithoutClauseInput>
  }

  export type ContractClauseCreateNestedOneWithoutPerformanceBonusInput = {
    create?: XOR<ContractClauseCreateWithoutPerformanceBonusInput, ContractClauseUncheckedCreateWithoutPerformanceBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutPerformanceBonusInput
    connect?: ContractClauseWhereUniqueInput
  }

  export type StatMilestoneCreateNestedOneWithoutPerformanceBonusInput = {
    create?: XOR<StatMilestoneCreateWithoutPerformanceBonusInput, StatMilestoneUncheckedCreateWithoutPerformanceBonusInput>
    connectOrCreate?: StatMilestoneCreateOrConnectWithoutPerformanceBonusInput
    connect?: StatMilestoneWhereUniqueInput
  }

  export type StatMilestoneUncheckedCreateNestedOneWithoutPerformanceBonusInput = {
    create?: XOR<StatMilestoneCreateWithoutPerformanceBonusInput, StatMilestoneUncheckedCreateWithoutPerformanceBonusInput>
    connectOrCreate?: StatMilestoneCreateOrConnectWithoutPerformanceBonusInput
    connect?: StatMilestoneWhereUniqueInput
  }

  export type ContractClauseUpdateOneRequiredWithoutPerformanceBonusNestedInput = {
    create?: XOR<ContractClauseCreateWithoutPerformanceBonusInput, ContractClauseUncheckedCreateWithoutPerformanceBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutPerformanceBonusInput
    upsert?: ContractClauseUpsertWithoutPerformanceBonusInput
    connect?: ContractClauseWhereUniqueInput
    update?: XOR<XOR<ContractClauseUpdateToOneWithWhereWithoutPerformanceBonusInput, ContractClauseUpdateWithoutPerformanceBonusInput>, ContractClauseUncheckedUpdateWithoutPerformanceBonusInput>
  }

  export type StatMilestoneUpdateOneWithoutPerformanceBonusNestedInput = {
    create?: XOR<StatMilestoneCreateWithoutPerformanceBonusInput, StatMilestoneUncheckedCreateWithoutPerformanceBonusInput>
    connectOrCreate?: StatMilestoneCreateOrConnectWithoutPerformanceBonusInput
    upsert?: StatMilestoneUpsertWithoutPerformanceBonusInput
    disconnect?: StatMilestoneWhereInput | boolean
    delete?: StatMilestoneWhereInput | boolean
    connect?: StatMilestoneWhereUniqueInput
    update?: XOR<XOR<StatMilestoneUpdateToOneWithWhereWithoutPerformanceBonusInput, StatMilestoneUpdateWithoutPerformanceBonusInput>, StatMilestoneUncheckedUpdateWithoutPerformanceBonusInput>
  }

  export type StatMilestoneUncheckedUpdateOneWithoutPerformanceBonusNestedInput = {
    create?: XOR<StatMilestoneCreateWithoutPerformanceBonusInput, StatMilestoneUncheckedCreateWithoutPerformanceBonusInput>
    connectOrCreate?: StatMilestoneCreateOrConnectWithoutPerformanceBonusInput
    upsert?: StatMilestoneUpsertWithoutPerformanceBonusInput
    disconnect?: StatMilestoneWhereInput | boolean
    delete?: StatMilestoneWhereInput | boolean
    connect?: StatMilestoneWhereUniqueInput
    update?: XOR<XOR<StatMilestoneUpdateToOneWithWhereWithoutPerformanceBonusInput, StatMilestoneUpdateWithoutPerformanceBonusInput>, StatMilestoneUncheckedUpdateWithoutPerformanceBonusInput>
  }

  export type PerformanceBonusCreateNestedOneWithoutStatMilestonesInput = {
    create?: XOR<PerformanceBonusCreateWithoutStatMilestonesInput, PerformanceBonusUncheckedCreateWithoutStatMilestonesInput>
    connectOrCreate?: PerformanceBonusCreateOrConnectWithoutStatMilestonesInput
    connect?: PerformanceBonusWhereUniqueInput
  }

  export type PerformanceBonusUpdateOneRequiredWithoutStatMilestonesNestedInput = {
    create?: XOR<PerformanceBonusCreateWithoutStatMilestonesInput, PerformanceBonusUncheckedCreateWithoutStatMilestonesInput>
    connectOrCreate?: PerformanceBonusCreateOrConnectWithoutStatMilestonesInput
    upsert?: PerformanceBonusUpsertWithoutStatMilestonesInput
    connect?: PerformanceBonusWhereUniqueInput
    update?: XOR<XOR<PerformanceBonusUpdateToOneWithWhereWithoutStatMilestonesInput, PerformanceBonusUpdateWithoutStatMilestonesInput>, PerformanceBonusUncheckedUpdateWithoutStatMilestonesInput>
  }

  export type ContractClauseCreateNestedOneWithoutRosterBonusInput = {
    create?: XOR<ContractClauseCreateWithoutRosterBonusInput, ContractClauseUncheckedCreateWithoutRosterBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutRosterBonusInput
    connect?: ContractClauseWhereUniqueInput
  }

  export type ContractClauseUpdateOneRequiredWithoutRosterBonusNestedInput = {
    create?: XOR<ContractClauseCreateWithoutRosterBonusInput, ContractClauseUncheckedCreateWithoutRosterBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutRosterBonusInput
    upsert?: ContractClauseUpsertWithoutRosterBonusInput
    connect?: ContractClauseWhereUniqueInput
    update?: XOR<XOR<ContractClauseUpdateToOneWithWhereWithoutRosterBonusInput, ContractClauseUpdateWithoutRosterBonusInput>, ContractClauseUncheckedUpdateWithoutRosterBonusInput>
  }

  export type ContractClauseCreateNestedOneWithoutWorkoutBonusInput = {
    create?: XOR<ContractClauseCreateWithoutWorkoutBonusInput, ContractClauseUncheckedCreateWithoutWorkoutBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutWorkoutBonusInput
    connect?: ContractClauseWhereUniqueInput
  }

  export type ContractClauseUpdateOneRequiredWithoutWorkoutBonusNestedInput = {
    create?: XOR<ContractClauseCreateWithoutWorkoutBonusInput, ContractClauseUncheckedCreateWithoutWorkoutBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutWorkoutBonusInput
    upsert?: ContractClauseUpsertWithoutWorkoutBonusInput
    connect?: ContractClauseWhereUniqueInput
    update?: XOR<XOR<ContractClauseUpdateToOneWithWhereWithoutWorkoutBonusInput, ContractClauseUpdateWithoutWorkoutBonusInput>, ContractClauseUncheckedUpdateWithoutWorkoutBonusInput>
  }

  export type ContractClauseCreateNestedOneWithoutOptionBonusInput = {
    create?: XOR<ContractClauseCreateWithoutOptionBonusInput, ContractClauseUncheckedCreateWithoutOptionBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutOptionBonusInput
    connect?: ContractClauseWhereUniqueInput
  }

  export type NullableEnumOptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.OptionType | null
  }

  export type ContractClauseUpdateOneRequiredWithoutOptionBonusNestedInput = {
    create?: XOR<ContractClauseCreateWithoutOptionBonusInput, ContractClauseUncheckedCreateWithoutOptionBonusInput>
    connectOrCreate?: ContractClauseCreateOrConnectWithoutOptionBonusInput
    upsert?: ContractClauseUpsertWithoutOptionBonusInput
    connect?: ContractClauseWhereUniqueInput
    update?: XOR<XOR<ContractClauseUpdateToOneWithWhereWithoutOptionBonusInput, ContractClauseUpdateWithoutOptionBonusInput>, ContractClauseUncheckedUpdateWithoutOptionBonusInput>
  }

  export type PlayerCreateNestedManyWithoutAgentInput = {
    create?: XOR<PlayerCreateWithoutAgentInput, PlayerUncheckedCreateWithoutAgentInput> | PlayerCreateWithoutAgentInput[] | PlayerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutAgentInput | PlayerCreateOrConnectWithoutAgentInput[]
    createMany?: PlayerCreateManyAgentInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<PlayerCreateWithoutAgentInput, PlayerUncheckedCreateWithoutAgentInput> | PlayerCreateWithoutAgentInput[] | PlayerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutAgentInput | PlayerCreateOrConnectWithoutAgentInput[]
    createMany?: PlayerCreateManyAgentInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PlayerCreateWithoutAgentInput, PlayerUncheckedCreateWithoutAgentInput> | PlayerCreateWithoutAgentInput[] | PlayerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutAgentInput | PlayerCreateOrConnectWithoutAgentInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutAgentInput | PlayerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PlayerCreateManyAgentInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutAgentInput | PlayerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutAgentInput | PlayerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PlayerCreateWithoutAgentInput, PlayerUncheckedCreateWithoutAgentInput> | PlayerCreateWithoutAgentInput[] | PlayerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutAgentInput | PlayerCreateOrConnectWithoutAgentInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutAgentInput | PlayerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PlayerCreateManyAgentInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutAgentInput | PlayerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutAgentInput | PlayerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutRatingsInput = {
    create?: XOR<PlayerCreateWithoutRatingsInput, PlayerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRatingsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUncheckedCreateNestedOneWithoutRatingsInput = {
    create?: XOR<PlayerCreateWithoutRatingsInput, PlayerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRatingsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<PlayerCreateWithoutRatingsInput, PlayerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRatingsInput
    upsert?: PlayerUpsertWithoutRatingsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRatingsInput, PlayerUpdateWithoutRatingsInput>, PlayerUncheckedUpdateWithoutRatingsInput>
  }

  export type PlayerUncheckedUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<PlayerCreateWithoutRatingsInput, PlayerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRatingsInput
    upsert?: PlayerUpsertWithoutRatingsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRatingsInput, PlayerUpdateWithoutRatingsInput>, PlayerUncheckedUpdateWithoutRatingsInput>
  }

  export type PlayerCreateNestedOneWithoutStatsInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUncheckedCreateNestedOneWithoutStatsInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneWithoutStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    upsert?: PlayerUpsertWithoutStatsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutStatsInput, PlayerUpdateWithoutStatsInput>, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type PlayerUncheckedUpdateOneWithoutStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    upsert?: PlayerUpsertWithoutStatsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutStatsInput, PlayerUpdateWithoutStatsInput>, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type ContractDesiresCreateoptOutYearsInput = {
    set: number[]
  }

  export type PlayerCreateNestedManyWithoutContractDesiresInput = {
    create?: XOR<PlayerCreateWithoutContractDesiresInput, PlayerUncheckedCreateWithoutContractDesiresInput> | PlayerCreateWithoutContractDesiresInput[] | PlayerUncheckedCreateWithoutContractDesiresInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutContractDesiresInput | PlayerCreateOrConnectWithoutContractDesiresInput[]
    createMany?: PlayerCreateManyContractDesiresInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutContractDesiresInput = {
    create?: XOR<PlayerCreateWithoutContractDesiresInput, PlayerUncheckedCreateWithoutContractDesiresInput> | PlayerCreateWithoutContractDesiresInput[] | PlayerUncheckedCreateWithoutContractDesiresInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutContractDesiresInput | PlayerCreateOrConnectWithoutContractDesiresInput[]
    createMany?: PlayerCreateManyContractDesiresInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type ContractDesiresUpdateoptOutYearsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type PlayerUpdateManyWithoutContractDesiresNestedInput = {
    create?: XOR<PlayerCreateWithoutContractDesiresInput, PlayerUncheckedCreateWithoutContractDesiresInput> | PlayerCreateWithoutContractDesiresInput[] | PlayerUncheckedCreateWithoutContractDesiresInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutContractDesiresInput | PlayerCreateOrConnectWithoutContractDesiresInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutContractDesiresInput | PlayerUpsertWithWhereUniqueWithoutContractDesiresInput[]
    createMany?: PlayerCreateManyContractDesiresInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutContractDesiresInput | PlayerUpdateWithWhereUniqueWithoutContractDesiresInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutContractDesiresInput | PlayerUpdateManyWithWhereWithoutContractDesiresInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutContractDesiresNestedInput = {
    create?: XOR<PlayerCreateWithoutContractDesiresInput, PlayerUncheckedCreateWithoutContractDesiresInput> | PlayerCreateWithoutContractDesiresInput[] | PlayerUncheckedCreateWithoutContractDesiresInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutContractDesiresInput | PlayerCreateOrConnectWithoutContractDesiresInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutContractDesiresInput | PlayerUpsertWithWhereUniqueWithoutContractDesiresInput[]
    createMany?: PlayerCreateManyContractDesiresInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutContractDesiresInput | PlayerUpdateWithWhereUniqueWithoutContractDesiresInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutContractDesiresInput | PlayerUpdateManyWithWhereWithoutContractDesiresInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerPositionEnum | EnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel> | $Enums.PlayerPositionEnum | null
  }

  export type NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRoleEnum | EnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel> | $Enums.PlayerRoleEnum | null
  }

  export type NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryTypeEnum | EnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel> | $Enums.InjuryTypeEnum | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractNegotiationStatusEnum | EnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel> | $Enums.ContractNegotiationStatusEnum | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlayerPositionEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerPositionEnum | EnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerPositionEnum[] | ListEnumPlayerPositionEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerPositionEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.PlayerPositionEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerPositionEnumNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlayerRoleEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRoleEnum | EnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlayerRoleEnum[] | ListEnumPlayerRoleEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerRoleEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.PlayerRoleEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerRoleEnumNullableFilter<$PrismaModel>
  }

  export type NestedEnumInjuryTypeEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryTypeEnum | EnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InjuryTypeEnum[] | ListEnumInjuryTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInjuryTypeEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.InjuryTypeEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumInjuryTypeEnumNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumContractNegotiationStatusEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractNegotiationStatusEnum | EnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractNegotiationStatusEnum[] | ListEnumContractNegotiationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractNegotiationStatusEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractNegotiationStatusEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumContractNegotiationStatusEnumNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDivisionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DivisionEnum | EnumDivisionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDivisionEnumFilter<$PrismaModel> | $Enums.DivisionEnum
  }

  export type NestedEnumConferenceEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceEnum | EnumConferenceEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceEnumFilter<$PrismaModel> | $Enums.ConferenceEnum
  }

  export type NestedEnumOffensiveSchemeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.OffensiveSchemeEnum | EnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumOffensiveSchemeEnumFilter<$PrismaModel> | $Enums.OffensiveSchemeEnum
  }

  export type NestedEnumDefensiveSchemeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DefensiveSchemeEnum | EnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefensiveSchemeEnumFilter<$PrismaModel> | $Enums.DefensiveSchemeEnum
  }

  export type NestedEnumFinancialHealthEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialHealthEnum | EnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialHealthEnumFilter<$PrismaModel> | $Enums.FinancialHealthEnum
  }

  export type NestedEnumDivisionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DivisionEnum | EnumDivisionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DivisionEnum[] | ListEnumDivisionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDivisionEnumWithAggregatesFilter<$PrismaModel> | $Enums.DivisionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDivisionEnumFilter<$PrismaModel>
    _max?: NestedEnumDivisionEnumFilter<$PrismaModel>
  }

  export type NestedEnumConferenceEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceEnum | EnumConferenceEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceEnum[] | ListEnumConferenceEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceEnumWithAggregatesFilter<$PrismaModel> | $Enums.ConferenceEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConferenceEnumFilter<$PrismaModel>
    _max?: NestedEnumConferenceEnumFilter<$PrismaModel>
  }

  export type NestedEnumOffensiveSchemeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OffensiveSchemeEnum | EnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.OffensiveSchemeEnum[] | ListEnumOffensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumOffensiveSchemeEnumWithAggregatesFilter<$PrismaModel> | $Enums.OffensiveSchemeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOffensiveSchemeEnumFilter<$PrismaModel>
    _max?: NestedEnumOffensiveSchemeEnumFilter<$PrismaModel>
  }

  export type NestedEnumDefensiveSchemeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefensiveSchemeEnum | EnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefensiveSchemeEnum[] | ListEnumDefensiveSchemeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefensiveSchemeEnumWithAggregatesFilter<$PrismaModel> | $Enums.DefensiveSchemeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefensiveSchemeEnumFilter<$PrismaModel>
    _max?: NestedEnumDefensiveSchemeEnumFilter<$PrismaModel>
  }

  export type NestedEnumFinancialHealthEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialHealthEnum | EnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialHealthEnum[] | ListEnumFinancialHealthEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialHealthEnumWithAggregatesFilter<$PrismaModel> | $Enums.FinancialHealthEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialHealthEnumFilter<$PrismaModel>
    _max?: NestedEnumFinancialHealthEnumFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumOptionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOptionTypeNullableFilter<$PrismaModel> | $Enums.OptionType | null
  }

  export type NestedEnumOptionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OptionType[] | ListEnumOptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOptionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OptionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOptionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOptionTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TeamCreateWithoutPlayersInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    practiceSquad?: PlayerCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutPlayersInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    practiceSquad?: PlayerUncheckedCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerUncheckedCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerUncheckedCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutPlayersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
  }

  export type TeamCreateWithoutPracticeSquadInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerCreateNestedManyWithoutTeamInput
    injuredReserve?: PlayerCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutPracticeSquadInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    injuredReserve?: PlayerUncheckedCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerUncheckedCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutPracticeSquadInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPracticeSquadInput, TeamUncheckedCreateWithoutPracticeSquadInput>
  }

  export type TeamCreateWithoutInjuredReserveInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerCreateNestedManyWithoutPracticeSquadTeamInput
    suspendedList?: PlayerCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutInjuredReserveInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerUncheckedCreateNestedManyWithoutPracticeSquadTeamInput
    suspendedList?: PlayerUncheckedCreateNestedManyWithoutSuspendedListTeamInput
    playerContracts?: PlayerContractUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutInjuredReserveInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutInjuredReserveInput, TeamUncheckedCreateWithoutInjuredReserveInput>
  }

  export type TeamCreateWithoutSuspendedListInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerCreateNestedManyWithoutInjuredReserveTeamInput
    playerContracts?: PlayerContractCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSuspendedListInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerUncheckedCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerUncheckedCreateNestedManyWithoutInjuredReserveTeamInput
    playerContracts?: PlayerContractUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSuspendedListInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSuspendedListInput, TeamUncheckedCreateWithoutSuspendedListInput>
  }

  export type PlayerContractCreateWithoutPlayerInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutPlayerInput = {
    id?: string
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutPlayerInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutPlayerInput, PlayerContractUncheckedCreateWithoutPlayerInput>
  }

  export type AgentCreateWithoutPlayersInput = {
    id?: string
    firstName: string
    lastName: string
    agencyName?: string | null
    reputation?: number | null
    yearsOfExperience?: number | null
  }

  export type AgentUncheckedCreateWithoutPlayersInput = {
    id?: string
    firstName: string
    lastName: string
    agencyName?: string | null
    reputation?: number | null
    yearsOfExperience?: number | null
  }

  export type AgentCreateOrConnectWithoutPlayersInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPlayersInput, AgentUncheckedCreateWithoutPlayersInput>
  }

  export type RatingCreateWithoutPlayerInput = {
    id?: string
    playerId?: string | null
    speed?: number | null
    acceleration?: number | null
    agility?: number | null
    changeOfDirection?: number | null
    strength?: number | null
    impactPower?: number | null
    verticalJump?: number | null
    stamina?: number | null
    toughness?: number | null
    awareness?: number | null
    discipline?: number | null
    injuryRecovery?: number | null
    throwPower?: number | null
    throwAccuracyShort?: number | null
    throwAccuracyMedium?: number | null
    throwAccuracyDeep?: number | null
    throwOnRun?: number | null
    playAction?: number | null
    pocketPresence?: number | null
    releaseTime?: number | null
    decisionMaking?: number | null
    scrambling?: number | null
    breakSack?: number | null
    fieldVision?: number | null
    ballSecurity?: number | null
    ballCarrierVision?: number | null
    breakTackle?: number | null
    topBallCarrierSpeed?: number | null
    trucking?: number | null
    elusiveness?: number | null
    stiffArm?: number | null
    spinMove?: number | null
    jukeMove?: number | null
    shortYardage?: number | null
    goalLine?: number | null
    openFieldRunning?: number | null
    catching?: number | null
    catchInTraffic?: number | null
    spectacularCatch?: number | null
    contestedCatches?: number | null
    yardsAfterCatch?: number | null
    jumpBallTiming?: number | null
    routeRunning?: number | null
    shortRoute?: number | null
    mediumRoute?: number | null
    deepRoute?: number | null
    separation?: number | null
    release?: number | null
    runBlocking?: number | null
    passBlocking?: number | null
    pullBlocking?: number | null
    scrambleBlocking?: number | null
    playActionBlocking?: number | null
    screenBlocking?: number | null
    leadBlocking?: number | null
    tackling?: number | null
    blockShedding?: number | null
    blitzing?: number | null
    playRecognition?: number | null
    openFieldTackling?: number | null
    coverageAgainstTEsRBs?: number | null
    coverageAgainstSlot?: number | null
    deepCoverage?: number | null
    runDefense?: number | null
    passRush?: number | null
    finessePassRush?: number | null
    powerPassRush?: number | null
    runStopping?: number | null
    penetration?: number | null
    edgeSetting?: number | null
    disengagement?: number | null
    offensiveLineRecognition?: number | null
    hitPower?: number | null
    pressCoverage?: number | null
    offBallCoverage?: number | null
    manCoverage?: number | null
    zoneCoverage?: number | null
    ballHawking?: number | null
    interceptions?: number | null
    passDeflection?: number | null
    kickPower?: number | null
    kickAccuracy?: number | null
    puntPower?: number | null
    puntAccuracy?: number | null
    onsideKickAbility?: number | null
    kickReturnVision?: number | null
    puntReturnVision?: number | null
  }

  export type RatingUncheckedCreateWithoutPlayerInput = {
    id?: string
    playerId?: string | null
    speed?: number | null
    acceleration?: number | null
    agility?: number | null
    changeOfDirection?: number | null
    strength?: number | null
    impactPower?: number | null
    verticalJump?: number | null
    stamina?: number | null
    toughness?: number | null
    awareness?: number | null
    discipline?: number | null
    injuryRecovery?: number | null
    throwPower?: number | null
    throwAccuracyShort?: number | null
    throwAccuracyMedium?: number | null
    throwAccuracyDeep?: number | null
    throwOnRun?: number | null
    playAction?: number | null
    pocketPresence?: number | null
    releaseTime?: number | null
    decisionMaking?: number | null
    scrambling?: number | null
    breakSack?: number | null
    fieldVision?: number | null
    ballSecurity?: number | null
    ballCarrierVision?: number | null
    breakTackle?: number | null
    topBallCarrierSpeed?: number | null
    trucking?: number | null
    elusiveness?: number | null
    stiffArm?: number | null
    spinMove?: number | null
    jukeMove?: number | null
    shortYardage?: number | null
    goalLine?: number | null
    openFieldRunning?: number | null
    catching?: number | null
    catchInTraffic?: number | null
    spectacularCatch?: number | null
    contestedCatches?: number | null
    yardsAfterCatch?: number | null
    jumpBallTiming?: number | null
    routeRunning?: number | null
    shortRoute?: number | null
    mediumRoute?: number | null
    deepRoute?: number | null
    separation?: number | null
    release?: number | null
    runBlocking?: number | null
    passBlocking?: number | null
    pullBlocking?: number | null
    scrambleBlocking?: number | null
    playActionBlocking?: number | null
    screenBlocking?: number | null
    leadBlocking?: number | null
    tackling?: number | null
    blockShedding?: number | null
    blitzing?: number | null
    playRecognition?: number | null
    openFieldTackling?: number | null
    coverageAgainstTEsRBs?: number | null
    coverageAgainstSlot?: number | null
    deepCoverage?: number | null
    runDefense?: number | null
    passRush?: number | null
    finessePassRush?: number | null
    powerPassRush?: number | null
    runStopping?: number | null
    penetration?: number | null
    edgeSetting?: number | null
    disengagement?: number | null
    offensiveLineRecognition?: number | null
    hitPower?: number | null
    pressCoverage?: number | null
    offBallCoverage?: number | null
    manCoverage?: number | null
    zoneCoverage?: number | null
    ballHawking?: number | null
    interceptions?: number | null
    passDeflection?: number | null
    kickPower?: number | null
    kickAccuracy?: number | null
    puntPower?: number | null
    puntAccuracy?: number | null
    onsideKickAbility?: number | null
    kickReturnVision?: number | null
    puntReturnVision?: number | null
  }

  export type RatingCreateOrConnectWithoutPlayerInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutPlayerInput, RatingUncheckedCreateWithoutPlayerInput>
  }

  export type StatCreateWithoutPlayerInput = {
    id?: string
    season?: number | null
    playerId?: string | null
    gamesPlayed?: number | null
    gamesStarted?: number | null
    snaps?: number | null
    rushingAttempts?: number | null
    rushingYards?: number | null
    yardsPerCarry?: number | null
    yardsAfterContact?: number | null
    yardsPerGame?: number | null
    rushingLong?: number | null
    rushingTouchdowns?: number | null
    fumblesLost?: number | null
    receptions?: number | null
    receivingYards?: number | null
    yardsPerReception?: number | null
    yardsAfterCatch?: number | null
    yardsPerTarget?: number | null
    airYards?: number | null
    receivingLong?: number | null
    targets?: number | null
    receivingTouchdowns?: number | null
    drops?: number | null
    passingAttempts?: number | null
    passingCompletions?: number | null
    passingYards?: number | null
    yardsPerPass?: number | null
    yardsPerCompletion?: number | null
    completionPercentage?: number | null
    passingTouchdowns?: number | null
    interceptions?: number | null
    sacksTaken?: number | null
    passerRating?: number | null
    pancakes?: number | null
    sacksAllowed?: number | null
    hurriesAllowed?: number | null
    tackles?: number | null
    tacklesForLoss?: number | null
    sacks?: number | null
    interceptionsMade?: number | null
    forcedFumbles?: number | null
    fumbleRecoveries?: number | null
    passesDefended?: number | null
    defensiveTouchdowns?: number | null
    fieldGoalsMade?: number | null
    fieldGoalsAttempted?: number | null
    extraPointsMade?: number | null
    extraPointsAttempted?: number | null
    punts?: number | null
    puntYards?: number | null
    kickReturns?: number | null
    kickReturnYards?: number | null
    puntReturns?: number | null
    puntReturnYards?: number | null
    specialTeamsTouchdowns?: number | null
    penaltiesCommitted?: number | null
    penaltyYards?: number | null
  }

  export type StatUncheckedCreateWithoutPlayerInput = {
    id?: string
    season?: number | null
    playerId?: string | null
    gamesPlayed?: number | null
    gamesStarted?: number | null
    snaps?: number | null
    rushingAttempts?: number | null
    rushingYards?: number | null
    yardsPerCarry?: number | null
    yardsAfterContact?: number | null
    yardsPerGame?: number | null
    rushingLong?: number | null
    rushingTouchdowns?: number | null
    fumblesLost?: number | null
    receptions?: number | null
    receivingYards?: number | null
    yardsPerReception?: number | null
    yardsAfterCatch?: number | null
    yardsPerTarget?: number | null
    airYards?: number | null
    receivingLong?: number | null
    targets?: number | null
    receivingTouchdowns?: number | null
    drops?: number | null
    passingAttempts?: number | null
    passingCompletions?: number | null
    passingYards?: number | null
    yardsPerPass?: number | null
    yardsPerCompletion?: number | null
    completionPercentage?: number | null
    passingTouchdowns?: number | null
    interceptions?: number | null
    sacksTaken?: number | null
    passerRating?: number | null
    pancakes?: number | null
    sacksAllowed?: number | null
    hurriesAllowed?: number | null
    tackles?: number | null
    tacklesForLoss?: number | null
    sacks?: number | null
    interceptionsMade?: number | null
    forcedFumbles?: number | null
    fumbleRecoveries?: number | null
    passesDefended?: number | null
    defensiveTouchdowns?: number | null
    fieldGoalsMade?: number | null
    fieldGoalsAttempted?: number | null
    extraPointsMade?: number | null
    extraPointsAttempted?: number | null
    punts?: number | null
    puntYards?: number | null
    kickReturns?: number | null
    kickReturnYards?: number | null
    puntReturns?: number | null
    puntReturnYards?: number | null
    specialTeamsTouchdowns?: number | null
    penaltiesCommitted?: number | null
    penaltyYards?: number | null
  }

  export type StatCreateOrConnectWithoutPlayerInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutPlayerInput, StatUncheckedCreateWithoutPlayerInput>
  }

  export type ContractDesiresCreateWithoutPlayerInput = {
    id?: string
    years?: number | null
    averageSalary?: number | null
    totalGuaranteed?: number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresCreateoptOutYearsInput | number[]
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    playerId?: string | null
  }

  export type ContractDesiresUncheckedCreateWithoutPlayerInput = {
    id?: string
    years?: number | null
    averageSalary?: number | null
    totalGuaranteed?: number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresCreateoptOutYearsInput | number[]
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    playerId?: string | null
  }

  export type ContractDesiresCreateOrConnectWithoutPlayerInput = {
    where: ContractDesiresWhereUniqueInput
    create: XOR<ContractDesiresCreateWithoutPlayerInput, ContractDesiresUncheckedCreateWithoutPlayerInput>
  }

  export type TeamUpsertWithoutPlayersInput = {
    update: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlayersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type TeamUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    practiceSquad?: PlayerUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    practiceSquad?: PlayerUncheckedUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUncheckedUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUncheckedUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutPracticeSquadInput = {
    update: XOR<TeamUpdateWithoutPracticeSquadInput, TeamUncheckedUpdateWithoutPracticeSquadInput>
    create: XOR<TeamCreateWithoutPracticeSquadInput, TeamUncheckedCreateWithoutPracticeSquadInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPracticeSquadInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPracticeSquadInput, TeamUncheckedUpdateWithoutPracticeSquadInput>
  }

  export type TeamUpdateWithoutPracticeSquadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUpdateManyWithoutTeamNestedInput
    injuredReserve?: PlayerUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPracticeSquadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    injuredReserve?: PlayerUncheckedUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUncheckedUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutInjuredReserveInput = {
    update: XOR<TeamUpdateWithoutInjuredReserveInput, TeamUncheckedUpdateWithoutInjuredReserveInput>
    create: XOR<TeamCreateWithoutInjuredReserveInput, TeamUncheckedCreateWithoutInjuredReserveInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutInjuredReserveInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutInjuredReserveInput, TeamUncheckedUpdateWithoutInjuredReserveInput>
  }

  export type TeamUpdateWithoutInjuredReserveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUpdateManyWithoutPracticeSquadTeamNestedInput
    suspendedList?: PlayerUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutInjuredReserveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUncheckedUpdateManyWithoutPracticeSquadTeamNestedInput
    suspendedList?: PlayerUncheckedUpdateManyWithoutSuspendedListTeamNestedInput
    playerContracts?: PlayerContractUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutSuspendedListInput = {
    update: XOR<TeamUpdateWithoutSuspendedListInput, TeamUncheckedUpdateWithoutSuspendedListInput>
    create: XOR<TeamCreateWithoutSuspendedListInput, TeamUncheckedCreateWithoutSuspendedListInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSuspendedListInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSuspendedListInput, TeamUncheckedUpdateWithoutSuspendedListInput>
  }

  export type TeamUpdateWithoutSuspendedListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUpdateManyWithoutInjuredReserveTeamNestedInput
    playerContracts?: PlayerContractUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSuspendedListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUncheckedUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUncheckedUpdateManyWithoutInjuredReserveTeamNestedInput
    playerContracts?: PlayerContractUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type PlayerContractUpsertWithoutPlayerInput = {
    update: XOR<PlayerContractUpdateWithoutPlayerInput, PlayerContractUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerContractCreateWithoutPlayerInput, PlayerContractUncheckedCreateWithoutPlayerInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutPlayerInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutPlayerInput, PlayerContractUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerContractUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type AgentUpsertWithoutPlayersInput = {
    update: XOR<AgentUpdateWithoutPlayersInput, AgentUncheckedUpdateWithoutPlayersInput>
    create: XOR<AgentCreateWithoutPlayersInput, AgentUncheckedCreateWithoutPlayersInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPlayersInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPlayersInput, AgentUncheckedUpdateWithoutPlayersInput>
  }

  export type AgentUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    agencyName?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableIntFieldUpdateOperationsInput | number | null
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgentUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    agencyName?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableIntFieldUpdateOperationsInput | number | null
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RatingUpsertWithoutPlayerInput = {
    update: XOR<RatingUpdateWithoutPlayerInput, RatingUncheckedUpdateWithoutPlayerInput>
    create: XOR<RatingCreateWithoutPlayerInput, RatingUncheckedCreateWithoutPlayerInput>
    where?: RatingWhereInput
  }

  export type RatingUpdateToOneWithWhereWithoutPlayerInput = {
    where?: RatingWhereInput
    data: XOR<RatingUpdateWithoutPlayerInput, RatingUncheckedUpdateWithoutPlayerInput>
  }

  export type RatingUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableIntFieldUpdateOperationsInput | number | null
    agility?: NullableIntFieldUpdateOperationsInput | number | null
    changeOfDirection?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: NullableIntFieldUpdateOperationsInput | number | null
    impactPower?: NullableIntFieldUpdateOperationsInput | number | null
    verticalJump?: NullableIntFieldUpdateOperationsInput | number | null
    stamina?: NullableIntFieldUpdateOperationsInput | number | null
    toughness?: NullableIntFieldUpdateOperationsInput | number | null
    awareness?: NullableIntFieldUpdateOperationsInput | number | null
    discipline?: NullableIntFieldUpdateOperationsInput | number | null
    injuryRecovery?: NullableIntFieldUpdateOperationsInput | number | null
    throwPower?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyShort?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyMedium?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyDeep?: NullableIntFieldUpdateOperationsInput | number | null
    throwOnRun?: NullableIntFieldUpdateOperationsInput | number | null
    playAction?: NullableIntFieldUpdateOperationsInput | number | null
    pocketPresence?: NullableIntFieldUpdateOperationsInput | number | null
    releaseTime?: NullableIntFieldUpdateOperationsInput | number | null
    decisionMaking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambling?: NullableIntFieldUpdateOperationsInput | number | null
    breakSack?: NullableIntFieldUpdateOperationsInput | number | null
    fieldVision?: NullableIntFieldUpdateOperationsInput | number | null
    ballSecurity?: NullableIntFieldUpdateOperationsInput | number | null
    ballCarrierVision?: NullableIntFieldUpdateOperationsInput | number | null
    breakTackle?: NullableIntFieldUpdateOperationsInput | number | null
    topBallCarrierSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    trucking?: NullableIntFieldUpdateOperationsInput | number | null
    elusiveness?: NullableIntFieldUpdateOperationsInput | number | null
    stiffArm?: NullableIntFieldUpdateOperationsInput | number | null
    spinMove?: NullableIntFieldUpdateOperationsInput | number | null
    jukeMove?: NullableIntFieldUpdateOperationsInput | number | null
    shortYardage?: NullableIntFieldUpdateOperationsInput | number | null
    goalLine?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldRunning?: NullableIntFieldUpdateOperationsInput | number | null
    catching?: NullableIntFieldUpdateOperationsInput | number | null
    catchInTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    spectacularCatch?: NullableIntFieldUpdateOperationsInput | number | null
    contestedCatches?: NullableIntFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    jumpBallTiming?: NullableIntFieldUpdateOperationsInput | number | null
    routeRunning?: NullableIntFieldUpdateOperationsInput | number | null
    shortRoute?: NullableIntFieldUpdateOperationsInput | number | null
    mediumRoute?: NullableIntFieldUpdateOperationsInput | number | null
    deepRoute?: NullableIntFieldUpdateOperationsInput | number | null
    separation?: NullableIntFieldUpdateOperationsInput | number | null
    release?: NullableIntFieldUpdateOperationsInput | number | null
    runBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    passBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    pullBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambleBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    playActionBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    screenBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    leadBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    tackling?: NullableIntFieldUpdateOperationsInput | number | null
    blockShedding?: NullableIntFieldUpdateOperationsInput | number | null
    blitzing?: NullableIntFieldUpdateOperationsInput | number | null
    playRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldTackling?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstTEsRBs?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstSlot?: NullableIntFieldUpdateOperationsInput | number | null
    deepCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    runDefense?: NullableIntFieldUpdateOperationsInput | number | null
    passRush?: NullableIntFieldUpdateOperationsInput | number | null
    finessePassRush?: NullableIntFieldUpdateOperationsInput | number | null
    powerPassRush?: NullableIntFieldUpdateOperationsInput | number | null
    runStopping?: NullableIntFieldUpdateOperationsInput | number | null
    penetration?: NullableIntFieldUpdateOperationsInput | number | null
    edgeSetting?: NullableIntFieldUpdateOperationsInput | number | null
    disengagement?: NullableIntFieldUpdateOperationsInput | number | null
    offensiveLineRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    hitPower?: NullableIntFieldUpdateOperationsInput | number | null
    pressCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    offBallCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    manCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    zoneCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    ballHawking?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    passDeflection?: NullableIntFieldUpdateOperationsInput | number | null
    kickPower?: NullableIntFieldUpdateOperationsInput | number | null
    kickAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    puntPower?: NullableIntFieldUpdateOperationsInput | number | null
    puntAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    onsideKickAbility?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RatingUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableIntFieldUpdateOperationsInput | number | null
    agility?: NullableIntFieldUpdateOperationsInput | number | null
    changeOfDirection?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: NullableIntFieldUpdateOperationsInput | number | null
    impactPower?: NullableIntFieldUpdateOperationsInput | number | null
    verticalJump?: NullableIntFieldUpdateOperationsInput | number | null
    stamina?: NullableIntFieldUpdateOperationsInput | number | null
    toughness?: NullableIntFieldUpdateOperationsInput | number | null
    awareness?: NullableIntFieldUpdateOperationsInput | number | null
    discipline?: NullableIntFieldUpdateOperationsInput | number | null
    injuryRecovery?: NullableIntFieldUpdateOperationsInput | number | null
    throwPower?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyShort?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyMedium?: NullableIntFieldUpdateOperationsInput | number | null
    throwAccuracyDeep?: NullableIntFieldUpdateOperationsInput | number | null
    throwOnRun?: NullableIntFieldUpdateOperationsInput | number | null
    playAction?: NullableIntFieldUpdateOperationsInput | number | null
    pocketPresence?: NullableIntFieldUpdateOperationsInput | number | null
    releaseTime?: NullableIntFieldUpdateOperationsInput | number | null
    decisionMaking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambling?: NullableIntFieldUpdateOperationsInput | number | null
    breakSack?: NullableIntFieldUpdateOperationsInput | number | null
    fieldVision?: NullableIntFieldUpdateOperationsInput | number | null
    ballSecurity?: NullableIntFieldUpdateOperationsInput | number | null
    ballCarrierVision?: NullableIntFieldUpdateOperationsInput | number | null
    breakTackle?: NullableIntFieldUpdateOperationsInput | number | null
    topBallCarrierSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    trucking?: NullableIntFieldUpdateOperationsInput | number | null
    elusiveness?: NullableIntFieldUpdateOperationsInput | number | null
    stiffArm?: NullableIntFieldUpdateOperationsInput | number | null
    spinMove?: NullableIntFieldUpdateOperationsInput | number | null
    jukeMove?: NullableIntFieldUpdateOperationsInput | number | null
    shortYardage?: NullableIntFieldUpdateOperationsInput | number | null
    goalLine?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldRunning?: NullableIntFieldUpdateOperationsInput | number | null
    catching?: NullableIntFieldUpdateOperationsInput | number | null
    catchInTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    spectacularCatch?: NullableIntFieldUpdateOperationsInput | number | null
    contestedCatches?: NullableIntFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    jumpBallTiming?: NullableIntFieldUpdateOperationsInput | number | null
    routeRunning?: NullableIntFieldUpdateOperationsInput | number | null
    shortRoute?: NullableIntFieldUpdateOperationsInput | number | null
    mediumRoute?: NullableIntFieldUpdateOperationsInput | number | null
    deepRoute?: NullableIntFieldUpdateOperationsInput | number | null
    separation?: NullableIntFieldUpdateOperationsInput | number | null
    release?: NullableIntFieldUpdateOperationsInput | number | null
    runBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    passBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    pullBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    scrambleBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    playActionBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    screenBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    leadBlocking?: NullableIntFieldUpdateOperationsInput | number | null
    tackling?: NullableIntFieldUpdateOperationsInput | number | null
    blockShedding?: NullableIntFieldUpdateOperationsInput | number | null
    blitzing?: NullableIntFieldUpdateOperationsInput | number | null
    playRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    openFieldTackling?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstTEsRBs?: NullableIntFieldUpdateOperationsInput | number | null
    coverageAgainstSlot?: NullableIntFieldUpdateOperationsInput | number | null
    deepCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    runDefense?: NullableIntFieldUpdateOperationsInput | number | null
    passRush?: NullableIntFieldUpdateOperationsInput | number | null
    finessePassRush?: NullableIntFieldUpdateOperationsInput | number | null
    powerPassRush?: NullableIntFieldUpdateOperationsInput | number | null
    runStopping?: NullableIntFieldUpdateOperationsInput | number | null
    penetration?: NullableIntFieldUpdateOperationsInput | number | null
    edgeSetting?: NullableIntFieldUpdateOperationsInput | number | null
    disengagement?: NullableIntFieldUpdateOperationsInput | number | null
    offensiveLineRecognition?: NullableIntFieldUpdateOperationsInput | number | null
    hitPower?: NullableIntFieldUpdateOperationsInput | number | null
    pressCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    offBallCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    manCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    zoneCoverage?: NullableIntFieldUpdateOperationsInput | number | null
    ballHawking?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    passDeflection?: NullableIntFieldUpdateOperationsInput | number | null
    kickPower?: NullableIntFieldUpdateOperationsInput | number | null
    kickAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    puntPower?: NullableIntFieldUpdateOperationsInput | number | null
    puntAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    onsideKickAbility?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnVision?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatUpsertWithoutPlayerInput = {
    update: XOR<StatUpdateWithoutPlayerInput, StatUncheckedUpdateWithoutPlayerInput>
    create: XOR<StatCreateWithoutPlayerInput, StatUncheckedCreateWithoutPlayerInput>
    where?: StatWhereInput
  }

  export type StatUpdateToOneWithWhereWithoutPlayerInput = {
    where?: StatWhereInput
    data: XOR<StatUpdateWithoutPlayerInput, StatUncheckedUpdateWithoutPlayerInput>
  }

  export type StatUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: NullableIntFieldUpdateOperationsInput | number | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    gamesStarted?: NullableIntFieldUpdateOperationsInput | number | null
    snaps?: NullableIntFieldUpdateOperationsInput | number | null
    rushingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    rushingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerCarry?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterContact?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerGame?: NullableFloatFieldUpdateOperationsInput | number | null
    rushingLong?: NullableIntFieldUpdateOperationsInput | number | null
    rushingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fumblesLost?: NullableIntFieldUpdateOperationsInput | number | null
    receptions?: NullableIntFieldUpdateOperationsInput | number | null
    receivingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerReception?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    airYards?: NullableIntFieldUpdateOperationsInput | number | null
    receivingLong?: NullableIntFieldUpdateOperationsInput | number | null
    targets?: NullableIntFieldUpdateOperationsInput | number | null
    receivingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    drops?: NullableIntFieldUpdateOperationsInput | number | null
    passingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    passingCompletions?: NullableIntFieldUpdateOperationsInput | number | null
    passingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerPass?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsPerCompletion?: NullableFloatFieldUpdateOperationsInput | number | null
    completionPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    sacksTaken?: NullableIntFieldUpdateOperationsInput | number | null
    passerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    pancakes?: NullableIntFieldUpdateOperationsInput | number | null
    sacksAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    hurriesAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    tackles?: NullableIntFieldUpdateOperationsInput | number | null
    tacklesForLoss?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptionsMade?: NullableIntFieldUpdateOperationsInput | number | null
    forcedFumbles?: NullableIntFieldUpdateOperationsInput | number | null
    fumbleRecoveries?: NullableIntFieldUpdateOperationsInput | number | null
    passesDefended?: NullableIntFieldUpdateOperationsInput | number | null
    defensiveTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsMade?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsMade?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    punts?: NullableIntFieldUpdateOperationsInput | number | null
    puntYards?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturns?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturns?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    specialTeamsTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    penaltiesCommitted?: NullableIntFieldUpdateOperationsInput | number | null
    penaltyYards?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: NullableIntFieldUpdateOperationsInput | number | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    gamesStarted?: NullableIntFieldUpdateOperationsInput | number | null
    snaps?: NullableIntFieldUpdateOperationsInput | number | null
    rushingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    rushingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerCarry?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterContact?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerGame?: NullableFloatFieldUpdateOperationsInput | number | null
    rushingLong?: NullableIntFieldUpdateOperationsInput | number | null
    rushingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fumblesLost?: NullableIntFieldUpdateOperationsInput | number | null
    receptions?: NullableIntFieldUpdateOperationsInput | number | null
    receivingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerReception?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsAfterCatch?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    airYards?: NullableIntFieldUpdateOperationsInput | number | null
    receivingLong?: NullableIntFieldUpdateOperationsInput | number | null
    targets?: NullableIntFieldUpdateOperationsInput | number | null
    receivingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    drops?: NullableIntFieldUpdateOperationsInput | number | null
    passingAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    passingCompletions?: NullableIntFieldUpdateOperationsInput | number | null
    passingYards?: NullableIntFieldUpdateOperationsInput | number | null
    yardsPerPass?: NullableFloatFieldUpdateOperationsInput | number | null
    yardsPerCompletion?: NullableFloatFieldUpdateOperationsInput | number | null
    completionPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passingTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
    sacksTaken?: NullableIntFieldUpdateOperationsInput | number | null
    passerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    pancakes?: NullableIntFieldUpdateOperationsInput | number | null
    sacksAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    hurriesAllowed?: NullableIntFieldUpdateOperationsInput | number | null
    tackles?: NullableIntFieldUpdateOperationsInput | number | null
    tacklesForLoss?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptionsMade?: NullableIntFieldUpdateOperationsInput | number | null
    forcedFumbles?: NullableIntFieldUpdateOperationsInput | number | null
    fumbleRecoveries?: NullableIntFieldUpdateOperationsInput | number | null
    passesDefended?: NullableIntFieldUpdateOperationsInput | number | null
    defensiveTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsMade?: NullableIntFieldUpdateOperationsInput | number | null
    fieldGoalsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsMade?: NullableIntFieldUpdateOperationsInput | number | null
    extraPointsAttempted?: NullableIntFieldUpdateOperationsInput | number | null
    punts?: NullableIntFieldUpdateOperationsInput | number | null
    puntYards?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturns?: NullableIntFieldUpdateOperationsInput | number | null
    kickReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturns?: NullableIntFieldUpdateOperationsInput | number | null
    puntReturnYards?: NullableIntFieldUpdateOperationsInput | number | null
    specialTeamsTouchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    penaltiesCommitted?: NullableIntFieldUpdateOperationsInput | number | null
    penaltyYards?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractDesiresUpsertWithoutPlayerInput = {
    update: XOR<ContractDesiresUpdateWithoutPlayerInput, ContractDesiresUncheckedUpdateWithoutPlayerInput>
    create: XOR<ContractDesiresCreateWithoutPlayerInput, ContractDesiresUncheckedCreateWithoutPlayerInput>
    where?: ContractDesiresWhereInput
  }

  export type ContractDesiresUpdateToOneWithWhereWithoutPlayerInput = {
    where?: ContractDesiresWhereInput
    data: XOR<ContractDesiresUpdateWithoutPlayerInput, ContractDesiresUncheckedUpdateWithoutPlayerInput>
  }

  export type ContractDesiresUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    years?: NullableIntFieldUpdateOperationsInput | number | null
    averageSalary?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresUpdateoptOutYearsInput | number[]
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractDesiresUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    years?: NullableIntFieldUpdateOperationsInput | number | null
    averageSalary?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    bonuses?: NullableJsonNullValueInput | InputJsonValue
    tradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rosterBonus?: NullableJsonNullValueInput | InputJsonValue
    workoutBonus?: NullableJsonNullValueInput | InputJsonValue
    incentives?: NullableJsonNullValueInput | InputJsonValue
    optOutYears?: ContractDesiresUpdateoptOutYearsInput | number[]
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerCreateWithoutTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput>
  }

  export type PlayerCreateManyTeamInputEnvelope = {
    data: PlayerCreateManyTeamInput | PlayerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutPracticeSquadTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPracticeSquadTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPracticeSquadTeamInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPracticeSquadTeamInput, PlayerUncheckedCreateWithoutPracticeSquadTeamInput>
  }

  export type PlayerCreateManyPracticeSquadTeamInputEnvelope = {
    data: PlayerCreateManyPracticeSquadTeamInput | PlayerCreateManyPracticeSquadTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutInjuredReserveTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutInjuredReserveTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutInjuredReserveTeamInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutInjuredReserveTeamInput, PlayerUncheckedCreateWithoutInjuredReserveTeamInput>
  }

  export type PlayerCreateManyInjuredReserveTeamInputEnvelope = {
    data: PlayerCreateManyInjuredReserveTeamInput | PlayerCreateManyInjuredReserveTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutSuspendedListTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSuspendedListTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSuspendedListTeamInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSuspendedListTeamInput, PlayerUncheckedCreateWithoutSuspendedListTeamInput>
  }

  export type PlayerCreateManySuspendedListTeamInputEnvelope = {
    data: PlayerCreateManySuspendedListTeamInput | PlayerCreateManySuspendedListTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerContractCreateWithoutTeamInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutTeamInput = {
    id?: string
    playerId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutTeamInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutTeamInput, PlayerContractUncheckedCreateWithoutTeamInput>
  }

  export type PlayerContractCreateManyTeamInputEnvelope = {
    data: PlayerContractCreateManyTeamInput | PlayerContractCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutTeamInput, PlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutTeamInput, PlayerUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerUpdateManyWithWhereWithoutTeamInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: StringFilter<"Player"> | string
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    age?: IntFilter<"Player"> | number
    college?: StringFilter<"Player"> | string
    heightInInches?: IntFilter<"Player"> | number
    weightInPounds?: IntFilter<"Player"> | number
    teamId?: StringNullableFilter<"Player"> | string | null
    practiceSquadTeamId?: StringNullableFilter<"Player"> | string | null
    injuredReserveTeamId?: StringNullableFilter<"Player"> | string | null
    suspendedListTeamId?: StringNullableFilter<"Player"> | string | null
    currentContractId?: StringNullableFilter<"Player"> | string | null
    agentId?: StringNullableFilter<"Player"> | string | null
    ratingsId?: StringNullableFilter<"Player"> | string | null
    statsId?: StringNullableFilter<"Player"> | string | null
    position?: EnumPlayerPositionEnumNullableFilter<"Player"> | $Enums.PlayerPositionEnum | null
    expectedRole?: EnumPlayerRoleEnumNullableFilter<"Player"> | $Enums.PlayerRoleEnum | null
    actualRole?: EnumPlayerRoleEnumNullableFilter<"Player"> | $Enums.PlayerRoleEnum | null
    recordsHeld?: EnumFootballRecordEnumNullableListFilter<"Player">
    currentInjury?: EnumInjuryTypeEnumNullableFilter<"Player"> | $Enums.InjuryTypeEnum | null
    injuryHistory?: EnumInjuryTypeEnumNullableListFilter<"Player">
    personalityTraits?: EnumPlayerPersonalityTraitEnumNullableListFilter<"Player">
    offFieldConcerns?: EnumOffFieldConcernTypeEnumNullableListFilter<"Player">
    pastEvents?: EnumPlayerEventEnumNullableListFilter<"Player">
    isStarter?: BoolFilter<"Player"> | boolean
    isCaptain?: BoolFilter<"Player"> | boolean
    isFreeAgent?: BoolFilter<"Player"> | boolean
    isRetired?: BoolFilter<"Player"> | boolean
    isSuspended?: BoolFilter<"Player"> | boolean
    isPracticeSquad?: BoolFilter<"Player"> | boolean
    isTradeBlock?: BoolFilter<"Player"> | boolean
    offense?: BoolFilter<"Player"> | boolean
    defense?: BoolFilter<"Player"> | boolean
    specialTeams?: BoolFilter<"Player"> | boolean
    draftYear?: IntNullableFilter<"Player"> | number | null
    draftRound?: IntNullableFilter<"Player"> | number | null
    isRecordHolder?: BoolFilter<"Player"> | boolean
    contractDesiresId?: StringNullableFilter<"Player"> | string | null
    contractNegotiationStatus?: EnumContractNegotiationStatusEnumNullableFilter<"Player"> | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: DateTimeNullableFilter<"Player"> | Date | string | null
    performanceRating?: IntNullableFilter<"Player"> | number | null
    impactRating?: IntNullableFilter<"Player"> | number | null
    potential?: IntNullableFilter<"Player"> | number | null
    experience?: IntNullableFilter<"Player"> | number | null
    isInjured?: BoolFilter<"Player"> | boolean
    injuryProneness?: BoolFilter<"Player"> | boolean
    expectedReturnFromInjury?: DateTimeNullableFilter<"Player"> | Date | string | null
    morale?: IntNullableFilter<"Player"> | number | null
    leadership?: IntNullableFilter<"Player"> | number | null
    adaptability?: IntNullableFilter<"Player"> | number | null
    workEthic?: IntNullableFilter<"Player"> | number | null
    consistency?: IntNullableFilter<"Player"> | number | null
    clutchFactor?: IntNullableFilter<"Player"> | number | null
    footballIQ?: IntNullableFilter<"Player"> | number | null
    popularity?: IntNullableFilter<"Player"> | number | null
    trainingFocus?: StringNullableFilter<"Player"> | string | null
    trainingProgress?: IntNullableFilter<"Player"> | number | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
  }

  export type PlayerUpsertWithWhereUniqueWithoutPracticeSquadTeamInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutPracticeSquadTeamInput, PlayerUncheckedUpdateWithoutPracticeSquadTeamInput>
    create: XOR<PlayerCreateWithoutPracticeSquadTeamInput, PlayerUncheckedCreateWithoutPracticeSquadTeamInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutPracticeSquadTeamInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutPracticeSquadTeamInput, PlayerUncheckedUpdateWithoutPracticeSquadTeamInput>
  }

  export type PlayerUpdateManyWithWhereWithoutPracticeSquadTeamInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPracticeSquadTeamInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutInjuredReserveTeamInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutInjuredReserveTeamInput, PlayerUncheckedUpdateWithoutInjuredReserveTeamInput>
    create: XOR<PlayerCreateWithoutInjuredReserveTeamInput, PlayerUncheckedCreateWithoutInjuredReserveTeamInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutInjuredReserveTeamInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutInjuredReserveTeamInput, PlayerUncheckedUpdateWithoutInjuredReserveTeamInput>
  }

  export type PlayerUpdateManyWithWhereWithoutInjuredReserveTeamInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutInjuredReserveTeamInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutSuspendedListTeamInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutSuspendedListTeamInput, PlayerUncheckedUpdateWithoutSuspendedListTeamInput>
    create: XOR<PlayerCreateWithoutSuspendedListTeamInput, PlayerUncheckedCreateWithoutSuspendedListTeamInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutSuspendedListTeamInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutSuspendedListTeamInput, PlayerUncheckedUpdateWithoutSuspendedListTeamInput>
  }

  export type PlayerUpdateManyWithWhereWithoutSuspendedListTeamInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutSuspendedListTeamInput>
  }

  export type PlayerContractUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlayerContractWhereUniqueInput
    update: XOR<PlayerContractUpdateWithoutTeamInput, PlayerContractUncheckedUpdateWithoutTeamInput>
    create: XOR<PlayerContractCreateWithoutTeamInput, PlayerContractUncheckedCreateWithoutTeamInput>
  }

  export type PlayerContractUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlayerContractWhereUniqueInput
    data: XOR<PlayerContractUpdateWithoutTeamInput, PlayerContractUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerContractUpdateManyWithWhereWithoutTeamInput = {
    where: PlayerContractScalarWhereInput
    data: XOR<PlayerContractUpdateManyMutationInput, PlayerContractUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlayerContractScalarWhereInput = {
    AND?: PlayerContractScalarWhereInput | PlayerContractScalarWhereInput[]
    OR?: PlayerContractScalarWhereInput[]
    NOT?: PlayerContractScalarWhereInput | PlayerContractScalarWhereInput[]
    id?: StringFilter<"PlayerContract"> | string
    playerId?: StringNullableFilter<"PlayerContract"> | string | null
    teamId?: StringNullableFilter<"PlayerContract"> | string | null
    signedDate?: DateTimeNullableFilter<"PlayerContract"> | Date | string | null
    startSeason?: IntNullableFilter<"PlayerContract"> | number | null
    endSeason?: IntNullableFilter<"PlayerContract"> | number | null
    totalValue?: IntNullableFilter<"PlayerContract"> | number | null
    averagePerYear?: IntNullableFilter<"PlayerContract"> | number | null
    totalGuaranteed?: IntNullableFilter<"PlayerContract"> | number | null
    isRookieContract?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isFranchiseTag?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isExtension?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isPlayerOptOut?: BoolNullableFilter<"PlayerContract"> | boolean | null
    isTeamOptOut?: BoolNullableFilter<"PlayerContract"> | boolean | null
    createdAt?: DateTimeFilter<"PlayerContract"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerContract"> | Date | string
  }

  export type PlayerCreateWithoutCurrentContractInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCurrentContractInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateOrConnectWithoutCurrentContractInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCurrentContractInput, PlayerUncheckedCreateWithoutCurrentContractInput>
  }

  export type TeamCreateWithoutPlayerContractsInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerCreateNestedManyWithoutSuspendedListTeamInput
  }

  export type TeamUncheckedCreateWithoutPlayerContractsInput = {
    id?: string
    name: string
    nickname: string
    location: string
    abbreviation: string
    logoUrl?: string | null
    division: $Enums.DivisionEnum
    conference: $Enums.ConferenceEnum
    overallRating: number
    offensiveScheme: $Enums.OffensiveSchemeEnum
    defensiveScheme: $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamCreateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins: number
    losses: number
    ties: number
    currentStreak: number
    longestWinningStreak: number
    playoffAppearances: number
    superBowlAppearances: number
    championships: number
    capSpace: number
    capLimit: number
    totalPayroll: number
    financialHealth: $Enums.FinancialHealthEnum
    yearFounded: number
    allTimeWins: number
    allTimeLosses: number
    allTimeTies: number
    retiredNumbers?: TeamCreateretiredNumbersInput | number[]
    fanBaseSize: number
    prestige: number
    rivalTeams?: TeamCreaterivalTeamsInput | string[]
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    practiceSquad?: PlayerUncheckedCreateNestedManyWithoutPracticeSquadTeamInput
    injuredReserve?: PlayerUncheckedCreateNestedManyWithoutInjuredReserveTeamInput
    suspendedList?: PlayerUncheckedCreateNestedManyWithoutSuspendedListTeamInput
  }

  export type TeamCreateOrConnectWithoutPlayerContractsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlayerContractsInput, TeamUncheckedCreateWithoutPlayerContractsInput>
  }

  export type ContractBonusCreateWithoutContractInput = {
    id?: string
    year: number
    signingBonus?: number | null
    rosterBonus?: number | null
    workoutBonus?: number | null
    incentiveBonus?: number | null
  }

  export type ContractBonusUncheckedCreateWithoutContractInput = {
    id?: string
    year: number
    signingBonus?: number | null
    rosterBonus?: number | null
    workoutBonus?: number | null
    incentiveBonus?: number | null
  }

  export type ContractBonusCreateOrConnectWithoutContractInput = {
    where: ContractBonusWhereUniqueInput
    create: XOR<ContractBonusCreateWithoutContractInput, ContractBonusUncheckedCreateWithoutContractInput>
  }

  export type ContractBonusCreateManyContractInputEnvelope = {
    data: ContractBonusCreateManyContractInput | ContractBonusCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type SalaryByYearCreateWithoutContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type SalaryByYearUncheckedCreateWithoutContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type SalaryByYearCreateOrConnectWithoutContractInput = {
    where: SalaryByYearWhereUniqueInput
    create: XOR<SalaryByYearCreateWithoutContractInput, SalaryByYearUncheckedCreateWithoutContractInput>
  }

  export type SalaryByYearCreateManyContractInputEnvelope = {
    data: SalaryByYearCreateManyContractInput | SalaryByYearCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type CapHitByYearCreateWithoutContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type CapHitByYearUncheckedCreateWithoutContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type CapHitByYearCreateOrConnectWithoutContractInput = {
    where: CapHitByYearWhereUniqueInput
    create: XOR<CapHitByYearCreateWithoutContractInput, CapHitByYearUncheckedCreateWithoutContractInput>
  }

  export type CapHitByYearCreateManyContractInputEnvelope = {
    data: CapHitByYearCreateManyContractInput | CapHitByYearCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type DeadCapByYearCreateWithoutContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type DeadCapByYearUncheckedCreateWithoutContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type DeadCapByYearCreateOrConnectWithoutContractInput = {
    where: DeadCapByYearWhereUniqueInput
    create: XOR<DeadCapByYearCreateWithoutContractInput, DeadCapByYearUncheckedCreateWithoutContractInput>
  }

  export type DeadCapByYearCreateManyContractInputEnvelope = {
    data: DeadCapByYearCreateManyContractInput | DeadCapByYearCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type OptOutYearCreateWithoutContractInput = {
    id?: string
    year: number
  }

  export type OptOutYearUncheckedCreateWithoutContractInput = {
    id?: string
    year: number
  }

  export type OptOutYearCreateOrConnectWithoutContractInput = {
    where: OptOutYearWhereUniqueInput
    create: XOR<OptOutYearCreateWithoutContractInput, OptOutYearUncheckedCreateWithoutContractInput>
  }

  export type OptOutYearCreateManyContractInputEnvelope = {
    data: OptOutYearCreateManyContractInput | OptOutYearCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type RestructureEventCreateWithoutContractInput = {
    id?: string
    year?: number | null
    date?: Date | string | null
    amountConvertedToBonus?: number | null
    newCapHit?: number | null
    newDeadCap?: number | null
  }

  export type RestructureEventUncheckedCreateWithoutContractInput = {
    id?: string
    year?: number | null
    date?: Date | string | null
    amountConvertedToBonus?: number | null
    newCapHit?: number | null
    newDeadCap?: number | null
  }

  export type RestructureEventCreateOrConnectWithoutContractInput = {
    where: RestructureEventWhereUniqueInput
    create: XOR<RestructureEventCreateWithoutContractInput, RestructureEventUncheckedCreateWithoutContractInput>
  }

  export type RestructureEventCreateManyContractInputEnvelope = {
    data: RestructureEventCreateManyContractInput | RestructureEventCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ContractClauseCreateWithoutContractInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    performanceBonus?: PerformanceBonusCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUncheckedCreateWithoutContractInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    performanceBonus?: PerformanceBonusUncheckedCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusUncheckedCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusUncheckedCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusUncheckedCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseCreateOrConnectWithoutContractInput = {
    where: ContractClauseWhereUniqueInput
    create: XOR<ContractClauseCreateWithoutContractInput, ContractClauseUncheckedCreateWithoutContractInput>
  }

  export type ContractClauseCreateManyContractInputEnvelope = {
    data: ContractClauseCreateManyContractInput | ContractClauseCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutCurrentContractInput = {
    update: XOR<PlayerUpdateWithoutCurrentContractInput, PlayerUncheckedUpdateWithoutCurrentContractInput>
    create: XOR<PlayerCreateWithoutCurrentContractInput, PlayerUncheckedCreateWithoutCurrentContractInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCurrentContractInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCurrentContractInput, PlayerUncheckedUpdateWithoutCurrentContractInput>
  }

  export type PlayerUpdateWithoutCurrentContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCurrentContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithoutPlayerContractsInput = {
    update: XOR<TeamUpdateWithoutPlayerContractsInput, TeamUncheckedUpdateWithoutPlayerContractsInput>
    create: XOR<TeamCreateWithoutPlayerContractsInput, TeamUncheckedCreateWithoutPlayerContractsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlayerContractsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlayerContractsInput, TeamUncheckedUpdateWithoutPlayerContractsInput>
  }

  export type TeamUpdateWithoutPlayerContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUpdateManyWithoutSuspendedListTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlayerContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    division?: EnumDivisionEnumFieldUpdateOperationsInput | $Enums.DivisionEnum
    conference?: EnumConferenceEnumFieldUpdateOperationsInput | $Enums.ConferenceEnum
    overallRating?: IntFieldUpdateOperationsInput | number
    offensiveScheme?: EnumOffensiveSchemeEnumFieldUpdateOperationsInput | $Enums.OffensiveSchemeEnum
    defensiveScheme?: EnumDefensiveSchemeEnumFieldUpdateOperationsInput | $Enums.DefensiveSchemeEnum
    teamNeeds?: TeamUpdateteamNeedsInput | $Enums.PlayerPositionEnum[]
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestWinningStreak?: IntFieldUpdateOperationsInput | number
    playoffAppearances?: IntFieldUpdateOperationsInput | number
    superBowlAppearances?: IntFieldUpdateOperationsInput | number
    championships?: IntFieldUpdateOperationsInput | number
    capSpace?: IntFieldUpdateOperationsInput | number
    capLimit?: IntFieldUpdateOperationsInput | number
    totalPayroll?: IntFieldUpdateOperationsInput | number
    financialHealth?: EnumFinancialHealthEnumFieldUpdateOperationsInput | $Enums.FinancialHealthEnum
    yearFounded?: IntFieldUpdateOperationsInput | number
    allTimeWins?: IntFieldUpdateOperationsInput | number
    allTimeLosses?: IntFieldUpdateOperationsInput | number
    allTimeTies?: IntFieldUpdateOperationsInput | number
    retiredNumbers?: TeamUpdateretiredNumbersInput | number[]
    fanBaseSize?: IntFieldUpdateOperationsInput | number
    prestige?: IntFieldUpdateOperationsInput | number
    rivalTeams?: TeamUpdaterivalTeamsInput | string[]
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    practiceSquad?: PlayerUncheckedUpdateManyWithoutPracticeSquadTeamNestedInput
    injuredReserve?: PlayerUncheckedUpdateManyWithoutInjuredReserveTeamNestedInput
    suspendedList?: PlayerUncheckedUpdateManyWithoutSuspendedListTeamNestedInput
  }

  export type ContractBonusUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractBonusWhereUniqueInput
    update: XOR<ContractBonusUpdateWithoutContractInput, ContractBonusUncheckedUpdateWithoutContractInput>
    create: XOR<ContractBonusCreateWithoutContractInput, ContractBonusUncheckedCreateWithoutContractInput>
  }

  export type ContractBonusUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractBonusWhereUniqueInput
    data: XOR<ContractBonusUpdateWithoutContractInput, ContractBonusUncheckedUpdateWithoutContractInput>
  }

  export type ContractBonusUpdateManyWithWhereWithoutContractInput = {
    where: ContractBonusScalarWhereInput
    data: XOR<ContractBonusUpdateManyMutationInput, ContractBonusUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractBonusScalarWhereInput = {
    AND?: ContractBonusScalarWhereInput | ContractBonusScalarWhereInput[]
    OR?: ContractBonusScalarWhereInput[]
    NOT?: ContractBonusScalarWhereInput | ContractBonusScalarWhereInput[]
    id?: StringFilter<"ContractBonus"> | string
    contractId?: StringFilter<"ContractBonus"> | string
    year?: IntFilter<"ContractBonus"> | number
    signingBonus?: IntNullableFilter<"ContractBonus"> | number | null
    rosterBonus?: IntNullableFilter<"ContractBonus"> | number | null
    workoutBonus?: IntNullableFilter<"ContractBonus"> | number | null
    incentiveBonus?: IntNullableFilter<"ContractBonus"> | number | null
  }

  export type SalaryByYearUpsertWithWhereUniqueWithoutContractInput = {
    where: SalaryByYearWhereUniqueInput
    update: XOR<SalaryByYearUpdateWithoutContractInput, SalaryByYearUncheckedUpdateWithoutContractInput>
    create: XOR<SalaryByYearCreateWithoutContractInput, SalaryByYearUncheckedCreateWithoutContractInput>
  }

  export type SalaryByYearUpdateWithWhereUniqueWithoutContractInput = {
    where: SalaryByYearWhereUniqueInput
    data: XOR<SalaryByYearUpdateWithoutContractInput, SalaryByYearUncheckedUpdateWithoutContractInput>
  }

  export type SalaryByYearUpdateManyWithWhereWithoutContractInput = {
    where: SalaryByYearScalarWhereInput
    data: XOR<SalaryByYearUpdateManyMutationInput, SalaryByYearUncheckedUpdateManyWithoutContractInput>
  }

  export type SalaryByYearScalarWhereInput = {
    AND?: SalaryByYearScalarWhereInput | SalaryByYearScalarWhereInput[]
    OR?: SalaryByYearScalarWhereInput[]
    NOT?: SalaryByYearScalarWhereInput | SalaryByYearScalarWhereInput[]
    id?: StringFilter<"SalaryByYear"> | string
    contractId?: StringFilter<"SalaryByYear"> | string
    year?: IntFilter<"SalaryByYear"> | number
    amount?: IntFilter<"SalaryByYear"> | number
  }

  export type CapHitByYearUpsertWithWhereUniqueWithoutContractInput = {
    where: CapHitByYearWhereUniqueInput
    update: XOR<CapHitByYearUpdateWithoutContractInput, CapHitByYearUncheckedUpdateWithoutContractInput>
    create: XOR<CapHitByYearCreateWithoutContractInput, CapHitByYearUncheckedCreateWithoutContractInput>
  }

  export type CapHitByYearUpdateWithWhereUniqueWithoutContractInput = {
    where: CapHitByYearWhereUniqueInput
    data: XOR<CapHitByYearUpdateWithoutContractInput, CapHitByYearUncheckedUpdateWithoutContractInput>
  }

  export type CapHitByYearUpdateManyWithWhereWithoutContractInput = {
    where: CapHitByYearScalarWhereInput
    data: XOR<CapHitByYearUpdateManyMutationInput, CapHitByYearUncheckedUpdateManyWithoutContractInput>
  }

  export type CapHitByYearScalarWhereInput = {
    AND?: CapHitByYearScalarWhereInput | CapHitByYearScalarWhereInput[]
    OR?: CapHitByYearScalarWhereInput[]
    NOT?: CapHitByYearScalarWhereInput | CapHitByYearScalarWhereInput[]
    id?: StringFilter<"CapHitByYear"> | string
    contractId?: StringFilter<"CapHitByYear"> | string
    year?: IntFilter<"CapHitByYear"> | number
    amount?: IntFilter<"CapHitByYear"> | number
  }

  export type DeadCapByYearUpsertWithWhereUniqueWithoutContractInput = {
    where: DeadCapByYearWhereUniqueInput
    update: XOR<DeadCapByYearUpdateWithoutContractInput, DeadCapByYearUncheckedUpdateWithoutContractInput>
    create: XOR<DeadCapByYearCreateWithoutContractInput, DeadCapByYearUncheckedCreateWithoutContractInput>
  }

  export type DeadCapByYearUpdateWithWhereUniqueWithoutContractInput = {
    where: DeadCapByYearWhereUniqueInput
    data: XOR<DeadCapByYearUpdateWithoutContractInput, DeadCapByYearUncheckedUpdateWithoutContractInput>
  }

  export type DeadCapByYearUpdateManyWithWhereWithoutContractInput = {
    where: DeadCapByYearScalarWhereInput
    data: XOR<DeadCapByYearUpdateManyMutationInput, DeadCapByYearUncheckedUpdateManyWithoutContractInput>
  }

  export type DeadCapByYearScalarWhereInput = {
    AND?: DeadCapByYearScalarWhereInput | DeadCapByYearScalarWhereInput[]
    OR?: DeadCapByYearScalarWhereInput[]
    NOT?: DeadCapByYearScalarWhereInput | DeadCapByYearScalarWhereInput[]
    id?: StringFilter<"DeadCapByYear"> | string
    contractId?: StringFilter<"DeadCapByYear"> | string
    year?: IntFilter<"DeadCapByYear"> | number
    amount?: IntFilter<"DeadCapByYear"> | number
  }

  export type OptOutYearUpsertWithWhereUniqueWithoutContractInput = {
    where: OptOutYearWhereUniqueInput
    update: XOR<OptOutYearUpdateWithoutContractInput, OptOutYearUncheckedUpdateWithoutContractInput>
    create: XOR<OptOutYearCreateWithoutContractInput, OptOutYearUncheckedCreateWithoutContractInput>
  }

  export type OptOutYearUpdateWithWhereUniqueWithoutContractInput = {
    where: OptOutYearWhereUniqueInput
    data: XOR<OptOutYearUpdateWithoutContractInput, OptOutYearUncheckedUpdateWithoutContractInput>
  }

  export type OptOutYearUpdateManyWithWhereWithoutContractInput = {
    where: OptOutYearScalarWhereInput
    data: XOR<OptOutYearUpdateManyMutationInput, OptOutYearUncheckedUpdateManyWithoutContractInput>
  }

  export type OptOutYearScalarWhereInput = {
    AND?: OptOutYearScalarWhereInput | OptOutYearScalarWhereInput[]
    OR?: OptOutYearScalarWhereInput[]
    NOT?: OptOutYearScalarWhereInput | OptOutYearScalarWhereInput[]
    id?: StringFilter<"OptOutYear"> | string
    contractId?: StringFilter<"OptOutYear"> | string
    year?: IntFilter<"OptOutYear"> | number
  }

  export type RestructureEventUpsertWithWhereUniqueWithoutContractInput = {
    where: RestructureEventWhereUniqueInput
    update: XOR<RestructureEventUpdateWithoutContractInput, RestructureEventUncheckedUpdateWithoutContractInput>
    create: XOR<RestructureEventCreateWithoutContractInput, RestructureEventUncheckedCreateWithoutContractInput>
  }

  export type RestructureEventUpdateWithWhereUniqueWithoutContractInput = {
    where: RestructureEventWhereUniqueInput
    data: XOR<RestructureEventUpdateWithoutContractInput, RestructureEventUncheckedUpdateWithoutContractInput>
  }

  export type RestructureEventUpdateManyWithWhereWithoutContractInput = {
    where: RestructureEventScalarWhereInput
    data: XOR<RestructureEventUpdateManyMutationInput, RestructureEventUncheckedUpdateManyWithoutContractInput>
  }

  export type RestructureEventScalarWhereInput = {
    AND?: RestructureEventScalarWhereInput | RestructureEventScalarWhereInput[]
    OR?: RestructureEventScalarWhereInput[]
    NOT?: RestructureEventScalarWhereInput | RestructureEventScalarWhereInput[]
    id?: StringFilter<"RestructureEvent"> | string
    contractId?: StringFilter<"RestructureEvent"> | string
    year?: IntNullableFilter<"RestructureEvent"> | number | null
    date?: DateTimeNullableFilter<"RestructureEvent"> | Date | string | null
    amountConvertedToBonus?: IntNullableFilter<"RestructureEvent"> | number | null
    newCapHit?: IntNullableFilter<"RestructureEvent"> | number | null
    newDeadCap?: IntNullableFilter<"RestructureEvent"> | number | null
  }

  export type ContractClauseUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractClauseWhereUniqueInput
    update: XOR<ContractClauseUpdateWithoutContractInput, ContractClauseUncheckedUpdateWithoutContractInput>
    create: XOR<ContractClauseCreateWithoutContractInput, ContractClauseUncheckedCreateWithoutContractInput>
  }

  export type ContractClauseUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractClauseWhereUniqueInput
    data: XOR<ContractClauseUpdateWithoutContractInput, ContractClauseUncheckedUpdateWithoutContractInput>
  }

  export type ContractClauseUpdateManyWithWhereWithoutContractInput = {
    where: ContractClauseScalarWhereInput
    data: XOR<ContractClauseUpdateManyMutationInput, ContractClauseUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractClauseScalarWhereInput = {
    AND?: ContractClauseScalarWhereInput | ContractClauseScalarWhereInput[]
    OR?: ContractClauseScalarWhereInput[]
    NOT?: ContractClauseScalarWhereInput | ContractClauseScalarWhereInput[]
    id?: StringFilter<"ContractClause"> | string
    contractId?: StringFilter<"ContractClause"> | string
    noTradeClause?: BoolNullableFilter<"ContractClause"> | boolean | null
    injuryGuarantee?: BoolNullableFilter<"ContractClause"> | boolean | null
    restructureEligible?: BoolNullableFilter<"ContractClause"> | boolean | null
    earlyTerminationPenalty?: FloatNullableFilter<"ContractClause"> | number | null
    performanceBonusId?: StringNullableFilter<"ContractClause"> | string | null
    rosterBonusId?: StringNullableFilter<"ContractClause"> | string | null
    workoutBonusId?: StringNullableFilter<"ContractClause"> | string | null
    optionBonusId?: StringNullableFilter<"ContractClause"> | string | null
  }

  export type PlayerContractCreateWithoutBonusesInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutBonusesInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutBonusesInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutBonusesInput, PlayerContractUncheckedCreateWithoutBonusesInput>
  }

  export type PlayerContractUpsertWithoutBonusesInput = {
    update: XOR<PlayerContractUpdateWithoutBonusesInput, PlayerContractUncheckedUpdateWithoutBonusesInput>
    create: XOR<PlayerContractCreateWithoutBonusesInput, PlayerContractUncheckedCreateWithoutBonusesInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutBonusesInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutBonusesInput, PlayerContractUncheckedUpdateWithoutBonusesInput>
  }

  export type PlayerContractUpdateWithoutBonusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutBonusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateWithoutSalariesInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutSalariesInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutSalariesInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutSalariesInput, PlayerContractUncheckedCreateWithoutSalariesInput>
  }

  export type PlayerContractUpsertWithoutSalariesInput = {
    update: XOR<PlayerContractUpdateWithoutSalariesInput, PlayerContractUncheckedUpdateWithoutSalariesInput>
    create: XOR<PlayerContractCreateWithoutSalariesInput, PlayerContractUncheckedCreateWithoutSalariesInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutSalariesInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutSalariesInput, PlayerContractUncheckedUpdateWithoutSalariesInput>
  }

  export type PlayerContractUpdateWithoutSalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutSalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateWithoutCapHitsInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutCapHitsInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutCapHitsInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutCapHitsInput, PlayerContractUncheckedCreateWithoutCapHitsInput>
  }

  export type PlayerContractUpsertWithoutCapHitsInput = {
    update: XOR<PlayerContractUpdateWithoutCapHitsInput, PlayerContractUncheckedUpdateWithoutCapHitsInput>
    create: XOR<PlayerContractCreateWithoutCapHitsInput, PlayerContractUncheckedCreateWithoutCapHitsInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutCapHitsInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutCapHitsInput, PlayerContractUncheckedUpdateWithoutCapHitsInput>
  }

  export type PlayerContractUpdateWithoutCapHitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutCapHitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateWithoutDeadCapsInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutDeadCapsInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutDeadCapsInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutDeadCapsInput, PlayerContractUncheckedCreateWithoutDeadCapsInput>
  }

  export type PlayerContractUpsertWithoutDeadCapsInput = {
    update: XOR<PlayerContractUpdateWithoutDeadCapsInput, PlayerContractUncheckedUpdateWithoutDeadCapsInput>
    create: XOR<PlayerContractCreateWithoutDeadCapsInput, PlayerContractUncheckedCreateWithoutDeadCapsInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutDeadCapsInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutDeadCapsInput, PlayerContractUncheckedUpdateWithoutDeadCapsInput>
  }

  export type PlayerContractUpdateWithoutDeadCapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutDeadCapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateWithoutOptOutYearsInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutOptOutYearsInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutOptOutYearsInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutOptOutYearsInput, PlayerContractUncheckedCreateWithoutOptOutYearsInput>
  }

  export type PlayerContractUpsertWithoutOptOutYearsInput = {
    update: XOR<PlayerContractUpdateWithoutOptOutYearsInput, PlayerContractUncheckedUpdateWithoutOptOutYearsInput>
    create: XOR<PlayerContractCreateWithoutOptOutYearsInput, PlayerContractUncheckedCreateWithoutOptOutYearsInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutOptOutYearsInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutOptOutYearsInput, PlayerContractUncheckedUpdateWithoutOptOutYearsInput>
  }

  export type PlayerContractUpdateWithoutOptOutYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutOptOutYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateWithoutRestructureEventsInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    clauses?: ContractClauseCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutRestructureEventsInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    clauses?: ContractClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutRestructureEventsInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutRestructureEventsInput, PlayerContractUncheckedCreateWithoutRestructureEventsInput>
  }

  export type PlayerContractUpsertWithoutRestructureEventsInput = {
    update: XOR<PlayerContractUpdateWithoutRestructureEventsInput, PlayerContractUncheckedUpdateWithoutRestructureEventsInput>
    create: XOR<PlayerContractCreateWithoutRestructureEventsInput, PlayerContractUncheckedCreateWithoutRestructureEventsInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutRestructureEventsInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutRestructureEventsInput, PlayerContractUncheckedUpdateWithoutRestructureEventsInput>
  }

  export type PlayerContractUpdateWithoutRestructureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutRestructureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractCreateWithoutClausesInput = {
    id?: string
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutCurrentContractInput
    team?: TeamCreateNestedOneWithoutPlayerContractsInput
    bonuses?: ContractBonusCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventCreateNestedManyWithoutContractInput
  }

  export type PlayerContractUncheckedCreateWithoutClausesInput = {
    id?: string
    playerId?: string | null
    teamId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bonuses?: ContractBonusUncheckedCreateNestedManyWithoutContractInput
    salaries?: SalaryByYearUncheckedCreateNestedManyWithoutContractInput
    capHits?: CapHitByYearUncheckedCreateNestedManyWithoutContractInput
    deadCaps?: DeadCapByYearUncheckedCreateNestedManyWithoutContractInput
    optOutYears?: OptOutYearUncheckedCreateNestedManyWithoutContractInput
    restructureEvents?: RestructureEventUncheckedCreateNestedManyWithoutContractInput
  }

  export type PlayerContractCreateOrConnectWithoutClausesInput = {
    where: PlayerContractWhereUniqueInput
    create: XOR<PlayerContractCreateWithoutClausesInput, PlayerContractUncheckedCreateWithoutClausesInput>
  }

  export type PerformanceBonusCreateWithoutClausesInput = {
    id?: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
    statMilestones?: StatMilestoneCreateNestedOneWithoutPerformanceBonusInput
  }

  export type PerformanceBonusUncheckedCreateWithoutClausesInput = {
    id?: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
    statMilestones?: StatMilestoneUncheckedCreateNestedOneWithoutPerformanceBonusInput
  }

  export type PerformanceBonusCreateOrConnectWithoutClausesInput = {
    where: PerformanceBonusWhereUniqueInput
    create: XOR<PerformanceBonusCreateWithoutClausesInput, PerformanceBonusUncheckedCreateWithoutClausesInput>
  }

  export type RosterBonusCreateWithoutClauseInput = {
    id?: string
    amount?: number | null
    perGame?: boolean | null
  }

  export type RosterBonusUncheckedCreateWithoutClauseInput = {
    id?: string
    amount?: number | null
    perGame?: boolean | null
  }

  export type RosterBonusCreateOrConnectWithoutClauseInput = {
    where: RosterBonusWhereUniqueInput
    create: XOR<RosterBonusCreateWithoutClauseInput, RosterBonusUncheckedCreateWithoutClauseInput>
  }

  export type WorkoutBonusCreateWithoutClauseInput = {
    id?: string
    amount?: number | null
    minWorkouts?: number | null
  }

  export type WorkoutBonusUncheckedCreateWithoutClauseInput = {
    id?: string
    amount?: number | null
    minWorkouts?: number | null
  }

  export type WorkoutBonusCreateOrConnectWithoutClauseInput = {
    where: WorkoutBonusWhereUniqueInput
    create: XOR<WorkoutBonusCreateWithoutClauseInput, WorkoutBonusUncheckedCreateWithoutClauseInput>
  }

  export type OptionBonusCreateWithoutClauseInput = {
    id?: string
    year?: number | null
    amount?: number | null
    type?: $Enums.OptionType | null
  }

  export type OptionBonusUncheckedCreateWithoutClauseInput = {
    id?: string
    year?: number | null
    amount?: number | null
    type?: $Enums.OptionType | null
  }

  export type OptionBonusCreateOrConnectWithoutClauseInput = {
    where: OptionBonusWhereUniqueInput
    create: XOR<OptionBonusCreateWithoutClauseInput, OptionBonusUncheckedCreateWithoutClauseInput>
  }

  export type PlayerContractUpsertWithoutClausesInput = {
    update: XOR<PlayerContractUpdateWithoutClausesInput, PlayerContractUncheckedUpdateWithoutClausesInput>
    create: XOR<PlayerContractCreateWithoutClausesInput, PlayerContractUncheckedCreateWithoutClausesInput>
    where?: PlayerContractWhereInput
  }

  export type PlayerContractUpdateToOneWithWhereWithoutClausesInput = {
    where?: PlayerContractWhereInput
    data: XOR<PlayerContractUpdateWithoutClausesInput, PlayerContractUncheckedUpdateWithoutClausesInput>
  }

  export type PlayerContractUpdateWithoutClausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    team?: TeamUpdateOneWithoutPlayerContractsNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutClausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PerformanceBonusUpsertWithoutClausesInput = {
    update: XOR<PerformanceBonusUpdateWithoutClausesInput, PerformanceBonusUncheckedUpdateWithoutClausesInput>
    create: XOR<PerformanceBonusCreateWithoutClausesInput, PerformanceBonusUncheckedCreateWithoutClausesInput>
    where?: PerformanceBonusWhereInput
  }

  export type PerformanceBonusUpdateToOneWithWhereWithoutClausesInput = {
    where?: PerformanceBonusWhereInput
    data: XOR<PerformanceBonusUpdateWithoutClausesInput, PerformanceBonusUncheckedUpdateWithoutClausesInput>
  }

  export type PerformanceBonusUpdateWithoutClausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    statMilestones?: StatMilestoneUpdateOneWithoutPerformanceBonusNestedInput
  }

  export type PerformanceBonusUncheckedUpdateWithoutClausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    statMilestones?: StatMilestoneUncheckedUpdateOneWithoutPerformanceBonusNestedInput
  }

  export type RosterBonusUpsertWithoutClauseInput = {
    update: XOR<RosterBonusUpdateWithoutClauseInput, RosterBonusUncheckedUpdateWithoutClauseInput>
    create: XOR<RosterBonusCreateWithoutClauseInput, RosterBonusUncheckedCreateWithoutClauseInput>
    where?: RosterBonusWhereInput
  }

  export type RosterBonusUpdateToOneWithWhereWithoutClauseInput = {
    where?: RosterBonusWhereInput
    data: XOR<RosterBonusUpdateWithoutClauseInput, RosterBonusUncheckedUpdateWithoutClauseInput>
  }

  export type RosterBonusUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    perGame?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RosterBonusUncheckedUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    perGame?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WorkoutBonusUpsertWithoutClauseInput = {
    update: XOR<WorkoutBonusUpdateWithoutClauseInput, WorkoutBonusUncheckedUpdateWithoutClauseInput>
    create: XOR<WorkoutBonusCreateWithoutClauseInput, WorkoutBonusUncheckedCreateWithoutClauseInput>
    where?: WorkoutBonusWhereInput
  }

  export type WorkoutBonusUpdateToOneWithWhereWithoutClauseInput = {
    where?: WorkoutBonusWhereInput
    data: XOR<WorkoutBonusUpdateWithoutClauseInput, WorkoutBonusUncheckedUpdateWithoutClauseInput>
  }

  export type WorkoutBonusUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    minWorkouts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutBonusUncheckedUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    minWorkouts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionBonusUpsertWithoutClauseInput = {
    update: XOR<OptionBonusUpdateWithoutClauseInput, OptionBonusUncheckedUpdateWithoutClauseInput>
    create: XOR<OptionBonusCreateWithoutClauseInput, OptionBonusUncheckedCreateWithoutClauseInput>
    where?: OptionBonusWhereInput
  }

  export type OptionBonusUpdateToOneWithWhereWithoutClauseInput = {
    where?: OptionBonusWhereInput
    data: XOR<OptionBonusUpdateWithoutClauseInput, OptionBonusUncheckedUpdateWithoutClauseInput>
  }

  export type OptionBonusUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType | null
  }

  export type OptionBonusUncheckedUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType | null
  }

  export type ContractClauseCreateWithoutPerformanceBonusInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    contract: PlayerContractCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUncheckedCreateWithoutPerformanceBonusInput = {
    id?: string
    contractId: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    rosterBonus?: RosterBonusUncheckedCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusUncheckedCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusUncheckedCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseCreateOrConnectWithoutPerformanceBonusInput = {
    where: ContractClauseWhereUniqueInput
    create: XOR<ContractClauseCreateWithoutPerformanceBonusInput, ContractClauseUncheckedCreateWithoutPerformanceBonusInput>
  }

  export type StatMilestoneCreateWithoutPerformanceBonusInput = {
    id?: string
    yards?: number | null
    touchdowns?: number | null
    sacks?: number | null
    interceptions?: number | null
  }

  export type StatMilestoneUncheckedCreateWithoutPerformanceBonusInput = {
    id?: string
    yards?: number | null
    touchdowns?: number | null
    sacks?: number | null
    interceptions?: number | null
  }

  export type StatMilestoneCreateOrConnectWithoutPerformanceBonusInput = {
    where: StatMilestoneWhereUniqueInput
    create: XOR<StatMilestoneCreateWithoutPerformanceBonusInput, StatMilestoneUncheckedCreateWithoutPerformanceBonusInput>
  }

  export type ContractClauseUpsertWithoutPerformanceBonusInput = {
    update: XOR<ContractClauseUpdateWithoutPerformanceBonusInput, ContractClauseUncheckedUpdateWithoutPerformanceBonusInput>
    create: XOR<ContractClauseCreateWithoutPerformanceBonusInput, ContractClauseUncheckedCreateWithoutPerformanceBonusInput>
    where?: ContractClauseWhereInput
  }

  export type ContractClauseUpdateToOneWithWhereWithoutPerformanceBonusInput = {
    where?: ContractClauseWhereInput
    data: XOR<ContractClauseUpdateWithoutPerformanceBonusInput, ContractClauseUncheckedUpdateWithoutPerformanceBonusInput>
  }

  export type ContractClauseUpdateWithoutPerformanceBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: PlayerContractUpdateOneRequiredWithoutClausesNestedInput
    rosterBonus?: RosterBonusUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateWithoutPerformanceBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonus?: RosterBonusUncheckedUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUncheckedUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUncheckedUpdateOneWithoutClauseNestedInput
  }

  export type StatMilestoneUpsertWithoutPerformanceBonusInput = {
    update: XOR<StatMilestoneUpdateWithoutPerformanceBonusInput, StatMilestoneUncheckedUpdateWithoutPerformanceBonusInput>
    create: XOR<StatMilestoneCreateWithoutPerformanceBonusInput, StatMilestoneUncheckedCreateWithoutPerformanceBonusInput>
    where?: StatMilestoneWhereInput
  }

  export type StatMilestoneUpdateToOneWithWhereWithoutPerformanceBonusInput = {
    where?: StatMilestoneWhereInput
    data: XOR<StatMilestoneUpdateWithoutPerformanceBonusInput, StatMilestoneUncheckedUpdateWithoutPerformanceBonusInput>
  }

  export type StatMilestoneUpdateWithoutPerformanceBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    yards?: NullableIntFieldUpdateOperationsInput | number | null
    touchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatMilestoneUncheckedUpdateWithoutPerformanceBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    yards?: NullableIntFieldUpdateOperationsInput | number | null
    touchdowns?: NullableIntFieldUpdateOperationsInput | number | null
    sacks?: NullableIntFieldUpdateOperationsInput | number | null
    interceptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PerformanceBonusCreateWithoutStatMilestonesInput = {
    id?: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
    clauses: ContractClauseCreateNestedOneWithoutPerformanceBonusInput
  }

  export type PerformanceBonusUncheckedCreateWithoutStatMilestonesInput = {
    id?: string
    clauseId: string
    proBowl?: number | null
    allPro?: number | null
    mvp?: number | null
    superBowlMVP?: number | null
    playoffAppearance?: number | null
  }

  export type PerformanceBonusCreateOrConnectWithoutStatMilestonesInput = {
    where: PerformanceBonusWhereUniqueInput
    create: XOR<PerformanceBonusCreateWithoutStatMilestonesInput, PerformanceBonusUncheckedCreateWithoutStatMilestonesInput>
  }

  export type PerformanceBonusUpsertWithoutStatMilestonesInput = {
    update: XOR<PerformanceBonusUpdateWithoutStatMilestonesInput, PerformanceBonusUncheckedUpdateWithoutStatMilestonesInput>
    create: XOR<PerformanceBonusCreateWithoutStatMilestonesInput, PerformanceBonusUncheckedCreateWithoutStatMilestonesInput>
    where?: PerformanceBonusWhereInput
  }

  export type PerformanceBonusUpdateToOneWithWhereWithoutStatMilestonesInput = {
    where?: PerformanceBonusWhereInput
    data: XOR<PerformanceBonusUpdateWithoutStatMilestonesInput, PerformanceBonusUncheckedUpdateWithoutStatMilestonesInput>
  }

  export type PerformanceBonusUpdateWithoutStatMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    clauses?: ContractClauseUpdateOneRequiredWithoutPerformanceBonusNestedInput
  }

  export type PerformanceBonusUncheckedUpdateWithoutStatMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clauseId?: StringFieldUpdateOperationsInput | string
    proBowl?: NullableIntFieldUpdateOperationsInput | number | null
    allPro?: NullableIntFieldUpdateOperationsInput | number | null
    mvp?: NullableIntFieldUpdateOperationsInput | number | null
    superBowlMVP?: NullableIntFieldUpdateOperationsInput | number | null
    playoffAppearance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractClauseCreateWithoutRosterBonusInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    contract: PlayerContractCreateNestedOneWithoutClausesInput
    performanceBonus?: PerformanceBonusCreateNestedOneWithoutClausesInput
    workoutBonus?: WorkoutBonusCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUncheckedCreateWithoutRosterBonusInput = {
    id?: string
    contractId: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    performanceBonus?: PerformanceBonusUncheckedCreateNestedOneWithoutClausesInput
    workoutBonus?: WorkoutBonusUncheckedCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusUncheckedCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseCreateOrConnectWithoutRosterBonusInput = {
    where: ContractClauseWhereUniqueInput
    create: XOR<ContractClauseCreateWithoutRosterBonusInput, ContractClauseUncheckedCreateWithoutRosterBonusInput>
  }

  export type ContractClauseUpsertWithoutRosterBonusInput = {
    update: XOR<ContractClauseUpdateWithoutRosterBonusInput, ContractClauseUncheckedUpdateWithoutRosterBonusInput>
    create: XOR<ContractClauseCreateWithoutRosterBonusInput, ContractClauseUncheckedCreateWithoutRosterBonusInput>
    where?: ContractClauseWhereInput
  }

  export type ContractClauseUpdateToOneWithWhereWithoutRosterBonusInput = {
    where?: ContractClauseWhereInput
    data: XOR<ContractClauseUpdateWithoutRosterBonusInput, ContractClauseUncheckedUpdateWithoutRosterBonusInput>
  }

  export type ContractClauseUpdateWithoutRosterBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: PlayerContractUpdateOneRequiredWithoutClausesNestedInput
    performanceBonus?: PerformanceBonusUpdateOneWithoutClausesNestedInput
    workoutBonus?: WorkoutBonusUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateWithoutRosterBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    performanceBonus?: PerformanceBonusUncheckedUpdateOneWithoutClausesNestedInput
    workoutBonus?: WorkoutBonusUncheckedUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUncheckedUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseCreateWithoutWorkoutBonusInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    contract: PlayerContractCreateNestedOneWithoutClausesInput
    performanceBonus?: PerformanceBonusCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUncheckedCreateWithoutWorkoutBonusInput = {
    id?: string
    contractId: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    performanceBonus?: PerformanceBonusUncheckedCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusUncheckedCreateNestedOneWithoutClauseInput
    optionBonus?: OptionBonusUncheckedCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseCreateOrConnectWithoutWorkoutBonusInput = {
    where: ContractClauseWhereUniqueInput
    create: XOR<ContractClauseCreateWithoutWorkoutBonusInput, ContractClauseUncheckedCreateWithoutWorkoutBonusInput>
  }

  export type ContractClauseUpsertWithoutWorkoutBonusInput = {
    update: XOR<ContractClauseUpdateWithoutWorkoutBonusInput, ContractClauseUncheckedUpdateWithoutWorkoutBonusInput>
    create: XOR<ContractClauseCreateWithoutWorkoutBonusInput, ContractClauseUncheckedCreateWithoutWorkoutBonusInput>
    where?: ContractClauseWhereInput
  }

  export type ContractClauseUpdateToOneWithWhereWithoutWorkoutBonusInput = {
    where?: ContractClauseWhereInput
    data: XOR<ContractClauseUpdateWithoutWorkoutBonusInput, ContractClauseUncheckedUpdateWithoutWorkoutBonusInput>
  }

  export type ContractClauseUpdateWithoutWorkoutBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: PlayerContractUpdateOneRequiredWithoutClausesNestedInput
    performanceBonus?: PerformanceBonusUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateWithoutWorkoutBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    performanceBonus?: PerformanceBonusUncheckedUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUncheckedUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUncheckedUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseCreateWithoutOptionBonusInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    contract: PlayerContractCreateNestedOneWithoutClausesInput
    performanceBonus?: PerformanceBonusCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseUncheckedCreateWithoutOptionBonusInput = {
    id?: string
    contractId: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
    performanceBonus?: PerformanceBonusUncheckedCreateNestedOneWithoutClausesInput
    rosterBonus?: RosterBonusUncheckedCreateNestedOneWithoutClauseInput
    workoutBonus?: WorkoutBonusUncheckedCreateNestedOneWithoutClauseInput
  }

  export type ContractClauseCreateOrConnectWithoutOptionBonusInput = {
    where: ContractClauseWhereUniqueInput
    create: XOR<ContractClauseCreateWithoutOptionBonusInput, ContractClauseUncheckedCreateWithoutOptionBonusInput>
  }

  export type ContractClauseUpsertWithoutOptionBonusInput = {
    update: XOR<ContractClauseUpdateWithoutOptionBonusInput, ContractClauseUncheckedUpdateWithoutOptionBonusInput>
    create: XOR<ContractClauseCreateWithoutOptionBonusInput, ContractClauseUncheckedCreateWithoutOptionBonusInput>
    where?: ContractClauseWhereInput
  }

  export type ContractClauseUpdateToOneWithWhereWithoutOptionBonusInput = {
    where?: ContractClauseWhereInput
    data: XOR<ContractClauseUpdateWithoutOptionBonusInput, ContractClauseUncheckedUpdateWithoutOptionBonusInput>
  }

  export type ContractClauseUpdateWithoutOptionBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: PlayerContractUpdateOneRequiredWithoutClausesNestedInput
    performanceBonus?: PerformanceBonusUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateWithoutOptionBonusInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    performanceBonus?: PerformanceBonusUncheckedUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUncheckedUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUncheckedUpdateOneWithoutClauseNestedInput
  }

  export type PlayerCreateWithoutAgentInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutAgentInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutAgentInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutAgentInput, PlayerUncheckedCreateWithoutAgentInput>
  }

  export type PlayerCreateManyAgentInputEnvelope = {
    data: PlayerCreateManyAgentInput | PlayerCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithWhereUniqueWithoutAgentInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutAgentInput, PlayerUncheckedUpdateWithoutAgentInput>
    create: XOR<PlayerCreateWithoutAgentInput, PlayerUncheckedCreateWithoutAgentInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutAgentInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutAgentInput, PlayerUncheckedUpdateWithoutAgentInput>
  }

  export type PlayerUpdateManyWithWhereWithoutAgentInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutAgentInput>
  }

  export type PlayerCreateWithoutRatingsInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    stats?: StatCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutRatingsInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutRatingsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutRatingsInput, PlayerUncheckedCreateWithoutRatingsInput>
  }

  export type PlayerUpsertWithoutRatingsInput = {
    update: XOR<PlayerUpdateWithoutRatingsInput, PlayerUncheckedUpdateWithoutRatingsInput>
    create: XOR<PlayerCreateWithoutRatingsInput, PlayerUncheckedCreateWithoutRatingsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutRatingsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutRatingsInput, PlayerUncheckedUpdateWithoutRatingsInput>
  }

  export type PlayerUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerCreateWithoutStatsInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    contractDesires?: ContractDesiresCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutStatsInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
  }

  export type PlayerUpsertWithoutStatsInput = {
    update: XOR<PlayerUpdateWithoutStatsInput, PlayerUncheckedUpdateWithoutStatsInput>
    create: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutStatsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutStatsInput, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type PlayerUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerCreateWithoutContractDesiresInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    currentContractId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutPlayersInput
    practiceSquadTeam?: TeamCreateNestedOneWithoutPracticeSquadInput
    injuredReserveTeam?: TeamCreateNestedOneWithoutInjuredReserveInput
    suspendedListTeam?: TeamCreateNestedOneWithoutSuspendedListInput
    currentContract?: PlayerContractCreateNestedOneWithoutPlayerInput
    agent?: AgentCreateNestedOneWithoutPlayersInput
    ratings?: RatingCreateNestedOneWithoutPlayerInput
    stats?: StatCreateNestedOneWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutContractDesiresInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentContract?: PlayerContractUncheckedCreateNestedOneWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutContractDesiresInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutContractDesiresInput, PlayerUncheckedCreateWithoutContractDesiresInput>
  }

  export type PlayerCreateManyContractDesiresInputEnvelope = {
    data: PlayerCreateManyContractDesiresInput | PlayerCreateManyContractDesiresInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithWhereUniqueWithoutContractDesiresInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutContractDesiresInput, PlayerUncheckedUpdateWithoutContractDesiresInput>
    create: XOR<PlayerCreateWithoutContractDesiresInput, PlayerUncheckedCreateWithoutContractDesiresInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutContractDesiresInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutContractDesiresInput, PlayerUncheckedUpdateWithoutContractDesiresInput>
  }

  export type PlayerUpdateManyWithWhereWithoutContractDesiresInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutContractDesiresInput>
  }

  export type PlayerCreateManyTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateManyPracticeSquadTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateManyInjuredReserveTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateManySuspendedListTeamInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerContractCreateManyTeamInput = {
    id?: string
    playerId?: string | null
    signedDate?: Date | string | null
    startSeason?: number | null
    endSeason?: number | null
    totalValue?: number | null
    averagePerYear?: number | null
    totalGuaranteed?: number | null
    isRookieContract?: boolean | null
    isFranchiseTag?: boolean | null
    isExtension?: boolean | null
    isPlayerOptOut?: boolean | null
    isTeamOptOut?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutPracticeSquadTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPracticeSquadTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutPracticeSquadTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutInjuredReserveTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutInjuredReserveTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutInjuredReserveTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutSuspendedListTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSuspendedListTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutSuspendedListTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerContractUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCurrentContractNestedInput
    bonuses?: ContractBonusUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bonuses?: ContractBonusUncheckedUpdateManyWithoutContractNestedInput
    salaries?: SalaryByYearUncheckedUpdateManyWithoutContractNestedInput
    capHits?: CapHitByYearUncheckedUpdateManyWithoutContractNestedInput
    deadCaps?: DeadCapByYearUncheckedUpdateManyWithoutContractNestedInput
    optOutYears?: OptOutYearUncheckedUpdateManyWithoutContractNestedInput
    restructureEvents?: RestructureEventUncheckedUpdateManyWithoutContractNestedInput
    clauses?: ContractClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PlayerContractUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startSeason?: NullableIntFieldUpdateOperationsInput | number | null
    endSeason?: NullableIntFieldUpdateOperationsInput | number | null
    totalValue?: NullableIntFieldUpdateOperationsInput | number | null
    averagePerYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalGuaranteed?: NullableIntFieldUpdateOperationsInput | number | null
    isRookieContract?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFranchiseTag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isExtension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPlayerOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTeamOptOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractBonusCreateManyContractInput = {
    id?: string
    year: number
    signingBonus?: number | null
    rosterBonus?: number | null
    workoutBonus?: number | null
    incentiveBonus?: number | null
  }

  export type SalaryByYearCreateManyContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type CapHitByYearCreateManyContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type DeadCapByYearCreateManyContractInput = {
    id?: string
    year: number
    amount: number
  }

  export type OptOutYearCreateManyContractInput = {
    id?: string
    year: number
  }

  export type RestructureEventCreateManyContractInput = {
    id?: string
    year?: number | null
    date?: Date | string | null
    amountConvertedToBonus?: number | null
    newCapHit?: number | null
    newDeadCap?: number | null
  }

  export type ContractClauseCreateManyContractInput = {
    id?: string
    noTradeClause?: boolean | null
    injuryGuarantee?: boolean | null
    restructureEligible?: boolean | null
    earlyTerminationPenalty?: number | null
    performanceBonusId?: string | null
    rosterBonusId?: string | null
    workoutBonusId?: string | null
    optionBonusId?: string | null
  }

  export type ContractBonusUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractBonusUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractBonusUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    signingBonus?: NullableIntFieldUpdateOperationsInput | number | null
    rosterBonus?: NullableIntFieldUpdateOperationsInput | number | null
    workoutBonus?: NullableIntFieldUpdateOperationsInput | number | null
    incentiveBonus?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalaryByYearUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryByYearUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryByYearUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type CapHitByYearUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type CapHitByYearUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type CapHitByYearUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type DeadCapByYearUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type DeadCapByYearUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type DeadCapByYearUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type OptOutYearUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type OptOutYearUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type OptOutYearUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type RestructureEventUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RestructureEventUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RestructureEventUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountConvertedToBonus?: NullableIntFieldUpdateOperationsInput | number | null
    newCapHit?: NullableIntFieldUpdateOperationsInput | number | null
    newDeadCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractClauseUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    performanceBonus?: PerformanceBonusUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    performanceBonus?: PerformanceBonusUncheckedUpdateOneWithoutClausesNestedInput
    rosterBonus?: RosterBonusUncheckedUpdateOneWithoutClauseNestedInput
    workoutBonus?: WorkoutBonusUncheckedUpdateOneWithoutClauseNestedInput
    optionBonus?: OptionBonusUncheckedUpdateOneWithoutClauseNestedInput
  }

  export type ContractClauseUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    noTradeClause?: NullableBoolFieldUpdateOperationsInput | boolean | null
    injuryGuarantee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    restructureEligible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    earlyTerminationPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    workoutBonusId?: NullableStringFieldUpdateOperationsInput | string | null
    optionBonusId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerCreateManyAgentInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractDesiresId?: string | null
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
    contractDesires?: ContractDesiresUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractDesiresId?: NullableStringFieldUpdateOperationsInput | string | null
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateManyContractDesiresInput = {
    id?: string
    firstName: string
    lastName: string
    age: number
    college: string
    heightInInches: number
    weightInPounds: number
    teamId?: string | null
    practiceSquadTeamId?: string | null
    injuredReserveTeamId?: string | null
    suspendedListTeamId?: string | null
    currentContractId?: string | null
    agentId?: string | null
    ratingsId?: string | null
    statsId?: string | null
    position?: $Enums.PlayerPositionEnum | null
    expectedRole?: $Enums.PlayerRoleEnum | null
    actualRole?: $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerCreaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerCreateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerCreatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerCreateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerCreatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: boolean
    isCaptain?: boolean
    isFreeAgent?: boolean
    isRetired?: boolean
    isSuspended?: boolean
    isPracticeSquad?: boolean
    isTradeBlock?: boolean
    offense?: boolean
    defense?: boolean
    specialTeams?: boolean
    draftYear?: number | null
    draftRound?: number | null
    isRecordHolder?: boolean
    contractNegotiationStatus?: $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: Date | string | null
    performanceRating?: number | null
    impactRating?: number | null
    potential?: number | null
    experience?: number | null
    isInjured?: boolean
    injuryProneness?: boolean
    expectedReturnFromInjury?: Date | string | null
    morale?: number | null
    leadership?: number | null
    adaptability?: number | null
    workEthic?: number | null
    consistency?: number | null
    clutchFactor?: number | null
    footballIQ?: number | null
    popularity?: number | null
    trainingFocus?: string | null
    trainingProgress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateWithoutContractDesiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutPlayersNestedInput
    practiceSquadTeam?: TeamUpdateOneWithoutPracticeSquadNestedInput
    injuredReserveTeam?: TeamUpdateOneWithoutInjuredReserveNestedInput
    suspendedListTeam?: TeamUpdateOneWithoutSuspendedListNestedInput
    currentContract?: PlayerContractUpdateOneWithoutPlayerNestedInput
    agent?: AgentUpdateOneWithoutPlayersNestedInput
    ratings?: RatingUpdateOneWithoutPlayerNestedInput
    stats?: StatUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutContractDesiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentContract?: PlayerContractUncheckedUpdateOneWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutContractDesiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    college?: StringFieldUpdateOperationsInput | string
    heightInInches?: IntFieldUpdateOperationsInput | number
    weightInPounds?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    practiceSquadTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredReserveTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedListTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentContractId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    ratingsId?: NullableStringFieldUpdateOperationsInput | string | null
    statsId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableEnumPlayerPositionEnumFieldUpdateOperationsInput | $Enums.PlayerPositionEnum | null
    expectedRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    actualRole?: NullableEnumPlayerRoleEnumFieldUpdateOperationsInput | $Enums.PlayerRoleEnum | null
    recordsHeld?: PlayerUpdaterecordsHeldInput | $Enums.FootballRecordEnum[]
    currentInjury?: NullableEnumInjuryTypeEnumFieldUpdateOperationsInput | $Enums.InjuryTypeEnum | null
    injuryHistory?: PlayerUpdateinjuryHistoryInput | $Enums.InjuryTypeEnum[]
    personalityTraits?: PlayerUpdatepersonalityTraitsInput | $Enums.PlayerPersonalityTraitEnum[]
    offFieldConcerns?: PlayerUpdateoffFieldConcernsInput | $Enums.OffFieldConcernTypeEnum[]
    pastEvents?: PlayerUpdatepastEventsInput | $Enums.PlayerEventEnum[]
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isCaptain?: BoolFieldUpdateOperationsInput | boolean
    isFreeAgent?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isPracticeSquad?: BoolFieldUpdateOperationsInput | boolean
    isTradeBlock?: BoolFieldUpdateOperationsInput | boolean
    offense?: BoolFieldUpdateOperationsInput | boolean
    defense?: BoolFieldUpdateOperationsInput | boolean
    specialTeams?: BoolFieldUpdateOperationsInput | boolean
    draftYear?: NullableIntFieldUpdateOperationsInput | number | null
    draftRound?: NullableIntFieldUpdateOperationsInput | number | null
    isRecordHolder?: BoolFieldUpdateOperationsInput | boolean
    contractNegotiationStatus?: NullableEnumContractNegotiationStatusEnumFieldUpdateOperationsInput | $Enums.ContractNegotiationStatusEnum | null
    lastContractUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    performanceRating?: NullableIntFieldUpdateOperationsInput | number | null
    impactRating?: NullableIntFieldUpdateOperationsInput | number | null
    potential?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    isInjured?: BoolFieldUpdateOperationsInput | boolean
    injuryProneness?: BoolFieldUpdateOperationsInput | boolean
    expectedReturnFromInjury?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    morale?: NullableIntFieldUpdateOperationsInput | number | null
    leadership?: NullableIntFieldUpdateOperationsInput | number | null
    adaptability?: NullableIntFieldUpdateOperationsInput | number | null
    workEthic?: NullableIntFieldUpdateOperationsInput | number | null
    consistency?: NullableIntFieldUpdateOperationsInput | number | null
    clutchFactor?: NullableIntFieldUpdateOperationsInput | number | null
    footballIQ?: NullableIntFieldUpdateOperationsInput | number | null
    popularity?: NullableIntFieldUpdateOperationsInput | number | null
    trainingFocus?: NullableStringFieldUpdateOperationsInput | string | null
    trainingProgress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}